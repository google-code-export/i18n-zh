# Copyright (C) 2007 the Subversion Book team
# 
# Authors:
# Dongsheng Song <dongsheng.song@gmail.com>, 2007
# Xun Leasun <leasun@gmail.com>
# Daijun Sun <daijun@gmail.com>
msgid ""
msgstr ""
"Project-Id-Version: Subversion Book\n"
"POT-Creation-Date: 2007-05-06 12:52+0800\n"
"PO-Revision-Date: 2007-04-30 10:07+0800\n"
"Last-Translator: Dongsheng Song <dongsheng.song@gmail.com>\n"
"Language-Team: Subversion Book team <svnbook-dev@red-bean.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: build/en/book.xml:0(None)
msgid "translator-credits"
msgstr ""
"Dongsheng Song <dongsheng.song@gmail.com>\n"
"Xun Leasun <leasun@gmail.com>\n"
"Daijun Sun <daijun@gmail.com>\n"

#: build/en/book.xml:10017(para)
msgid "There's nothing particularly incorrect about such a layout, but it may or may not seem as intuitive for your users. Especially in large, multi-project situations with many users, those users may tend to be familiar with only one or two of the projects in the repository. But the projects-as-branch-siblings tends to de-emphasize project individuality and focus on the entire set of projects as a single entity. That's a social issue though. We like our originally suggested arrangement for purely practical reasons—it's easier to ask about (or modify, or migrate elsewhere) the entire history of a single project when there's a single repository path that holds the entire history—past, present, tagged, and branched—for that project and that project alone."
msgstr ""

#: build/en/book.xml:10036(title)
msgid "Deciding Where and How to Host Your Repository"
msgstr ""

#: build/en/book.xml:10038(para)
msgid "Before creating your Subversion repository, an obvious question you'll need to answer is where the thing is going to live. This is strongly connected to a myriad of other questions involving how the repository will be accessed (via a Subversion server or directly), by whom (users behind your corporate firewall or the whole world out on the open Internet), what other services you'll be providing around Subversion (repository browsing interfaces, e-mail based commit notification, etc.), your data backup strategy, and so on."
msgstr ""

#: build/en/book.xml:10049(para)
msgid "We cover server choice and configuration in <xref linkend=\"svn.serverconfig\"/>, but the point we'd like to briefly make here is simply that the answers to some of these other questions might have implications that force your hand when deciding where your repository will live. For example, certain deployment scenarios might require accessing the repository via a remote filesystem from multiple computers, in which case (as you'll read in the next section) your choice of a repository back-end data store turns out not to be a choice at all because only one of the available back-ends will work in this scenario."
msgstr ""

#: build/en/book.xml:10060(para)
msgid "To try to address each and every possible way to deploy Subversion is both not possible and outside the scope of this book. We simply encourage you to evaluate your options using these pages and other sources as your reference material, and plan ahead."
msgstr ""

#: build/en/book.xml:1007(title) build/en/book.xml:1014(title)
msgid "Subversion's Architecture"
msgstr "Subversion的架构"

#: build/en/book.xml:10070(title)
msgid "Choosing a Data Store"
msgstr "选择数据存储格式"

#: build/en/book.xml:10072(para)
#, fuzzy
msgid "As of version 1.1, Subversion provides two options for the type of underlying data store—often referred to as <quote>the back-end</quote> or, somewhat confusingly, <quote>the (versioned) filesystem</quote>—that each repository uses. One type of data store keeps everything in a Berkeley DB (or BDB) database environment; repositories that use this type are often referred to as being <quote>BDB-backed</quote>. The other type stores data in ordinary flat files, using a custom format. Subversion developers have adopted the habit of referring to this latter data storage mechanism as <firstterm>FSFS</firstterm><placeholder-1/> —a versioned filesystem implementation that uses the native OS filesystem to store data."
msgstr "在Subversion1.2中，版本库中存储数据有两种方式。一种是在Berkeley DB数据库中存储数据；另一种是使用普通的文件，使用自定义格式。因为Subversion的开发者称版本库为（版本化的）文件系统，他们接受了称后一种存储方式为FSFS<footnote><placeholder-1/></footnote>的习惯，也就是说，使用本地操作系统文件系统来存储数据的版本化文件的系统。"

#: build/en/book.xml:10084(para)
#, fuzzy
msgid "Often pronounced <quote>fuzz-fuzz</quote>, if Jack Repenning has anything to say about it. (This book, however, assumes that the reader is thinking <quote>eff-ess-eff-ess</quote>.)"
msgstr "读作<quote>fuzz-fuzz</quote>, 如果Jack Repenning说起这个问题。"

#: build/en/book.xml:1009(para)
#, fuzzy
msgid "<xref linkend=\"svn.intro.architecture.dia-1\"/> illustrates a <quote>mile-high</quote> view of Subversion's design."
msgstr "<xref linkend=\"svn.intro.architecture.dia-1\"/>给出了Subversion设计总体上的<quote>俯视图</quote>。"

#: build/en/book.xml:10092(para)
#, fuzzy
msgid "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/> gives a comparative overview of Berkeley DB and FSFS repositories."
msgstr "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>从总体上比较了Berkeley DB和FSFS版本库，下一部分将会详细讲述细节。"

#: build/en/book.xml:10097(title)
msgid "Repository Data Store Comparison"
msgstr "版本库数据存储对照表"

#: build/en/book.xml:101(para)
msgid "The problem with such FAQs is that they are not, in a literal sense, FAQs at all. No one ever called the tech support line and asked, <quote>How can we maximize productivity?</quote>. Rather, people asked highly specific questions, like, <quote>How can we change the calendaring system to send reminders two days in advance instead of one?</quote> and so on. But it's a lot easier to make up imaginary Frequently Asked Questions than it is to discover the real ones. Compiling a true FAQ sheet requires a sustained, organized effort: over the lifetime of the software, incoming questions must be tracked, responses monitored, and all gathered into a coherent, searchable whole that reflects the collective experience of users in the wild. It calls for the patient, observant attitude of a field naturalist. No grand hypothesizing, no visionary pronouncements here—open eyes and accurate note-taking are what's needed most."
msgstr "类似的问题完全不符合FAQ的精神。没人会打电话给技术支援中心，询问<quote>怎样提高生产率？</quote>相反，人们经常询问一些非常具体的问题，像<quote>怎样让日程系统提前两天而不是一天提醒相关用户？</quote>等等。但是想象比发现真正的问题更容易。构建一个真实的问题列表需要持之以恒的、有组织的辛勤工作：跨越整个软件生命周期，追踪新提出的问题，监控反馈信息，所有的问题要整理成一个统一的、可查询的整体，并且能够真实的反映所有用户的感受。这需要耐心，如自然学家一样严谨的态度，没有浮华的假设，没有虚幻的断言—相反的，需要开放的视野和精确的记录。"

#: build/en/book.xml:10101(entry)
msgid "Category"
msgstr "分类"

#: build/en/book.xml:10102(entry) build/en/book.xml:12670(entry)
msgid "Feature"
msgstr "特性"

#: build/en/book.xml:10103(entry) build/en/book.xml:10207(title)
msgid "Berkeley DB"
msgstr "Berkeley DB"

#: build/en/book.xml:10104(entry) build/en/book.xml:10335(title)
msgid "FSFS"
msgstr "FSFS"

#: build/en/book.xml:10109(entry)
msgid "Reliability"
msgstr "可靠性"

#: build/en/book.xml:10110(entry)
msgid "Data integrity"
msgstr ""

#: build/en/book.xml:10111(entry)
msgid "when properly deployed, extremely reliable; Berkeley DB 4.4 brings auto-recovery"
msgstr ""

#: build/en/book.xml:10113(entry)
msgid "older versions had some rarely demonstrated, but data-destroying bugs"
msgstr ""

#: build/en/book.xml:10117(entry)
msgid "Sensitivity to interruptions"
msgstr "对操作中断的敏感"

#: build/en/book.xml:10118(entry)
#, fuzzy
msgid "very; crashes and permission problems can leave the database <placeholder-1/>, requiring journaled recovery procedures"
msgstr "很敏感；系统崩溃或者权限问题会导致数据库<placeholder-1/>，需要定期进行恢复。"

#: build/en/book.xml:10119(quote)
msgid "wedged"
msgstr "塞住"

#: build/en/book.xml:10121(entry)
msgid "quite insensitive"
msgstr "十分敏感"

#: build/en/book.xml:10124(entry)
msgid "Accessibility"
msgstr "可用性"

#: build/en/book.xml:10125(entry)
msgid "Usable from a read-only mount"
msgstr "可只读加载"

#: build/en/book.xml:10126(entry) build/en/book.xml:10131(entry)
msgid "no"
msgstr "不能"

#: build/en/book.xml:10127(entry) build/en/book.xml:10132(entry)
#: build/en/book.xml:10137(entry)
msgid "yes"
msgstr "可以"

#: build/en/book.xml:10130(entry)
msgid "Platform-independent storage"
msgstr "存储平台无关"

#: build/en/book.xml:10135(entry)
msgid "Usable over network filesystems"
msgstr "可从网络文件系统访问"

#: build/en/book.xml:10136(entry)
msgid "generally, no"
msgstr ""

#: build/en/book.xml:10140(entry)
msgid "Group permissions handling"
msgstr "组访问权处理"

#: build/en/book.xml:10141(entry)
#, fuzzy
msgid "sensitive to user umask problems; best if accessed by only one user"
msgstr "对于用户的umask设置十分敏感，最好只由一个用户访问。"

#: build/en/book.xml:10143(entry)
msgid "works around umask problems"
msgstr "对umask设置不敏感"

#: build/en/book.xml:10146(entry)
msgid "Scalability"
msgstr "伸缩性"

#: build/en/book.xml:10147(entry)
#, fuzzy
msgid "Repository disk usage"
msgstr "版本库大小"

#: build/en/book.xml:10148(entry)
msgid "larger (especially if logfiles aren't purged)"
msgstr ""

#: build/en/book.xml:10149(entry)
msgid "smaller"
msgstr "较小"

#: build/en/book.xml:10152(entry)
#, fuzzy
msgid "Number of revision trees"
msgstr "可扩展性：修订版本树的数量"

#: build/en/book.xml:10153(entry)
msgid "database; no problems"
msgstr "数据库，没有限制"

#: build/en/book.xml:10154(entry)
#, fuzzy
msgid "some older native filesystems don't scale well with thousands of entries in a single directory"
msgstr "许多古老的本地文件系统在处理单一目录包含上千个条目时出现问题。"

#: build/en/book.xml:10158(entry)
#, fuzzy
msgid "Directories with many files"
msgstr "可扩展性：文件较多的目录"

#: build/en/book.xml:10159(entry)
msgid "slower"
msgstr "较慢"

#: build/en/book.xml:10160(entry)
msgid "faster"
msgstr "较快"

#: build/en/book.xml:10163(entry)
msgid "Performance"
msgstr "性能"

#: build/en/book.xml:10164(entry)
msgid "Checking out latest revision"
msgstr "检出最新的代码"

#: build/en/book.xml:10165(entry) build/en/book.xml:10166(entry)
msgid "no meaningful difference"
msgstr ""

#: build/en/book.xml:10169(entry)
msgid "Large commits"
msgstr "大的提交"

#: build/en/book.xml:10170(entry)
msgid "slower overall, but cost is amortized across the lifetime of the commit"
msgstr ""

#: build/en/book.xml:10172(entry)
#, fuzzy
msgid "faster overall, but finalization delay may cause client timeouts"
msgstr "较快，但是最后较长的延时可能会导致客户端操作超时"

#: build/en/book.xml:10179(para)
msgid "There are advantages and disadvantages to each of these two back-end types. Neither of them is more <quote>official</quote> than the other, though the newer FSFS is the default data store as of Subversion 1.2. Both are reliable enough to trust with your versioned data. But as you can see in <xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>, the FSFS backend provides quite a bit more flexibility in terms of its supported deployment scenarios. More flexibility means you have to work a little harder to find ways to deploy it incorrectly. Those reasons—plus the fact that not using Berkeley DB means there's one fewer component in the system—largely explain why today almost everyone uses the FSFS backend when creating new repositories."
msgstr ""

#: build/en/book.xml:1018(para)
msgid "On one end is a Subversion repository that holds all of your versioned data. On the other end is your Subversion client program, which manages local reflections of portions of that versioned data (called <quote>working copies</quote>). Between these extremes are multiple routes through various Repository Access (RA) layers. Some of these routes go across computer networks and through network servers which then access the repository. Others bypass the network altogether and access the repository directly."
msgstr "图中的一端是保存所有在版本控制下数据的Subversion版本库，另一端是Subvesion的客户端程序，管理着所有在版本控制下数据的本地影射（称为<quote>工作拷贝</quote>），在这两极之间是各种各样的版本库访问（RA）层，某些使用电脑网络通过网络服务器访问版本库，某些则绕过网络服务器直接访问版本库。"

#: build/en/book.xml:10193(para)
msgid "Fortunately, most programs which access Subversion repositories are blissfully ignorant of which back-end data store is in use. And you aren't even necessarily stuck with your first choice of a data store—in the event that you change your mind later, Subversion provides ways of migrating your repository's data into another repository that uses a different back-end data store. We talk more about that later in this chapter."
msgstr ""

#: build/en/book.xml:10202(para)
msgid "The following subsections provide a more detailed look at the available data store types."
msgstr ""

#: build/en/book.xml:10209(para)
msgid "When the initial design phase of Subversion was in progress, the developers decided to use Berkeley DB for a variety of reasons, including its open-source license, transaction support, reliability, performance, API simplicity, thread-safety, support for cursors, and so on."
msgstr "在Subversion的初始设计阶段，开发者因为多种原因而决定采用Berkeley DB，比如它的开源协议、事务支持、可靠性、性能、简单的API、线程安全、支持游标等。"

#: build/en/book.xml:10216(para)
msgid "Berkeley DB provides real transaction support—perhaps its most powerful feature. Multiple processes accessing your Subversion repositories don't have to worry about accidentally clobbering each other's data. The isolation provided by the transaction system is such that for any given operation, the Subversion repository code sees a static view of the database—not a database that is constantly changing at the hand of some other process—and can make decisions based on that view. If the decision made happens to conflict with what another process is doing, the entire operation is rolled back as if it never happened, and Subversion gracefully retries the operation against a new, updated (and yet still static) view of the database."
msgstr "Berkeley DB提供了真正的事务支持－这或许是它最强大的特性，访问你的Subversion版本库的多个进程不必担心偶尔会破坏其他进程的数据。事务系统提供的隔离对于任何给定的操作，Subversion版本库代码看到的只是数据库的静态视图－而不是一个在其他进程影响不断变化的数据库－并能够根据该视图作出决定。如果该决定正好同其他进程所做操作冲突，整个操作会回滚，就像什么都没有发生一样，并且Subversion会优雅的再次对更新的静态视图进行操作。"

#: build/en/book.xml:10231(para)
msgid "Another great feature of Berkeley DB is <firstterm>hot backups</firstterm>—the ability to backup the database environment without taking it <quote>offline</quote>. We'll discuss how to backup your repository in <xref linkend=\"svn.reposadmin.maint.backup\"/>, but the benefits of being able to make fully functional copies of your repositories without any downtime should be obvious."
msgstr "Berkeley DB另一个强大的特性是热备份－不必<quote>脱机</quote>就可以备份数据库环境的能力。我们将会在<xref linkend=\"svn.reposadmin.maint.backup\"/>讨论如何备份你的版本库，能够不停止系统对版本库做全面备份的好处是显而易见的。"

#: build/en/book.xml:10238(para)
#, fuzzy
msgid "Berkeley DB is also a very reliable database system when properly used. Subversion uses Berkeley DB's logging facilities, which means that the database first writes to on-disk log files a description of any modifications it is about to make, and then makes the modification itself. This is to ensure that if anything goes wrong, the database system can back up to a previous <firstterm>checkpoint</firstterm>—a location in the log files known not to be corrupt—and replay transactions until the data is restored to a usable state. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more about Berkeley DB log files."
msgstr "Berkeley DB同时是一个可信赖的数据库系统。Subversion利用了Berkeley DB可以记日志的便利，这意味着数据库先在磁盘上写一个日志文件，描述它将要做的修改，然后再做这些修改。这是为了确保如果如果任何地方出了差错，数据库系统能恢复到先前的检查点—一个日志文件认为没有错误的位置，重新开始事务直到数据恢复为一个可用的状态。关于Berkeley DB日志文件的更多信息请查看<xref linkend=\"svn.reposadmin.maint.diskspace\"/>。"

#: build/en/book.xml:10251(para)
#, fuzzy
msgid "But every rose has its thorn, and so we must note some known limitations of Berkeley DB. First, Berkeley DB environments are not portable. You cannot simply copy a Subversion repository that was created on a Unix system onto a Windows system and expect it to work. While much of the Berkeley DB database format is architecture independent, there are other aspects of the environment that are not. Secondly, Subversion uses Berkeley DB in a way that will not operate on Windows 95/98 systems—if you need to house a BDB-backed repository on a Windows machine, stick with Windows 2000 or newer."
msgstr "但是每朵玫瑰都有刺，我们也必须记录一些Berkeley DB已知的缺陷。首先，Berkeley DB环境不是跨平台的。你不能简单的拷贝一个在Unix上创建的Subversion版本库到一个Windows系统并期望它能够正常工作。尽管Berkeley DB数据库的大部分格式是不受架构约束的，但环境还是有一些方面没有独立出来。其次，使用Berkeley DB的Subversion不能在95/98系统上运行—如果你需要将版本库建在一个Windows机器上，请装到Windows2000或WindowsXP上。另外，Berkeley DB版本库不能放在网络共享文件夹中，尽管Berkeley DB承诺如果按照一套特定规范的话，可以在网络共享上正常运行，但实际上已知的共享类型几乎都不满足这套规范。"

#: build/en/book.xml:10263(para)
msgid "While Berkeley DB promises to behave correctly on network shares that meet a particular set of specifications, <placeholder-1/> most networked filesystem types and appliances do <emphasis>not</emphasis> actually meet those requirements. And in no case can you allow a BDB-backed repository that resides on a network share to be accessed by multiple clients of that share at once (which quite often is the whole point of having the repository live on a network share in the first place)."
msgstr ""

#: build/en/book.xml:10266(para)
msgid "Berkeley DB requires that the underlying filesystem implement strict POSIX locking semantics, and more importantly, the ability to map files directly into process memory."
msgstr ""

#: build/en/book.xml:10280(para)
msgid "If you attempt to use Berkeley DB on a non-compliant remote filesystem, the results are unpredictable—you may see mysterious errors right away, or it may be months before you discover that your repository database is subtly corrupted. You should strongly consider using the FSFS data store for repositories that need to live on a network share."
msgstr ""

#: build/en/book.xml:10289(para)
#, fuzzy
msgid "Finally, because Berkeley DB is a library linked directly into Subversion, it's more sensitive to interruptions than a typical relational database system. Most SQL systems, for example, have a dedicated server process that mediates all access to tables. If a program accessing the database crashes for some reason, the database daemon notices the lost connection and cleans up any mess left behind. And because the database daemon is the only process accessing the tables, applications don't need to worry about permission conflicts. These things are not the case with Berkeley DB, however. Subversion (and programs using Subversion libraries) access the database tables directly, which means that a program crash can leave the database in a temporarily inconsistent, inaccessible state. When this happens, an administrator needs to ask Berkeley DB to restore to a checkpoint, which is a bit of an annoyance. Other things can cause a repository to <quote>wedge</quote> besides crashed processes, such as programs conflicting over ownership and permissions on the database files."
msgstr "最后，因为Berkeley DB的库直接链接到了Subversion中，它对于中断比典型的关系型数据库系统更为敏感。大多数SQL系统，举例来说，有一个主服务进程来协调对数据库表的访问。如果一个访问数据库的程序因为某种原因出现问题，数据库守护进程察觉到连接中断会做一些清理。因为数据库守护进程是唯一访问数据库表的进程，应用程序不需要担心访问许可的冲突。但是，这些情况与Berkeley DB不同。Subversion（和使用Subversion库的程序）直接访问数据库的表，这意味着如果有一个程序崩溃，就会使数据库处于一个暂时的不一致、不可访问的状态。当这种情况发生时，管理员需要让Berkeley DB恢复到一个检查点，这的确有点讨厌。除了崩溃的进程，还有一些情况能让版本库出现异常，比如程序在数据库文件的所有权或访问权限上发生冲突。因为Berkeley DB版本库非常快，并且可以扩展，非常适合使用一个单独的服务进程，通过一个用户来访问—比如Apache的<command moreinfo=\"none\">httpd</command>或<command moreinfo=\"none\">svnserve</command>（参见<xref linkend=\"svn.serverconfig\"/>）—而不是多用户通过<literal moreinfo=\"none\">file:///</literal>或<literal moreinfo=\"none\">svn+ssh://</literal>URL的方式多用户访问。如果将Berkeley DB版本库直接用作多用户访问，请先阅读<xref linkend=\"svn.serverconfig.multimethod\"/>。"

#: build/en/book.xml:10310(para)
msgid "Berkeley DB 4.4 brings (to Subversion 1.4 and better) the ability for Subversion to automatically and transparently recover Berkeley DB environments in need of such recovery. When a Subversion process attaches to a repository's Berkeley DB environment, it uses some process accounting mechanisms to detect any unclean disconnections by previous processes, performs any necessary recovery, and then continues on as if nothing happened. This doesn't completely eliminate instances of repository wedging, but it does drastically reduce the amount of human interaction required to recover from them."
msgstr ""

#: build/en/book.xml:10323(para)
msgid "So while a Berkeley DB repository is quite fast and scalable, it's best used by a single server process running as one user—such as Apache's <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> (see <xref linkend=\"svn.serverconfig\"/>)—rather than accessing it as many different users via <literal moreinfo=\"none\">file://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> URLs. If using a Berkeley DB repository directly as multiple users, be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>."
msgstr ""

#: build/en/book.xml:1033(title)
msgid "Subversion's Components"
msgstr "Subversion的组件"

#: build/en/book.xml:10337(para)
#, fuzzy
msgid "In mid-2004, a second type of repository storage system—one which doesn't use a database at all—came into being. An FSFS repository stores the changes associated with a revision in a single file, and so all of a repository's revisions can be found in a single subdirectory full of numbered files. Transactions are created in separate subdirectories as individual files. When complete, the transaction file is renamed and moved into the revisions directory, thus guaranteeing that commits are atomic. And because a revision file is permanent and unchanging, the repository also can be backed up while <quote>hot</quote>, just like a BDB-backed repository."
msgstr "在2004年中期，另一种版本库存储系统慢慢形成了：一种不需要数据库的存储系统。FSFS版本库在单一文件中存储修订版本树，所以版本库中所有的修订版本都在一个子文件夹中有限的几个文件里。事务在单独的子目录中被创建，创建完成后，一个单独的事务文件被创建并移动到修订版本目录，这保证提交是原子性的。因为一个修订版本文件是持久不可改变的，版本库也可以做到热备份，就象Berkeley DB版本库一样。"

#: build/en/book.xml:1035(para)
msgid "Subversion, once installed, has a number of different pieces. The following is a quick overview of what you get. Don't be alarmed if the brief descriptions leave you scratching your head—there are <emphasis>plenty</emphasis> more pages in this book devoted to alleviating that confusion."
msgstr "安装好的Subversion有几个几个部分组成，本节将简单的介绍一下这些组件。下文的描述或许过于简略，不易理解，不过不用担心，本书后面章节中会用<emphasis>更多的</emphasis>内容来详细阐述这些组件。"

#: build/en/book.xml:10351(para)
#, fuzzy
msgid "The FSFS revision files describe a revision's directory structure, file contents, and deltas against files in other revision trees. Unlike a Berkeley DB database, this storage format is portable across different operating systems and isn't sensitive to CPU architecture. Because there's no journaling or shared-memory files being used, the repository can be safely accessed over a network filesystem and examined in a read-only environment. The lack of database overhead also means that the overall repository size is a bit smaller."
msgstr "修订版本文件格式代表了一个修订版本的目录结构，文件内容，和其它修订版本树中相关信息。不像Berkeley DB数据库，这种存储格式可跨平台并且与CPU架构无关。因为没有日志或用到共享内存的文件，数据库能被网络文件系统安全的访问和在只读环境下检查。缺少数据库花消同时也意味着版本库的总体体积可以稍小一点。"

#: build/en/book.xml:10362(para)
#, fuzzy
msgid "FSFS has different performance characteristics too. When committing a directory with a huge number of files, FSFS is able to more quickly append directory entries. On the other hand, FSFS writes the latest version of a file as a delta against an earlier version, which means that checking out the latest tree is a bit slower than fetching the fulltexts stored in a Berkeley DB HEAD revision. FSFS also has a longer delay when finalizing a commit, which could in extreme cases cause clients to time out while waiting for a response."
msgstr "FSFS也有一种不同的性能特性。当提交大量文件时，FSFS使用O(N)算法来追加条目，而Berkeley DB则用(N^2)算法来重写整个目录。另一方面，FSFS通过写入与上一个版本比较的变化来记录新版本，这也意味着获取最新修订版本时会比Berkeley DB慢一点，提交时FSFS也会有一个更长的延迟，在某些极端情况下会导致客护端在等待回应时超时。"

#: build/en/book.xml:10373(para)
#, fuzzy
msgid "The most important distinction, however, is FSFS's inability to be <quote>wedged</quote> when something goes wrong. If a process using a Berkeley DB database runs into a permissions problem or suddenly crashes, the database can be left in an unusable state until an administrator recovers it. If the same scenarios happen to a process using an FSFS repository, the repository isn't affected at all. At worst, some transaction data is left behind."
msgstr "最重要的区别是当出现错误时FSFS不会楔住的能力。如果使用Berkeley DB的进程发生许可错误或突然崩溃，数据库会一直无法使用，直到管理员恢复。假如在应用FSFS版本库时发生同样的情况，版本库不会受到任何干扰，最坏情况下也就是会留下一些事务数据。"

#: build/en/book.xml:10382(para)
msgid "The only real argument against FSFS is its relative immaturity compared to Berkeley DB. Unlike Berkeley DB, which has years of history, its own dedicated development team and, now, Oracle's mighty name attached to it, <placeholder-1/> FSFS is a much newer bit of engineering. Prior to Subversion 1.4, it was still shaking out some pretty serious data integrity bugs which, while only triggered in very rare cases, nonetheless did occur. That said, FSFS has quickly become the back-end of choice for some of the largest public and private Subversion repositories, and promises a lower barrier to entry for Subversion across the board."
msgstr ""

#: build/en/book.xml:10387(para)
msgid "Oracle bought Sleepycat and its flagship software, Berkeley DB, on Valentine's Day in 2006."
msgstr ""

#: build/en/book.xml:10407(title)
#, fuzzy
msgid "Creating and Configuring Your Repository"
msgstr "创建一个新的Subversion版本库。"

#: build/en/book.xml:10409(para)
msgid "In <xref linkend=\"svn.reposadmin.planning\"/>, we looked at some of the important decisions that should be made before creating and configuring your Subversion repository. Now, we finally get to get our hands dirty! In this section, we'll see how to actually create a Subversion repository and configure it to perform custom actions when special repository events occur."
msgstr ""

#: build/en/book.xml:10419(title)
msgid "Creating the Repository"
msgstr "创建版本库"

#: build/en/book.xml:10421(para)
#, fuzzy
msgid "Subversion repository creation is an incredibly simple task. The <command moreinfo=\"none\">svnadmin</command> utility that comes with Subversion provides a subcommand (<literal moreinfo=\"none\">create</literal>) for doing just that."
msgstr "创建一个 Subversion 版本库出乎寻常的简单。 Subversion 提供的<command moreinfo=\"none\">svnadmin</command> 工具，有一个执行这个功能的子命令。要建立一个新的版本库，只需要运行："

#: build/en/book.xml:10426(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/repos\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/repos\n"

#: build/en/book.xml:1043(term) build/en/book.xml:18147(primary)
#: build/en/book.xml:18253(primary) build/en/book.xml:18323(primary)
#: build/en/book.xml:18408(primary) build/en/book.xml:18545(primary)
#: build/en/book.xml:18623(primary) build/en/book.xml:18761(primary)
#: build/en/book.xml:18936(primary) build/en/book.xml:19049(primary)
#: build/en/book.xml:19301(primary) build/en/book.xml:19415(primary)
#: build/en/book.xml:19467(primary) build/en/book.xml:19569(primary)
#: build/en/book.xml:19730(primary) build/en/book.xml:19842(primary)
#: build/en/book.xml:19942(primary) build/en/book.xml:20186(primary)
#: build/en/book.xml:20307(primary) build/en/book.xml:20393(primary)
#: build/en/book.xml:20507(primary) build/en/book.xml:20585(primary)
#: build/en/book.xml:20661(primary) build/en/book.xml:20743(primary)
#: build/en/book.xml:20830(primary) build/en/book.xml:20965(primary)
#: build/en/book.xml:21054(primary) build/en/book.xml:21158(primary)
#: build/en/book.xml:21563(primary) build/en/book.xml:21723(primary)
#: build/en/book.xml:21816(primary)
msgid "svn"
msgstr "svn"

#: build/en/book.xml:10430(para)
msgid "This creates a new repository in the directory <filename moreinfo=\"none\">/path/to/repos</filename>, and with the default filesystem data store. Prior to Subversion 1.2, the default was to use Berkeley DB; the default is now FSFS. You can explicitly choose the filesystem type using the <option>--fs-type</option> argument, which accepts as a parameter either <literal moreinfo=\"none\">fsfs</literal> or <literal moreinfo=\"none\">bdb</literal>."
msgstr ""

#: build/en/book.xml:10439(screen)
#, no-wrap
msgid ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"

#: build/en/book.xml:10445(screen)
#, no-wrap
msgid ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"

#: build/en/book.xml:1045(para)
msgid "The command-line client program."
msgstr "命令行客户端程序。"

#: build/en/book.xml:10451(para)
#, fuzzy
msgid "After running this simple command, you have a Subversion repository."
msgstr "目前Subversion有已实现了九种钩子："

#: build/en/book.xml:10455(para)
#, fuzzy
msgid "The path argument to <command moreinfo=\"none\">svnadmin</command> is just a regular filesystem path and not a URL like the <command moreinfo=\"none\">svn</command> client program uses when referring to repositories. Both <command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command> are considered server-side utilities—they are used on the machine where the repository resides to examine or modify aspects of the repository, and are in fact unable to perform tasks across a network. A common mistake made by Subversion newcomers is trying to pass URLs (even <quote>local</quote><literal moreinfo=\"none\">file://</literal> ones) to these two programs."
msgstr "你可能已经注意到了，<command moreinfo=\"none\">svnadmin</command>命令的路径参数只是一个普通的文件系统路径，而不是一个<command moreinfo=\"none\">svn</command>客户端程序访问版本库时使用的URL。<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>都被认为是服务器端工具—它们在版本库所在的机器上使用，用来检查或修改版本库，不能通过网络来执行任务。一个Subversion的新手通常会犯的错误，就是试图将URL（甚至<quote>本地</quote><literal moreinfo=\"none\">file:</literal>路径）传给这两个程序。"

#: build/en/book.xml:10468(para)
#, fuzzy
msgid "Present in the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository is the implementation of the versioned filesystem. Your new repository's versioned filesystem begins life at revision 0, which is defined to consist of nothing but the top-level root (<filename moreinfo=\"none\">/</filename>) directory. Initially, revision 0 also has a single revision property, <literal moreinfo=\"none\">svn:date</literal>, set to the time at which the repository was created."
msgstr "这个命令在目录<filename moreinfo=\"none\">/path/to/repos</filename>创建了一个新的版本库。这个新的版本库会以修订版本版本0开始其生命周期，里面除了最上层的根目录(<filename moreinfo=\"none\">/</filename>)，什么都没有。刚开始，修订版本0有一个修订版本属性<literal moreinfo=\"none\">svn:date</literal>，设置为版本库创建的时间。"

#: build/en/book.xml:10477(para)
msgid "Now that you have a repository, it's time to customize it."
msgstr ""

#: build/en/book.xml:10481(para)
#, fuzzy
msgid "While some parts of a Subversion repository—such as the configuration files and hook scripts—are meant to be examined and modified manually, you shouldn't (and shouldn't need to) tamper with the other parts of the repository <quote>by hand</quote>. The <command moreinfo=\"none\">svnadmin</command> tool should be sufficient for any changes necessary to your repository, or you can look to third-party tools (such as Berkeley DB's tool suite) for tweaking relevant subsections of the repository. Do <emphasis>not</emphasis> attempt manual manipulation of your version control history by poking and prodding around in your repository's data store files!"
msgstr "一般来说，你不需要手动干预版本库。<command moreinfo=\"none\">svnadmin</command>工具应该足以用来处理对版本库的任何修改，或者你也可以使用第三方工具（比如Berkeley DB的工具包）来调整部分版本库。不过还是会有些例外情况，我们会在这里提到。"

#: build/en/book.xml:10499(title)
msgid "Implementing Repository Hooks"
msgstr "实现版本库钩子"

#: build/en/book.xml:1050(term) build/en/book.xml:24024(command)
#: build/en/book.xml:24029(primary) build/en/book.xml:24033(refname)
msgid "svnversion"
msgstr "svnversion"

#: build/en/book.xml:10501(para)
msgid "A <firstterm>hook</firstterm> is a program triggered by some repository event, such as the creation of a new revision or the modification of an unversioned property. Some hooks (the so-called <quote>pre hooks</quote>) run in advance of a repository operation and provide a means by which to both report what is about to happen and to prevent it from happening at all. Other hooks (the <quote>post hooks</quote>) run after the completion of a repository event, and are useful for reporting purposes only. Each hook is handed enough information to tell what that event is (or was), the specific repository changes proposed (or completed), and the username of the person who triggered the event."
msgstr ""

#: build/en/book.xml:10514(para)
msgid "The <filename moreinfo=\"none\">hooks</filename> subdirectory is, by default, filled with templates for various repository hooks."
msgstr "默认情况下，钩子的子目录中包含各种版本库钩子模板。"

#: build/en/book.xml:10518(screen)
#, no-wrap
msgid ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"
msgstr ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"

#: build/en/book.xml:1052(para)
msgid "A program for reporting the state (in terms of revisions of the items present) of a working copy."
msgstr "此工具用来显示工作副本的状态（用术语来说，就是当前项目的修订版本）。"

#: build/en/book.xml:10525(para)
#, fuzzy
msgid "There is one template for each hook that the Subversion repository supports, and by examining the contents of those template scripts, you can see what triggers each script to run and what data is passed to that script. Also present in many of these templates are examples of how one might use that script, in conjunction with other Subversion-supplied programs, to perform common useful tasks. To actually install a working hook, you need only place some executable program or script into the <filename moreinfo=\"none\">repos/hooks</filename> directory which can be executed as the name (like <command moreinfo=\"none\">start-commit</command> or <command moreinfo=\"none\">post-commit</command>) of the hook."
msgstr "对每种Subversion版本库支持的钩子的都有一个模板，通过查看这些脚本的内容，你能看到是什么事件触发了脚本及如何给传脚本传递数据。同时，这些模版也是如何使用这些脚本，结合Subversion支持的工具来完成有用任务的例子。要实际安装一个可用的钩子，你需要在<filename moreinfo=\"none\">repos/hooks</filename>目录下安装一些与钩子同名（如 <command moreinfo=\"none\">start-commit</command>或者<command moreinfo=\"none\">post-commit</command>）的可执行程序或脚本。"

#: build/en/book.xml:10538(para)
msgid "On Unix platforms, this means supplying a script or program (which could be a shell script, a Python program, a compiled C binary, or any number of other things) named exactly like the name of the hook. Of course, the template files are present for more than just informational purposes—the easiest way to install a hook on Unix platforms is to simply copy the appropriate template file to a new file that lacks the <literal moreinfo=\"none\">.tmpl</literal> extension, customize the hook's contents, and ensure that the script is executable. Windows, however, uses file extensions to determine whether or not a program is executable, so you would need to supply a program whose basename is the name of the hook, and whose extension is one of the special extensions recognized by Windows for executable programs, such as <filename moreinfo=\"none\">.exe</filename> or <filename moreinfo=\"none\">.com</filename> for programs, and <filename moreinfo=\"none\">.bat</filename> for batch files."
msgstr "在Unix平台上，这意味着要提供一个与钩子同名的脚本或程序（可能是shell 脚本，Python 程序，编译过的c语言二进制文件或其他东西）。当然，脚本模板文件不仅仅是展示了一些信息—在Unix下安装钩子最简单的办法就是拷贝这些模板，并且去掉.tmpl扩展名，然后自定义钩子的内容，确定脚本是可运行的。Windows用文件的扩展名来决定一个程序是否可运行，所以你要使程序的基本名与钩子同名，同时，它的扩展名是Windows系统所能辨认的，例如<filename moreinfo=\"none\">exe</filename>、<filename moreinfo=\"none\">com</filename>和批处理的<filename moreinfo=\"none\">bat</filename>。"

#: build/en/book.xml:10557(para)
#, fuzzy
msgid "For security reasons, the Subversion repository executes hook programs with an empty environment—that is, no environment variables are set at all, not even <literal moreinfo=\"none\">$PATH</literal> (or <literal moreinfo=\"none\">%PATH%</literal>, under Windows). Because of this, many administrators are baffled when their hook program runs fine by hand, but doesn't work when run by Subversion. Be sure to explicitly set any necessary environment variables in your hook program and/or use absolute paths to programs."
msgstr "由于安全原因，Subversion版本库在一个空环境中执行钩子脚本—就是没有任何环境变量，甚至没有<literal moreinfo=\"none\">$PATH</literal>或<literal moreinfo=\"none\">%PATH%</literal>。由于这个原因，许多管理员会感到很困惑，它们的钩子脚本手工运行时正常，可在Subversion中却不能运行。要注意，必须在你的钩子中设置好环境变量或为你的程序指定好绝对路径。"

#: build/en/book.xml:10568(para)
#, fuzzy
msgid "Subversion will attempt to execute hooks as the same user who owns the process which is accessing the Subversion repository. In most cases, the repository is being accessed via a Subversion server, so this user is the same user as which that server runs on the system. The hooks themselves will need to be configured with OS-level permissions that allow that user to execute them. Also, this means that any file or programs (including the Subversion repository itself) accessed directly or indirectly by the hook will be accessed as the same user. In other words, be alert to potential permission-related problems that could prevent the hook from performing the tasks it is designed to perform."
msgstr "Subversion会试图以当前访问版本库的用户身份执行钩子。通常，对版本库的访问总是通过Apache HTTP服务器和mod_dav_svn进行，因此，执行钩子的用户就是运行Apache的用户。钩子本身需要具有操作系统级的访问许可，用户可以运行它。另外，其它被钩子直接或间接使用的文件或程序（包括Subversion版本库本身）也要被同一个用户访问。换句话说，要注意潜在的访问控制问题，它可能会让你的钩子无法按照你的目的顺利执行。"

#: build/en/book.xml:1058(term) build/en/book.xml:10734(title)
#: build/en/book.xml:22908(command) build/en/book.xml:22998(primary)
#: build/en/book.xml:23044(primary) build/en/book.xml:23102(primary)
#: build/en/book.xml:23201(primary) build/en/book.xml:23247(primary)
#: build/en/book.xml:23318(primary) build/en/book.xml:23365(primary)
#: build/en/book.xml:23396(primary) build/en/book.xml:23461(primary)
#: build/en/book.xml:23512(primary) build/en/book.xml:23564(primary)
#: build/en/book.xml:23609(primary) build/en/book.xml:23664(primary)
#: build/en/book.xml:23730(primary) build/en/book.xml:23784(primary)
#: build/en/book.xml:23823(primary)
msgid "svnlook"
msgstr "svnlook"

#: build/en/book.xml:10581(para)
msgid "There are nine hooks implemented by the Subversion repository, and you can get details about each of them in <xref linkend=\"svn.ref.reposhooks\"/>. As a repository administrator, you'll need to decide which of hooks you wish to implement (by way of providing an appropriately named and permissioned hook program), and how. This decision needs to be made with the bigger picture of how repository is deployed in mind. For example, if you are using server configuration stuffs to determine which usernames are permitted to commit changes to your repository, then you don't need to do this sort of access control via the hook system."
msgstr ""

#: build/en/book.xml:10593(para)
msgid "There is no shortage of Subversion hook programs and scripts freely available either from the Subversion community itself or elsewhere. These scripts cover a wide range of utility—basic access control, policy adherence checking, issue tracker integration, email- or syndication-based commit notification, and beyond. See <xref linkend=\"svn.3rdparty\"/> for discussion of some of the most commonly used hook programs. Or, if you wish to write your own, see <xref linkend=\"svn.developer\"/>."
msgstr ""

#: build/en/book.xml:1060(para)
#, fuzzy
msgid "A tool for directly inspecting a Subversion repository."
msgstr "查看Subversion版本库的工具。"

#: build/en/book.xml:10603(para)
msgid "While hook scripts can be leveraged to do almost anything, there is one dimension in which hook script authors should show restraint: do <emphasis>not</emphasis> modify a commit transaction using hook scripts. While it might be tempting to use hook scripts to automatically correct errors or shortcomings or policy violations present in the files being committed, doing so can cause problems. Subversion keeps client-side caches of certain bits of repository data, and if you change a commit transaction in this way, those caches become indetectably stale. This inconsistency can lead to surprising and unexpected behavior. Instead of modifying the transaction, you should simply <emphasis>validate</emphasis> the transaction in the <filename moreinfo=\"none\">pre-commit</filename> hook and reject the commit if it does not meet the desired requirements. As an added bonus, your users will learn the value of careful, compliance-minded work habits."
msgstr ""

#: build/en/book.xml:10626(title)
msgid "Berkeley DB Configuration"
msgstr "Berkeley DB配置"

#: build/en/book.xml:10628(para)
#, fuzzy
msgid "A Berkeley DB environment is an encapsulation of one or more databases, log files, region files and configuration files. The Berkeley DB environment has its own set of default configuration values for things like the number of database locks allowed to be taken out at any given time, or the maximum size of the journaling log files, etc. Subversion's filesystem logic additionally chooses default values for some of the Berkeley DB configuration options. However, sometimes your particular repository, with its unique collection of data and access patterns, might require a different set of configuration option values."
msgstr "Berkeley DB环境是对一个或多个数据库、日志文件、区域文件和配置文件的封装。Berkeley DB环境对许多参数有自己的缺省值，例如任何时间里可用的数据库锁定数目、日志文件的最大值等。Subversion文件系统会使用Berkeley DB的默认值。 不过，有时候你的特定版本库与它独特的数据集合和访问类型，可能需要不同的配置选项。"

#: build/en/book.xml:10640(para)
#, fuzzy
msgid "The producers of Berkeley DB understand that different applications and database environments have different requirements, and so they have provided a mechanism for overriding at runtime many of the configuration values for the Berkeley DB environment. Berkeley checks for the presence of a file named <filename moreinfo=\"none\">DB_CONFIG</filename> in the environment directory, and parses the options found in that file for use with that particular Berkeley DB environment."
msgstr "Sleepycat（Berkeley DB的制造厂商）的人们清楚不同的数据库有不同的需求，所以他们提供了在运行中覆盖Berkeley DB环境配置参数的机制。Berkeley在每一个环境目录中检查是否存在一个名叫<filename moreinfo=\"none\">DB_CONFIG</filename>的文件，然后解析其中的参数成为Berkeley环境所用的选项。"

#: build/en/book.xml:10649(para)
#, fuzzy
msgid "The Berkeley DB configuration file for a BDB-backed repository is located in the repository's <filename moreinfo=\"none\">db</filename> subdirectory, at <filename moreinfo=\"none\">db/DB_CONFIG</filename>. Subversion itself creates this file when it creates the rest of the repository. The file initially contains some default options, as well as pointers to the Berkeley DB online documentation so you can read about what those options do. Of course, you are free to add any of the supported Berkeley DB options to your <filename moreinfo=\"none\">DB_CONFIG</filename> file. Just be aware that while Subversion never attempts to read or interpret the contents of the file, and makes no direct use of the option settings in it, you'll want to avoid any configuration changes that may cause Berkeley DB to behave in a fashion that is at odds with what Subversion might expect. Also, changes made to <filename moreinfo=\"none\">DB_CONFIG</filename> won't take effect until you recover the database environment (using <command moreinfo=\"none\">svnadmin recover</command>)."
msgstr "你的版本库的Berkeley配置文件位于<filename moreinfo=\"none\">db</filename>目录的<filename moreinfo=\"none\">repos/db/DB_CONFIG</filename>， Subversion在创建版本库时自己创建了这个文件。这个文件初始时包含了一些默认选项，也包含了Berkeley DB在线文档，使你能够了解这些选项是做什么的。当然，你也可以为你的<filename moreinfo=\"none\">DB_CONFIG</filename> 文件添加任何Berkeley DB支持的选项。需要注意到，虽然Subversion不会尝试读取并解析这个文件，或使用其中的设置，你一定要避免会导致Berkeley DB按照Subversion代码不习惯的方式工作的修改。另外，<filename moreinfo=\"none\">DB_CONFIG</filename>的修改在复原数据库环境（用<command moreinfo=\"none\">svnadmin recover</command>）之前不会产生任何效果。"

#: build/en/book.xml:1065(term) build/en/book.xml:10701(title)
#: build/en/book.xml:21967(command) build/en/book.xml:22102(primary)
#: build/en/book.xml:22165(primary) build/en/book.xml:22205(primary)
#: build/en/book.xml:22315(primary) build/en/book.xml:22347(primary)
#: build/en/book.xml:22389(primary) build/en/book.xml:22421(primary)
#: build/en/book.xml:22469(primary) build/en/book.xml:22535(primary)
#: build/en/book.xml:22583(primary) build/en/book.xml:22623(primary)
#: build/en/book.xml:22705(primary) build/en/book.xml:22751(primary)
#: build/en/book.xml:22805(primary) build/en/book.xml:22865(primary)
msgid "svnadmin"
msgstr "svnadmin"

#: build/en/book.xml:1067(para)
msgid "A tool for creating, tweaking or repairing a Subversion repository."
msgstr "建立、调整和修复Subversion版本库的工具。"

#: build/en/book.xml:10676(title)
msgid "Repository Maintenance"
msgstr "版本库维护"

#: build/en/book.xml:10678(para)
#, fuzzy
msgid "Maintaining a Subversion repository can be a daunting task, mostly due to the complexities inherent in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield them to accomplish tasks such as repository data migration, upgrades, backups and cleanups."
msgstr "维护一个Subversion版本库是一项令人沮丧的工作，主要因为有数据库后端与生俱来的复杂性。做好这项工作需要知道一些工具——它们是什么，什么时候用以及如何使用。这一节将会向你介绍Subversion自带的版本库管理工具，以及如何使用它们来完成诸如版本库移植、升级、备份和整理之类的任务。"

#: build/en/book.xml:10689(title)
msgid "An Administrator's Toolkit"
msgstr "管理员的工具箱"

#: build/en/book.xml:10691(para)
msgid "Subversion provides a handful of utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools."
msgstr "Subversion提供了一些用来创建、查看、修改和修复版本库的工具。让我们首先详细了解一下每个工具，然后，我们再看一下仅在Berkeley DB后端分发版本中提供的版本数据库工具。"

#: build/en/book.xml:10703(para)
#, fuzzy
msgid "The <command moreinfo=\"none\">svnadmin</command> program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of <command moreinfo=\"none\">svnadmin</command> is similar to that of other Subversion command-line programs:"
msgstr "<command moreinfo=\"none\">svnadmin</command>程序是版本库管理员最好的朋友。除了提供创建Subversion版本库的功能，这个程序使你可以维护这些版本库。<command moreinfo=\"none\">svnadmin</command>的语法跟<command moreinfo=\"none\">svnlook</command>类似："

#: build/en/book.xml:10711(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"

#: build/en/book.xml:10724(para)
#, fuzzy
msgid "We've already mentioned <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">create</literal> subcommand (see <xref linkend=\"svn.reposadmin.basics.creating\"/>). Most of the others we will cover as they become topically relevant later in this chapter. And you can consult <xref linkend=\"svn.ref.svnadmin\"/> for a full rundown of subcommands and what each of them offers."
msgstr "我们已经提过<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">create</literal>子命令（参照<xref linkend=\"svn.reposadmin.create\"/>）。本章中我们会详细讲解大多数其他的命令。现在，我们来简单的看一下每个可用的子命令提供了什么功能。"

#: build/en/book.xml:1073(term) build/en/book.xml:10859(title)
msgid "svndumpfilter"
msgstr "svndumpfilter"

#: build/en/book.xml:10736(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> is a tool provided by Subversion for examining the various revisions and transactions in a repository. No part of this program attempts to change the repository. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the <command moreinfo=\"none\">pre-commit</command> hook) or that were just committed (in the case of the <command moreinfo=\"none\">post-commit</command> hook) to the repository. A repository administrator may use this tool for diagnostic purposes."
msgstr "<command moreinfo=\"none\">svnlook</command>是Subversion提供的用来查看版本库中不同的修订版本和事务。这个程序不会修改版本库内容－这是个<quote>只读</quote>的工具。<command moreinfo=\"none\">svnlook</command>通常用在版本库钩子程序中，用来记录版本库即将提交（<command moreinfo=\"none\">用在pre-commit钩子时）</command>或者已经提交的（用在<command moreinfo=\"none\">post-commit</command>钩子时）修改。版本库管理员可以将这个工具用于诊断。"

#: build/en/book.xml:10747(para)
msgid "<command moreinfo=\"none\">svnlook</command> has a straightforward syntax:"
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:1075(para)
msgid "A program for filtering Subversion repository dump streams."
msgstr "过滤Subversion版本库转储数据流的工具。"

#: build/en/book.xml:10750(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"
msgstr ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"

#: build/en/book.xml:10761(para)
#, fuzzy
msgid "Nearly every one of <command moreinfo=\"none\">svnlook</command>'s subcommands can operate on either a revision or a transaction tree, printing information about the tree itself, or how it differs from the previous revision of the repository. You use the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options to specify which revision or transaction, respectively, to examine. In the absence of both the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options, <command moreinfo=\"none\">svnlook</command> will examine the youngest (or <quote>HEAD</quote>) revision in the repository. So the following two commands do exactly the same thing when 19 is the youngest revision in the repository located at <filename moreinfo=\"none\">/path/to/repos</filename>:"
msgstr "几乎<command moreinfo=\"none\">svnlook</command>的每一个子命令都能操作修订版本或事务树，显示树本身的信息，或是它与版本库中上一个修订版本的不同。你可以用<option>--revision</option> 和 <option>--transaction</option>选项指定要查看的修订版本或事务。注意，虽然修订版本号看起来像自然数，但是事务名称是包含英文字母与数字的字符串。请记住文件系统只允许浏览未提交的事务（还没有形成一个新的修订版本的事务）。多数版本库没有这种事务，因为事务通常或者被提交了（这样便不能被查看），或者被中止并删除了。"

#: build/en/book.xml:10776(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"

#: build/en/book.xml:10781(para)
#, fuzzy
msgid "The only exception to these rules about subcommands is the <command moreinfo=\"none\">svnlook youngest</command> subcommand, which takes no options, and simply prints out the repository's youngest revision number."
msgstr "这些子命令的唯一例外，是<command moreinfo=\"none\">svnlook youngest</command>命令，它不需要选项，只会显示出<literal moreinfo=\"none\">HEAD</literal>的修订版本号。"

#: build/en/book.xml:10786(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"
msgstr ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"

#: build/en/book.xml:10792(para)
msgid "Keep in mind that the only transactions you can browse are uncommitted ones. Most repositories will have no such transactions, because transactions are usually either committed (in which case, you should access them as revision with the <option>--revision (-r)</option> option) or aborted and removed."
msgstr ""

#: build/en/book.xml:10800(para)
msgid "Output from <command moreinfo=\"none\">svnlook</command> is designed to be both human- and machine-parsable. Take as an example the output of the <literal moreinfo=\"none\">info</literal> subcommand:"
msgstr "<command moreinfo=\"none\">svnlook</command>的输出被设计为人和机器都易理解，拿<literal moreinfo=\"none\">info</literal>子命令举例来说："

#: build/en/book.xml:10804(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon， 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"

#: build/en/book.xml:1081(term) build/en/book.xml:16483(term)
#: build/en/book.xml:24178(command) build/en/book.xml:24183(literal)
msgid "mod_dav_svn"
msgstr "mod_dav_svn"

#: build/en/book.xml:10813(para)
msgid "The output of the <literal moreinfo=\"none\">info</literal> subcommand is defined as:"
msgstr "<literal moreinfo=\"none\">info</literal>子命令的输出定义如下："

#: build/en/book.xml:10818(para)
msgid "The author, followed by a newline."
msgstr "作者，后接换行。"

#: build/en/book.xml:10821(para)
msgid "The date, followed by a newline."
msgstr "日期，后接换行。"

#: build/en/book.xml:10824(para)
msgid "The number of characters in the log message, followed by a newline."
msgstr "日志消息的字数，后接换行。"

#: build/en/book.xml:10828(para)
msgid "The log message itself, followed by a newline."
msgstr "日志信息本身， 后接换行。"

#: build/en/book.xml:1083(para)
msgid "A plug-in module for the Apache HTTP Server, used to make your repository available to others over a network."
msgstr "Apache HTTP服务器的一个插件，使版本库可以通过网络访问。"

#: build/en/book.xml:10832(para)
#, fuzzy
msgid "This output is human-readable, meaning items like the datestamp are displayed using a textual representation instead of something more obscure (such as the number of nanoseconds since the Tasty Freeze guy drove by). But the output is also machine-parsable—because the log message can contain multiple lines and be unbounded in length, <command moreinfo=\"none\">svnlook</command> provides the length of that message before the message itself. This allows scripts and other wrappers around this command to make intelligent decisions about the log message, such as how much memory to allocate for the message, or at least how many bytes to skip in the event that this output is not the last bit of data in the stream."
msgstr "这种输出是人可阅读的，像是时间戳这种有意义的条目，使用文本表示，而不是其他比较晦涩的方式（例如许多无聊的人推荐的十亿分之一秒的数量）。这种输出也是机器可读的—因为日志信息可以有多行，没有长度的限制，<command moreinfo=\"none\">svnlook</command>在日志消息之前提供了消息的长度，这使得脚本或者其他对这个命令进行的封装提供了更强的功能，比如日志消息使用了多少内存，或在这个输出成为最后一个字节之前应该略过多少字节。"

#: build/en/book.xml:10846(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> can perform a variety of other queries: displaying subsets of bits of information we've mentioned previously, recursively listing versioned directory trees, reporting which paths were modified in a given revision or transaction, showing textual and property differences made to files and directories, and so on. See <xref linkend=\"svn.ref.svnlook\"/> for a full reference of <command moreinfo=\"none\">svnlook</command>'s features."
msgstr "<command moreinfo=\"none\">svnlook</command>还可以做很多别的查询，显示我们先前提到的信息的一些子集，报告指定的修订版本或事务中哪些路径曾经被修改过，显示对文件和目录做过的文本和属性的修改，等等。下面是<command moreinfo=\"none\">svnlook</command>命令能接受的子命令的介绍，以及这些子命令的输出："

#: build/en/book.xml:10861(para)
#, fuzzy
msgid "While it won't be the most commonly used tool at the administrator's disposal, <command moreinfo=\"none\">svndumpfilter</command> provides a very particular brand of useful functionality—the ability to quickly and easily modify streams of Subversion repository history data by acting as a path-based filter."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:10868(para)
msgid "The syntax of <command moreinfo=\"none\">svndumpfilter</command> is as follows:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的语法如下："

#: build/en/book.xml:10871(screen)
#, no-wrap
msgid ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"
msgstr ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"

#: build/en/book.xml:10883(para)
msgid "There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream:"
msgstr "有意义的子命令只有两个。你可以使用这两个子命令说明你希望保留和不希望保留的路径："

#: build/en/book.xml:10889(literal)
msgid "exclude"
msgstr "exclude"

#: build/en/book.xml:10891(para)
msgid "Filter out a set of paths from the dump data stream."
msgstr "将指定路径的数据从转储数据流中排除。"

#: build/en/book.xml:10897(literal)
msgid "include"
msgstr "include"

#: build/en/book.xml:10899(para)
msgid "Allow only the requested set of paths to pass through the dump data stream."
msgstr "将指定路径的数据添加到转储数据流中。"

#: build/en/book.xml:1090(term) build/en/book.xml:12672(entry)
#: build/en/book.xml:1624(literal) build/en/book.xml:23864(command)
msgid "svnserve"
msgstr "svnserve"

#: build/en/book.xml:10905(para)
#, fuzzy
msgid "You can learn more about these subcommands and <command moreinfo=\"none\">svndumpfilter</command>'s unique purpose in <xref linkend=\"svn.reposadmin.maint.filtering\"/>."
msgstr "关于<command moreinfo=\"none\">svn update</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.update\"/>。"

#: build/en/book.xml:10912(title) build/en/book.xml:1099(term)
msgid "svnsync"
msgstr "svnsync"

#: build/en/book.xml:10914(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program, which is new to the 1.4 release of Subversion, provides all the functionality required for maintaining a read-only mirror of a Subversion repository. The program really has one job—to transfer one repository's versioned history into another repository. And while there are few ways to do that, its primary strength is that it can operate remotely—the <quote>source</quote> and <quote>sink</quote><placeholder-1/> repositories may be on different computers from each other and from <command moreinfo=\"none\">svnsync</command> itself."
msgstr ""

#: build/en/book.xml:1092(para)
msgid "A custom standalone server program, runnable as a daemon process or invokable by SSH; another way to make your repository available to others over a network."
msgstr "一个单独运行的服务器程序，可以作为守护进程或由SSH调用。这是另一种使版本库可以通过网络访问的方式。"

#: build/en/book.xml:10924(para)
#, fuzzy
msgid "Or is that, the <quote>sync</quote>?"
msgstr "<quote>锁定</quote>的三种含义"

#: build/en/book.xml:10929(para)
msgid "As you might expect, <command moreinfo=\"none\">svnsync</command> has a syntax that looks very much like every other program we've mentioned in this chapter:"
msgstr ""

#: build/en/book.xml:10933(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"
msgstr ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"

#: build/en/book.xml:10947(para)
#, fuzzy
msgid "We talk more about replication repositories with <command moreinfo=\"none\">svnsync</command> in <xref linkend=\"svn.reposadmin.maint.replication\"/>."
msgstr "关于<command moreinfo=\"none\">svn status</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:10954(title)
msgid "Berkeley DB Utilities"
msgstr "Berkeley DB工具"

#: build/en/book.xml:10956(para)
#, fuzzy
msgid "If you're using a Berkeley DB repository, then all of your versioned filesystem's structure and data live in a set of database tables within the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository. This subdirectory is a regular Berkeley DB environment directory, and can therefore be used in conjunction with any of the Berkeley database tools, typically provided as part of the Berkeley DB distribution."
msgstr "如果你使用Berkeley DB版本库，那么所有纳入版本控制的文件系统结构和数据都储存在一系列数据库的表中，而这个位于版本库的<filename moreinfo=\"none\">db</filename>子目录下。这个子目录是一个标准的Berkeley DB环境目录，可以应用任何Berkeley数据库工具进行操作（参考SleepyCat网站<ulink url=\"http://www.sleepycat.com/\"/>上关于这些工具的介绍）。"

#: build/en/book.xml:10965(para)
msgid "For day-to-day Subversion use, these tools are unnecessary. Most of the functionality typically needed for Subversion repositories has been duplicated in the <command moreinfo=\"none\">svnadmin</command> tool. For example, <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> and <command moreinfo=\"none\">svnadmin list-dblogs</command> perform a subset of what is provided by the Berkeley <command moreinfo=\"none\">db_archive</command> command, and <command moreinfo=\"none\">svnadmin recover</command> reflects the common use cases of the <command moreinfo=\"none\">db_recover</command> utility."
msgstr "对于Subversion的日常使用来说，这些工具并没有什么用处。大多数Subversion版本库必须的数据库操作都集成到<command moreinfo=\"none\">svnadmin</command>工具中。比如，<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>和<command moreinfo=\"none\">svnadmin list-dblogs</command>实现了Berkeley <command moreinfo=\"none\">db_archive</command>命令功能的一个子集，而<command moreinfo=\"none\">svnadmin recover</command>则起到了 <command moreinfo=\"none\">db_recover</command>工具的作用。"

#: build/en/book.xml:10976(para)
msgid "There are still a few Berkeley DB utilities that you might find useful. The <command moreinfo=\"none\">db_dump</command> and <command moreinfo=\"none\">db_load</command> programs write and read, respectively, a custom file format which describes the keys and values in a Berkeley DB database. Since Berkeley databases are not portable across machine architectures, this format is a useful way to transfer those databases from machine to machine, irrespective of architecture or operating system. Also, the <command moreinfo=\"none\">db_stat</command> utility can provide useful information about the status of your Berkeley DB environment, including detailed statistics about the locking and storage subsystems."
msgstr "当然，还有一些Berkeley DB工具有时是有用的。<command moreinfo=\"none\">db_dump</command>将Berkeley DB数据库中的键值对以特定的格式写入文件中，而<command moreinfo=\"none\">db_load</command>则可以将这些键值对注入到数据库中。Berkeley数据库本身不支持跨平台转移，这两个工具在这样的情况下就可以实现在平台间转移数据库的功能，而无需关心操作系统或机器架构。此外，<command moreinfo=\"none\">db_stat</command>工具能够提供关于Berkeley DB环境的许多有用信息，包括详细的锁定和存储子系统的统计信息。"

#: build/en/book.xml:10989(para)
msgid "For more information on the Berkeley DB tool chain, visit the documentation section of the Berkeley DB section of Oracle's website, located at <ulink url=\"http://www.oracle.com/technology/documentation/berkeley-db/db/\"/>."
msgstr ""

#: build/en/book.xml:10998(title)
#, fuzzy
msgid "Commit Log Message Correction"
msgstr "提交事务。"

#: build/en/book.xml:11000(para)
msgid "Sometimes a user will have an error in her log message (a misspelling or some misinformation, perhaps). If the repository is configured (using the <literal moreinfo=\"none\">pre-revprop-change</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks; see <xref linkend=\"svn.reposadmin.create.hooks\"/>) to accept changes to this log message after the commit is finished, then the user can <quote>fix</quote> her log message remotely using the <command moreinfo=\"none\">svn</command> program's <literal moreinfo=\"none\">propset</literal> command (see <xref linkend=\"svn.ref\"/>). However, because of the potential to lose information forever, Subversion repositories are not, by default, configured to allow changes to unversioned properties—except by an administrator."
msgstr "有时用户输入的日志信息有错误（比如拼写错误或者内容错误）。如果配置版本库时设置了（使用<literal moreinfo=\"none\">pre-revprop-change</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子；参见<xref linkend=\"svn.reposadmin.create.hooks\"/>）允许用户在提交后修改日志信息的选项，那么用户可以使用<command moreinfo=\"none\">svn</command>程序的<literal moreinfo=\"none\">propset</literal>命令（参见<xref linkend=\"svn.ref\"/>）<quote>修正</quote>日志信息中的错误。不过为了避免永远丢失信息，Subversion版本库通常设置为仅能由管理员修改非版本化属性（这也是默认的选项）。"

#: build/en/book.xml:1101(para)
msgid "A program for incrementally mirroring one repository to another over a network."
msgstr ""

#: build/en/book.xml:11013(para)
msgid "If a log message needs to be changed by an administrator, this can be done using <command moreinfo=\"none\">svnadmin setlog</command>. This command changes the log message (the <literal moreinfo=\"none\">svn:log</literal> property) on a given revision of a repository, reading the new value from a provided file."
msgstr "如果管理员想要修改日志信息，那么可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令。这个命令从指定的文件中读取信息，取代版本库中某个修订版本的日志信息（<literal moreinfo=\"none\">svn:log</literal>属性）。"

#: build/en/book.xml:11019(screen)
#, no-wrap
msgid ""
"\n"
"$ echo \"Here is the new, correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"
msgstr ""
"\n"
"$ echo \"Here is the new， correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"

#: build/en/book.xml:11024(para)
msgid "The <command moreinfo=\"none\">svnadmin setlog</command> command alone is still bound by the same protections against modifying unversioned properties as a remote client is—the <literal moreinfo=\"none\">pre-</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks are still triggered, and therefore must be setup to accept changes of this nature. But an administrator can get around these protections by passing the <option>--bypass-hooks</option> option to the <command moreinfo=\"none\">svnadmin setlog</command> command."
msgstr "即使是<command moreinfo=\"none\">svnadmin setlog</command>命令也受到限制。<literal moreinfo=\"none\">pre-</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子同样会被触发，因此必须进行相应的设置才能允许修改非版本化属性。不过管理员可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令的<option>--bypass-hooks</option>选项跳过钩子。"

#: build/en/book.xml:11035(para)
msgid "Remember, though, that by bypassing the hooks, you are likely avoiding such things as email notifications of property changes, backup systems which track unversioned property changes, and so on. In other words, be very careful about what you are changing, and how you change it."
msgstr "不过需要注意的是，一旦跳过钩子也就跳过了钩子所提供的所有功能，比如邮件通知（通知属性有改动）、系统备份（可以用来跟踪非版本化的属性变更）等等。换句话说，要留心你所作出的修改，以及你作出修改的方式。"

#: build/en/book.xml:11048(title)
msgid "Managing Disk Space"
msgstr "管理磁盘空间"

#: build/en/book.xml:11050(para)
#, fuzzy
msgid "While the cost of storage has dropped incredibly in the past few years, disk usage is still a valid concern for administrators seeking to version large amounts of data. Every bit of version history information stored in the live repository is information that needs to be backed up elsewhere, perhaps multiple times as part of rotating backup schedules. It is useful to know what pieces of Subversion's repository data need to remain on the live site, which need to be backed up, and which can be safely removed."
msgstr "虽然存储器的价格在过去的几年里以让人难以致信的速度滑落，但是对于那些需要对大量数据进行版本管理的管理员们来说，磁盘空间的消耗依然是一个重要的因素。版本库每增加一个字节都意味着需要多一个字节的磁盘空间进行备份，对于多重备份来说，就需要消耗更多的磁盘空间。Berkeley DB版本库的主要存储机制是基于一个复杂的数据库系统建立的，因此了解一些数据性质是有意义的，比如哪些数据必须保留。哪些数据需要备份、哪些数据可以安全的删除等等。本节的内容专注于Berkeley DB类型的版本库。FSFS类型的版本库不需要进行数据清理和回收。"

#: build/en/book.xml:11062(title)
msgid "How Subversion saves disk space"
msgstr ""

#: build/en/book.xml:11064(para)
#, fuzzy
msgid "To keep the size of the repository as small as possible, Subversion uses <firstterm>deltification</firstterm> (or, <quote>deltified storage</quote>) within the repository itself. Deltification involves encoding the representation of a chunk of data as a collection of differences against some other chunk of data. If the two pieces of data are very similar, this deltification results in storage savings for the deltified chunk—rather than taking up space equal to the size of the original data, it takes up only enough space to say, <quote>I look just like this other piece of data over here, except for the following couple of changes</quote>. The result is that most of the repository data that tends to be sizable—namely, the contents of versioned files—is stored at a much smaller size than the original <quote>fulltext</quote> representation of that data. And for repositories created with Subversion 1.4 or later, the space saving get even better—now those fulltext representations of file contents are themselves compressed."
msgstr "为了尽可能减小版本库的体积，Subversion在版本库中采用了<firstterm>增量化技术</firstterm>（或称为<quote>增量存储技术</quote>）。增量化技术可以将一组数据表示为相对于另一组数据的不同。如果这两组数据十分相似，增量化技术就可以仅保存其中一组数据以及两组数据的差别，而不需要同时保存两组数据，从而节省了磁盘空间。每次一个文件的新版本提交到版本库，版本库就会将之前的版本（之前的多个版本）相对于新版本做增量化处理。采用了这项技术，版本库的数据量大小基本上是可以估算出来的—主要是版本化的文件的大小—并且远小于<quote>全文</quote>保存所需的数据量。"

#: build/en/book.xml:1108(para)
msgid "Assuming you have Subversion installed correctly, you should be ready to start. The next two chapters will walk you through the use of <command moreinfo=\"none\">svn</command>, Subversion's command-line client program."
msgstr "如果已经正确完成了Subversion的安装，我们就可以开始我们的学习之旅了。在后面的两章中，我们将讲解如何使用Subversion的客户端程序<command moreinfo=\"none\">svn</command>。"

#: build/en/book.xml:11085(para)
#, fuzzy
msgid "Because all of the data that is subject to deltification in a BDB-backed repository is stored in a single Berkeley DB database file, reducing the size of the stored values will not immediately reduce the size of the database file itself. Berkeley DB will, however, keep internal records of unused areas of the database file, and consume those areas first before growing the size of the database file. So while deltification doesn't produce immediate space savings, it can drastically slow future growth of the database."
msgstr "由于Subversion版本库的增量化数据保存在单一Berkeley DB数据库文件中，减少数据的体积并不一定能够减小数据库文件的大小。但是，Berkeley DB会在内部记录未使用的数据库文件区域，并且在增加数据库文件大小之前会首先使用这些未使用的区域。因此，即使增量化技术不能立杆见影的节省磁盘空间，也可以极大的减慢数据库的膨胀速度。"

#: build/en/book.xml:11101(title)
#, fuzzy
msgid "Removing dead transactions"
msgstr "移除中止的事务，"

#: build/en/book.xml:11103(para)
#, fuzzy
msgid "Though they are uncommon, there are circumstances in which a Subversion commit process might fail, leaving behind in the repository the remnants of the revision-to-be that wasn't—an uncommitted transaction and all the file and directory changes associated with it. This could happen for several reasons: perhaps the client operation was inelegantly terminated by the user, or a network failure might have occurred in the middle of an operation, etc. Regardless of the reason, dead transactions can happen. They don't do any real harm, other than consuming disk space. A fastidious administrator may nonetheless wish to remove them."
msgstr "<command moreinfo=\"none\">svnadmin</command>的另一个常见用途是查询异常的—可能是已经死亡的—Subversion事务。通常提交操作失败时，与之相关的事务就会被清除。也就是说，事务本身及所有与该事务相关（且仅与该事务相关）的数据会从版本库中删除。不过偶尔也会出现操作失败而事务没有被清除的情况。出现这种情况可能有以下原因：客户端的用户粗暴的结束了操作，操作过程中出现网络故障，等等。不管是什么原因，死亡的事务总是有可能会出现。这类事务不会产生什么负面影响，仅仅是消耗了一点点磁盘空间。不过，严厉的管理员总是希望能够将它们清除出去。"

#: build/en/book.xml:11116(para)
msgid "You can use <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">lstxns</literal> command to list the names of the currently outstanding transactions."
msgstr "可以使用<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">lstxns</literal> 命令列出当前的异常事务名。"

#: build/en/book.xml:11120(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"

#: build/en/book.xml:11128(para)
#, fuzzy
msgid "Each item in the resultant output can then be used with <command moreinfo=\"none\">svnlook</command> (and its <option>--transaction (-t)</option> option) to determine who created the transaction, when it was created, what types of changes were made in the transaction—information that is helpful in determining whether or not the transaction is a safe candidate for removal! If so, the transaction's name can be passed to <command moreinfo=\"none\">svnadmin rmtxns</command>, which will perform the cleanup of the transaction. In fact, the <literal moreinfo=\"none\">rmtxns</literal> subcommand can take its input directly from the output of <literal moreinfo=\"none\">lstxns</literal>!"
msgstr "将输出的结果条目作为<command moreinfo=\"none\">svnlook</command>（设置<option>--transaction</option>选项）的参数，就可以获得事务的详细信息，如事务的创建者、创建时间，事务已作出的更改类型，由这些信息可以判断出是否可以将这个事务安全的删除。如果可以安全删除，那么只需将事务名作为参数输入到<command moreinfo=\"none\">svnadmin rmtxns</command>，就可以将事务清除掉了。其实<literal moreinfo=\"none\">rmtxns</literal>子命令可以直接以<literal moreinfo=\"none\">lstxns</literal>的输出作为输入进行清理。"

#: build/en/book.xml:11141(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"

#: build/en/book.xml:11146(para)
#, fuzzy
msgid "If you use these two subcommands like this, you should consider making your repository temporarily inaccessible to clients. That way, no one can begin a legitimate transaction before you start your cleanup. <xref linkend=\"svn.reposadmin.maint.diskspace.deadtxns.ex-1\"/> contains a bit of shell-scripting that can quickly generate information about each outstanding transaction in your repository."
msgstr "在按照上面例子中的方法清理版本库之前，你或许应该暂时关闭版本库和客户端的连接。这样在你开始清理之前，不会有正常的事务进入版本库。下面例子中的shell脚本可以用来迅速获得版本库中异常事务的信息："

#: build/en/book.xml:11155(title)
msgid "txn-info.sh (Reporting Outstanding Transactions)"
msgstr "txn-info.sh（异常事务报告）"

#: build/en/book.xml:11157(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"

#: build/en/book.xml:11176(para)
#, fuzzy
msgid "The output of the script is basically a concatenation of several chunks of <command moreinfo=\"none\">svnlook info</command> output (see <xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>), and will look something like:"
msgstr "可以用下面的命令使用上例中脚本： <command moreinfo=\"none\">/path/to/txn-info.sh /path/to/repos</command>。该命令的输出主要由多个<command moreinfo=\"none\">svnlook info</command>参见<xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>）的输出组成，类似于下面的例子："

#: build/en/book.xml:11181(screen)
#, no-wrap
msgid ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)\n"
"0\n"
"$\n"
msgstr ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue， 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon， 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed， 12 Sep 2001)\n"
"0\n"
"$\n"

#: build/en/book.xml:11199(para)
msgid "A long-abandoned transaction usually represents some sort of failed or interrupted commit. A transaction's datestamp can provide interesting information—for example, how likely is it that an operation begun nine months ago is still active?"
msgstr "一个废弃了很长时间的事务通常是提交错误或异常中断的结果。事务的时间戳可以提供给我们一些有趣的信息，比如一个进行了9个月的操作居然还是活动的等等。"

#: build/en/book.xml:11205(para)
#, fuzzy
msgid "In short, transaction cleanup decisions need not be made unwisely. Various sources of information—including Apache's error and access logs, Subversion's operational logs, Subversion revision history, and so on—can be employed in the decision-making process. And of course, an administrator can often simply communicate with a seemingly dead transaction's owner (via email, for example) to verify that the transaction is, in fact, in a zombie state."
msgstr "简言之，作出事务清理的决定前应该仔细考虑一下。许多信息源—比如Apache的错误和访问日志，已成功完成的Subversion提交日志等等—都可以作为决策的参考。管理员还可以直接和那些似乎已经死亡事务的提交者直接交流（比如通过邮件），来确认该事务确实已经死亡了。"

#: build/en/book.xml:11218(title)
#, fuzzy
msgid "Purging unused Berkeley DB logfiles"
msgstr "删除不使用的Berkeley DB日志。"

#: build/en/book.xml:11220(para)
#, fuzzy
msgid "Until recently, the largest offender of disk space usage with respect to BDB-backed Subversion repositories was the log files in which Berkeley DB performs its pre-writes before modifying the actual database files. These files capture all the actions taken along the route of changing the database from one state to another—while the database files reflect at any given time some state, the log files contain all the many changes along the way between states. As such, they can grow and accumulate quite rapidly."
msgstr "目前为止，Subversion版本库中耗费磁盘空间的最大凶手是日志文件，每次Berkeley DB在修改真正的数据文件之前都会进行预写入（pre-writes）操作。这些文件记录了数据库从一个状态变化到另一个状态的所有动作——数据库文件反应了特定时刻数据库的状态，而日志文件则记录了所有状态变化的信息。因此，日志文件会以很快的速度膨胀起来。"

#: build/en/book.xml:11231(para)
msgid "Fortunately, beginning with the 4.2 release of Berkeley DB, the database environment has the ability to remove its own unused log files without any external procedures. Any repositories created using an <command moreinfo=\"none\">svnadmin</command> which is compiled against Berkeley DB version 4.2 or greater will be configured for this automatic log file removal. If you don't want this feature enabled, simply pass the <option>--bdb-log-keep</option> option to the <command moreinfo=\"none\">svnadmin create</command> command. If you forget to do this, or change your mind at a later time, simple edit the <filename moreinfo=\"none\">DB_CONFIG</filename> file found in your repository's <filename moreinfo=\"none\">db</filename> directory, comment out the line which contains the <literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal> directive, and then run <command moreinfo=\"none\">svnadmin recover</command> on your repository to force the configuration changes to take effect. See <xref linkend=\"svn.reposadmin.create.bdb\"/> for more information about database configuration."
msgstr "幸运的是，从版本4.2开始，Berkeley DB的数据库环境无需额外的操作即可删除无用的日志文件。如果编译<command moreinfo=\"none\">svnadmin</command>时使用了高于4.2版本的Berkeley DB，那么由此<command moreinfo=\"none\">svnadmin</command>程序创建的版本库就具备了自动清除日志文件的功能。如果想屏蔽这个功能，只需设置<command moreinfo=\"none\">svnadmin create</command>命令的<option>--bdb-log-keep</option>选项即可。如果创建版本库以后想要修改关于此功能的设置，只需编辑版本库中<filename moreinfo=\"none\">db</filename>目录下的<filename moreinfo=\"none\">DB_CONFIG</filename>文件，注释掉包含<literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal>内容的这一行，然后运行<command moreinfo=\"none\">svnadmin recover</command>强制设置生效就行了。查阅<xref linkend=\"svn.reposadmin.create.bdb\"/>获得更多关于数据库配置的帮助信息。"

#: build/en/book.xml:11249(para)
msgid "Without some sort of automatic log file removal in place, log files will accumulate as you use your repository. This is actually somewhat of a feature of the database system—you should be able to recreate your entire database using nothing but the log files, so these files can be useful for catastrophic database recovery. But typically, you'll want to archive the log files that are no longer in use by Berkeley DB, and then remove them from disk to conserve space. Use the <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> command to list the unused log files:"
msgstr "如果不自动删除日志文件，那么日志文件会随着版本库的使用逐渐增加。这多少应该算是数据库系统的特性，通过这些日志文件可以在数据库严重损坏时恢复整个数据库的内容。但是一般情况下，最好是能够将无用的日志文件收集起来并删除，这样就可以节省磁盘空间。使用<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>命令可以列出无用的日志文件："

#: build/en/book.xml:1126(title)
msgid "Fundamental Concepts"
msgstr "基本概念"

#: build/en/book.xml:11261(screen) build/en/book.xml:22453(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"
msgstr ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"

#: build/en/book.xml:11272(para)
msgid "BDB-backed repositories whose log files are used as part of a backup or disaster recovery plan should <emphasis>not</emphasis> make use of the log file autoremoval feature. Reconstruction of a repository's data from log files can only be accomplished when the log files are all available. If some of the log files are removed from disk before the backup system has a chance to copy them elsewhere, the incomplete set of backed-up log files is essentially useless."
msgstr ""

#: build/en/book.xml:1128(para)
msgid "This chapter is a short, casual introduction to Subversion. If you're new to version control, this chapter is definitely for you. We begin with a discussion of general version control concepts, work our way into the specific ideas behind Subversion, and show some simple examples of Subversion in use."
msgstr "本章主要为那些不熟悉版本控制技术的入门者提供一个简单扼要的、非系统的介绍。我们将从版本控制的基本概念开始，随后阐述Subversion的独特理念，并演示一些使用Subversion的例子。"

#: build/en/book.xml:11289(title)
#, fuzzy
msgid "Berkeley DB Recovery"
msgstr "Berkeley DB"

#: build/en/book.xml:11291(para)
msgid "As mentioned in <xref linkend=\"svn.reposadmin.basics.backends.bdb\"/>, a Berkeley DB repository can sometimes be left in frozen state if not closed properly. When this happens, an administrator needs to rewind the database back into a consistent state. This is unique to BDB-backed repositories, though—if you are using FSFS-backed ones instead, this won't apply to you. And for those of you using Subversion 1.4 with Berkeley DB 4.4 or better, you should find that Subversion has become much more resilient in these types of situations. Still, wedged Berkeley DB repositories do occur, and an administrator needs to know how to safely deal with this circumstance."
msgstr ""

#: build/en/book.xml:11303(para)
#, fuzzy
msgid "In order to protect the data in your repository, Berkeley DB uses a locking mechanism. This mechanism ensures that portions of the database are not simultaneously modified by multiple database accessors, and that each process sees the data in the correct state when that data is being read from the database. When a process needs to change something in the database, it first checks for the existence of a lock on the target data. If the data is not locked, the process locks the data, makes the change it wants to make, and then unlocks the data. Other processes are forced to wait until that lock is removed before they are permitted to continue accessing that section of the database. (This has nothing to do with the locks that you, as a user, can apply to versioned files within the repository; we try to clear up the confusion caused by this terminology collision in <xref linkend=\"svn.advanced.locking.meanings\"/>.)"
msgstr "Berkeley DB使用一种锁机制保护版本库中的数据。锁机制确保数据库不会同时被多个访问进程修改，也就保证了从数据库中读取到的数据始终是稳定而且正确的。当一个进程需要修改数据库中的数据时，首先必须检查目标数据是否已经上锁。如果目标数据没有上锁，进程就将它锁上，然后作出修改，最后再将锁解除。而其它进程则必须等待锁解除后才能继续访问数据库中的相关内容。"

#: build/en/book.xml:11319(para)
#, fuzzy
msgid "In the course of using your Subversion repository, fatal errors or interruptions can prevent a process from having the chance to remove the locks it has placed in the database. The result is that the back-end database system gets <quote>wedged</quote>. When this happens, any attempts to access the repository hang indefinitely (since each new accessor is waiting for a lock to go away—which isn't going to happen)."
msgstr "在操作Subversion版本库的过程中，致命错误（如内存或硬盘空间不足）或异常中断可能会导致某个进程没能及时将锁解除。结果就是后端的数据库系统被<quote>塞住</quote>了。一旦发生这种情况，任何访问版本库的进程都会挂起（每个访问进程都在等待锁被解除，但是锁已经无法解除了）。"

#: build/en/book.xml:11328(para)
#, fuzzy
msgid "If this happens to your repository, don't panic. The Berkeley DB filesystem takes advantage of database transactions and checkpoints and pre-write journaling to ensure that only the most catastrophic of events <placeholder-1/> can permanently destroy a database environment. A sufficiently paranoid repository administrator will have made off-site backups of the repository data in some fashion, but head off to the tape backup storage closet just yet."
msgstr "首先，如果你的版本库出现这种情况，没什么好惊慌的。Berkeley DB的文件系统采用了数据库事务、检查点以及预写入日志等技术来取保只有灾难性的事件<footnote><placeholder-1/></footnote>才能永久性的破坏数据库环境。所以虽然一个过于稳重的版本库管理员通常都会按照某种方案进行大量的版本库离线备份，不过不要急着通知你的管理员进行恢复。"

#: build/en/book.xml:11333(para)
msgid "E.g.: hard drive + huge electromagnet = disaster."
msgstr "比如：硬盘 + 大号电磁铁 = 毁灭。"

#: build/en/book.xml:11340(para)
#, fuzzy
msgid "Instead, use the following recipe to attempt to <quote>unwedge</quote> your repository:"
msgstr "然后，使用下面的方法试着<quote>恢复</quote>你的版本库："

#: build/en/book.xml:11345(para)
#, fuzzy
msgid "Make sure that there are no processes accessing (or attempting to access) the repository. For networked repositories, this means shutting down the Apache HTTP Server or svnserve daemon, too."
msgstr "确保没有其它进程访问（或者试图访问）版本库。对于网络版本库，关闭Apache HTTP服务器是个好办法。"

#: build/en/book.xml:1135(para)
msgid "Even though the examples in this chapter show people sharing collections of program source code, keep in mind that Subversion can manage any sort of file collection—it's not limited to helping computer programmers."
msgstr "虽然我们在本章中以分享程序源代码作为例子，但是记住Subversion可以管理任何类型的文件集—它并非是程序员专用的。"

#: build/en/book.xml:11351(para)
msgid "Become the user who owns and manages the repository. This is important, as recovering a repository while running as the wrong user can tweak the permissions of the repository's files in such a way that your repository will still be inaccessible even after it is <quote>unwedged</quote>."
msgstr "成为版本库的拥有者和管理员。这一点很重要，如果以其它用户的身份恢复版本库，可能会改变版本库文件的访问权限，导致在版本库<quote>恢复</quote>后依旧无法访问。"

#: build/en/book.xml:11359(para)
msgid "Run the command <command moreinfo=\"none\">svnadmin recover /path/to/repos</command>. You should see output like this:"
msgstr "运行命令<command moreinfo=\"none\">svnadmin recover /path/to/repos</command>。 输出如下："

#: build/en/book.xml:11363(screen)
#, no-wrap
msgid ""
"\n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"
msgstr ""
"\n"
"Repository lock acquired。\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"

#: build/en/book.xml:11370(para)
msgid "This command may take many minutes to complete."
msgstr "此命令可能需要数分钟才能完成。"

#: build/en/book.xml:11373(para)
#, fuzzy
msgid "Restart the server process."
msgstr "重新启动Subversion服务器。"

#: build/en/book.xml:11377(para)
msgid "This procedure fixes almost every case of repository lock-up. Make sure that you run this command as the user that owns and manages the database, not just as <literal moreinfo=\"none\">root</literal>. Part of the recovery process might involve recreating from scratch various database files (shared memory regions, for example). Recovering as <literal moreinfo=\"none\">root</literal> will create those files such that they are owned by <literal moreinfo=\"none\">root</literal>, which means that even after you restore connectivity to your repository, regular users will be unable to access it."
msgstr "这个方法能修复几乎所有版本库锁住的问题。记住，要以数据库的拥有者和管理员的身份运行这个命令，而不一定是<literal moreinfo=\"none\">root</literal>用户。恢复过程中可能会使用其它数据存储区（例如共享内存区）重建一些数据库文件。如果以<literal moreinfo=\"none\">root</literal>用户身份恢复版本库，这些重建的文件拥有者将变成<literal moreinfo=\"none\">root</literal>用户，也就是说，即使恢复了到版本库的连接，一般的用户也无权访问这些文件。"

#: build/en/book.xml:11388(para)
msgid "If the previous procedure, for some reason, does not successfully unwedge your repository, you should do two things. First, move your broken repository out of the way and restore your latest backup of it. Then, send an email to the Subversion user list (at <email>users@subversion.tigris.org</email>) describing your problem in detail. Data integrity is an extremely high priority to the Subversion developers."
msgstr "如果因为某些原因，上面的方法没能成功的恢复版本库，那么你可以做两件事。首先，将破损的版本库保存到其它地方，然后从最新的备份中恢复版本库。然后，发送一封邮件到Subversion用户列表（地址是：<email>users@subversion.tigris.org</email>），写清你所遇到的问题。对于Subversion的开发者来说，数据安全是最重要的问题。"

#: build/en/book.xml:11401(title)
#, fuzzy
msgid "Migrating Repository Data Elsewhere"
msgstr "版本库的移植"

#: build/en/book.xml:11403(para)
#, fuzzy
msgid "A Subversion filesystem has its data spread throughout various back-end data store files in a fashion generally understood by (and of interest to) only the Subversion developers themselves. However, circumstances may arise that call for all, or some subset, of that data to be copied or moved into another repository."
msgstr "Subversion文件系统将数据保存在许多数据库表中，而这些表的结构只有Subversion开发者们才了解（也只有他们才感兴趣）不过，有些时候我们会想到把所有的数据（或者一部分数据）保存在一个独立的、可移植的、普通格式的文件中。Subversion通过<command moreinfo=\"none\">svnadmin</command>的两个子命令<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>提供了类似的功能。"

#: build/en/book.xml:11410(para)
msgid "Subversion provides such functionality by way of repository dump streams. A repository dump stream (often referred to as a <quote>dumpfile</quote> when stored as a file on disk) is a portable, flat file format that describes the various revisions in your repository—what was changed, by whom, when, and so on. This dump stream is the primary mechanism used to marshal versioned history—in whole or in part, with or without modification—between repositories. And Subversion provides the tools necessary for creating and loading these dump streams—the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands, respectively."
msgstr ""

#: build/en/book.xml:11424(para)
msgid "While the Subversion repository dump format contains human-readable portions and a familiar structure (it resembles an RFC-822 format, the same type of format used for most email), it is <emphasis>not</emphasis> a plaintext file format. The format should be treated as a binary file format, highly sensitive to meddling. Many text editor tools will corrupt the file's contents, often due to automatic line ending character conversion."
msgstr ""

#: build/en/book.xml:11434(para)
msgid "There are many reasons for dumping and loading Subversion repository data. Early in Subversion's life, the most common reason was due to the evolution of Subversion itself. As Subversion matured, there were times when changes made to the back-end database schema caused compatibility issues with previous versions of the repository, so users had to dump their repository data using the previous version of Subversion, and load it into a freshly created repository with the new version of Subversion. Now, these types of schema changes haven't occured since Subversion's 1.0 release, and the Subversion developers promise not to force users to dump and load their repositories when upgrading between minor versions (such as from 1.3 to 1.4) of Subversion. But there are still other reasons for dumping and loading, including re-deploying a Berkeley DB repository on a new OS or CPU architecture, switching between the Berkeley DB and FSFS back-ends, or (as we'll cover in <xref linkend=\"svn.reposadmin.maint.filtering\"/> purging versioned data from repository history."
msgstr ""

#: build/en/book.xml:1145(title)
msgid "The Repository"
msgstr "版本库"

#: build/en/book.xml:11453(para)
#, fuzzy
msgid "Whatever your reason for migration repository history, using the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands is straightforward. <command moreinfo=\"none\">svnadmin dump</command> will output a range of repository revisions that are formatted using Subversion's custom filesystem dump format. The dump format is printed to the standard output stream, while informative messages are printed to the standard error stream. This allows you to redirect the output stream to a file while watching the status output in your terminal window. For example:"
msgstr "<command moreinfo=\"none\">svnadmin dump</command>命令会将版本库中的修订版本数据按照特定的格式输出到转储流中。转储数据会输出到标准输出流，而提示信息会输出到标准错误流。这就是说，可以将转储数据存储到文件中，而同时在终端窗口中监视运行状态。例如："

#: build/en/book.xml:11465(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"
msgstr ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"

#: build/en/book.xml:1147(para)
msgid "Subversion is a centralized system for sharing information. At its core is a repository, which is a central store of data. The repository stores information in the form of a <firstterm>filesystem tree</firstterm>—a typical hierarchy of files and directories. Any number of <firstterm>clients</firstterm> connect to the repository, and then read or write to these files. By writing data, a client makes the information available to others; by reading data, the client receives information from others. <xref linkend=\"svn.basic.repository.dia-1\"/> illustrates this."
msgstr "Subversion是一个“中央集权式”的信息共享系统。版本库是Subversion的核心部分，是数据的中央仓库。版本库以文件和目录的典型结构形式—<firstterm>文件系统树</firstterm>来保存信息。此外，数个<firstterm>客户端</firstterm>（数量不限）连接到Subversion版本库，读取、修改这些文件。客户端之间通过修改数据实现与别人共享信息，通过读取数据实现获取别人共享的信息。<xref linkend=\"svn.basic.repository.dia-1\"/>展示了这种系统的概貌："

#: build/en/book.xml:11477(para)
msgid "At the end of the process, you will have a single file (<filename moreinfo=\"none\">dumpfile</filename> in the previous example) that contains all the data stored in your repository in the requested range of revisions. Note that <command moreinfo=\"none\">svnadmin dump</command> is reading revision trees from the repository just like any other <quote>reader</quote> process would (<command moreinfo=\"none\">svn checkout</command>, for example). So it's safe to run this command at any time."
msgstr "最后，版本库中的指定的修订版本数据被转储到一个独立的文件中（在上面的例子中是<filename moreinfo=\"none\">dumpfile</filename>）。注意，<command moreinfo=\"none\">svnadmin dump</command>从版本库中读取修订版本树与其它<quote>读者</quote>（比如<command moreinfo=\"none\">svn checkout</command>）的过程相同，所以可以在任何时候安全的运行这个命令。"

#: build/en/book.xml:11486(para)
msgid "The other subcommand in the pair, <command moreinfo=\"none\">svnadmin load</command>, parses the standard input stream as a Subversion repository dump file, and effectively replays those dumped revisions into the target repository for that operation. It also gives informative feedback, this time using the standard output stream:"
msgstr "另一个命令，<command moreinfo=\"none\">svnadmin load</command>，从标准输入流中读取Subversion转储数据，并且高效的将数据转载到目标版本库中。这个命令的提示信息输出到标准输出流中："

#: build/en/book.xml:11493(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"

#: build/en/book.xml:11522(para)
#, fuzzy
msgid "The result of a load is new revisions added to a repository—the same thing you get by making commits against that repository from a regular Subversion client. And just as in a commit, you can use hook programs to perform actions before and after each of the commits made during a load process. By passing the <option>--use-pre-commit-hook</option> and <option>--use-post-commit-hook</option> options to <command moreinfo=\"none\">svnadmin load</command>, you can instruct Subversion to execute the pre-commit and post-commit hook programs, respectively, for each loaded revision. You might use these, for example, to ensure that loaded revisions pass through the same validation steps that regular commits pass through. Of course, you should use these options with care—if your post-commit hook sends emails to a mailing list for each new commit, you might not want to spew hundreds or thousands of commit emails in rapid succession at that list for each of the loaded revisions! You can read more about the use of hook scripts in <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr "load命令的结果就是添加一些新的修订版本—与使用普通Subversion客户端直接提交到版本库相同。正像一次简单的提交，你也可以使用钩子脚本在每次load的开始和结束执行一些操作。通过传递<option>--use-pre-commit-hook</option>和<option>--use-post-commit-hook</option>选项给<command moreinfo=\"none\">svnadmin load</command>，你可以告诉Subversion的对每一个加载修订版本执行pre-commit和post-commit钩子脚本，可以利用这个选项确保这种提交也能通过一般提交的检验。当然，你要小心使用这个选项，你一定不像接受一大堆提交邮件。你可以查看<xref linkend=\"svn.reposadmin.create.hooks\"/>来得到更多相关信息。"

#: build/en/book.xml:11542(para)
msgid "Note that because <command moreinfo=\"none\">svnadmin</command> uses standard input and output streams for the repository dump and load process, people who are feeling especially saucy can try things like this (perhaps even using different versions of <command moreinfo=\"none\">svnadmin</command> on each side of the pipe):"
msgstr "既然<command moreinfo=\"none\">svnadmin</command>使用标准输入流和标准输出流作为转储和装载的输入和输出，那么更漂亮的用法是（管道两端可以是不同版本的<command moreinfo=\"none\">svnadmin</command>："

#: build/en/book.xml:11548(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"
msgstr ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"

#: build/en/book.xml:11553(para)
#, fuzzy
msgid "By default, the dump file will be quite large—much larger than the repository itself. That's because by default every version of every file is expressed as a full text in the dump file. This is the fastest and simplest behavior, and nice if you're piping the dump data directly into some other process (such as a compression program, filtering program, or into a loading process). But if you're creating a dump file for longer-term storage, you'll likely want to save disk space by using the <option>--deltas</option> switch. With this option, successive revisions of files will be output as compressed, binary differences—just as file revisions are stored in a repository. This option is slower, but results in a dump file much closer in size to the original repository."
msgstr "默认情况下，转储文件的体积可能会相当庞大——比版本库自身大很多。这是因为在转储文件中，每个文件的每个版本都以完整的文本形式保存下来。这种方法速度很快，而且很简单，尤其是直接将转储数据通过管道输入到其它进程中时（比如一个压缩程序，过滤程序，或者一个装载进程）。不过如果要长期保存转储文件，那么可以使用<option>--deltas</option>选项来节省磁盘空间。设置这个选项，同一个文件的数个连续修订版本会以增量式的方式保存—就像储存在版本库中一样。这个方法较慢，但是转储文件的体积则基本上与版本库的体积相当。"

#: build/en/book.xml:11568(para)
#, fuzzy
msgid "We mentioned previously that <command moreinfo=\"none\">svnadmin dump</command> outputs a range of revisions. Use the <option>--revision (-r)</option> option to specify a single revision to dump, or a range of revisions. If you omit this option, all the existing repository revisions will be dumped."
msgstr "之前我们提到<command moreinfo=\"none\">svnadmin dump</command>输出指定的修订版本。使用<option>--revision</option>选项可以指定一个单独的修订版本，或者一个修订版本的范围。如果忽略这个选项，所有版本库中的修订版本都会被转储。"

#: build/en/book.xml:11575(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"

#: build/en/book.xml:1158(title)
msgid "A typical client/server system"
msgstr "一个典型的客户/服务器系统"

#: build/en/book.xml:11580(para)
msgid "As Subversion dumps each new revision, it outputs only enough information to allow a future loader to re-create that revision based on the previous one. In other words, for any given revision in the dump file, only the items that were changed in that revision will appear in the dump. The only exception to this rule is the first revision that is dumped with the current <command moreinfo=\"none\">svnadmin dump</command> command."
msgstr "Subversion在转储修订版本时，仅会输出与前一个修订版本之间的差异，通过这些差异足以从前一个修订版本中重建当前的修订版本。换句话说，在转储文件中的每一个修订版本仅包含这个修订版本作出的修改。这个规则的唯一一个例外是当前<command moreinfo=\"none\">svnadmin dump</command>转储的第一个修订版本。"

#: build/en/book.xml:11589(para)
msgid "By default, Subversion will not express the first dumped revision as merely differences to be applied to the previous revision. For one thing, there is no previous revision in the dump file! And secondly, Subversion cannot know the state of the repository into which the dump data will be loaded (if it ever, in fact, occurs). To ensure that the output of each execution of <command moreinfo=\"none\">svnadmin dump</command> is self-sufficient, the first dumped revision is by default a full representation of every directory, file, and property in that revision of the repository."
msgstr "默认情况下，Subversion不会把转储的第一个修订版本看作对前一个修订版本的更改。 首先，转储文件中没有比第一个修订版本更靠前的修订版本了！其次，Subversion不知道装载转储数据时（如果真的需要装载的话）的版本库是什么样的情况。为了保证每次运行<command moreinfo=\"none\">svnadmin dump</command>都能得到一个独立的结果，第一个转储的修订版本默认情况下会完整的保存目录、文件以及属性等数据。"

#: build/en/book.xml:11600(para)
msgid "However, you can change this default behavior. If you add the <option>--incremental</option> option when you dump your repository, <command moreinfo=\"none\">svnadmin</command> will compare the first dumped revision against the previous revision in the repository, the same way it treats every other revision that gets dumped. It will then output the first revision exactly as it does the rest of the revisions in the dump range—mentioning only the changes that occurred in that revision. The benefit of this is that you can create several small dump files that can be loaded in succession, instead of one large one, like so:"
msgstr "不过，这些都是可以改变的。如果转储时设置了<option>--incremental</option>选项，<command moreinfo=\"none\">svnadmin</command>会比较第一个转储的修订版本和版本库中前一个修订版本，就像对待其它转储的修订版本一样。转储时也是一样，转储文件中将仅包含第一个转储的修订版本的增量信息。这样的好处是，可以创建几个连续的小体积的转储文件代替一个大文件，比如："

#: build/en/book.xml:11612(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3\n"

#: build/en/book.xml:11618(para)
msgid "These dump files could be loaded into a new repository with the following command sequence:"
msgstr "这些转储文件可以使用下列命令装载到一个新的版本库中："

#: build/en/book.xml:1162(para)
msgid "So why is this interesting? So far, this sounds like the definition of a typical file server. And indeed, the repository <emphasis>is</emphasis> a kind of file server, but it's not your usual breed. What makes the Subversion repository special is that <emphasis>it remembers every change</emphasis> ever written to it: every change to every file, and even changes to the directory tree itself, such as the addition, deletion, and rearrangement of files and directories."
msgstr "这有什么意义吗？说了这么多，Subversion听起来和一般的文件服务器没什么不同。事实上，Subversion的版本库的确<emphasis>是</emphasis>一种文件服务器，但不是“一般”的文件服务器。Subversion版本库的特别之处在于，<emphasis>它会记录每一次改变</emphasis>，每一次文件和目录结构的改变，（比如增加、删除和重新布置文件和目录）它都不会放过。"

#: build/en/book.xml:11621(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"

#: build/en/book.xml:11627(para)
#, fuzzy
msgid "Another neat trick you can perform with this <option>--incremental</option> option involves appending to an existing dump file a new range of dumped revisions. For example, you might have a <literal moreinfo=\"none\">post-commit</literal> hook that simply appends the repository dump of the single revision that triggered the hook. Or you might have a script that runs nightly to append dump file data for all the revisions that were added to the repository since the last time the script ran. Used like this, <command moreinfo=\"none\">svnadmin dump</command> can be one way to backup changes to your repository over time in case of a system crash or some other catastrophic event."
msgstr "另一个有关的技巧是，可以使用<option>--incremental</option>选项在一个转储文件中增加新的转储修订版本。举个例子，可以使用<literal moreinfo=\"none\">post-commit</literal>钩子在每次新的修订版本提交后将其转储到文件中。或者，可以编写一个脚本，在每天夜里将所有新增的修订版本转储到文件中。这样，<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>命令就变成了很好的版本库备份工具，万一出现系统崩溃或其它灾难性事件，它的价值就体现出来了。"

#: build/en/book.xml:11639(para)
msgid "The dump format can also be used to merge the contents of several different repositories into a single repository. By using the <option>--parent-dir</option> option of <command moreinfo=\"none\">svnadmin load</command>, you can specify a new virtual root directory for the load process. That means if you have dump files for three repositories, say <filename moreinfo=\"none\">calc-dumpfile</filename>, <filename moreinfo=\"none\">cal-dumpfile</filename>, and <filename moreinfo=\"none\">ss-dumpfile</filename>, you can first create a new repository to hold them all:"
msgstr "转储还可以用来将几个独立的版本库合并为一个版本库。使用<command moreinfo=\"none\">svnadmin load</command>的<option>--parent-dir</option>选项，可以在装载的时候指定根目录。也就是说，如果有三个不同版本库的转储文件，比如<filename moreinfo=\"none\">calc-dumpfile</filename>，<filename moreinfo=\"none\">cal-dumpfile</filename>，和<filename moreinfo=\"none\">ss-dumpfile</filename>，可以在一个新的版本库中保存所有三个转储文件中的数据："

#: build/en/book.xml:11650(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"

#: build/en/book.xml:11655(para)
msgid "Then, make new directories in the repository which will encapsulate the contents of each of the three previous repositories:"
msgstr "然后在版本库中创建三个目录分别保存来自三个不同版本库的数据："

#: build/en/book.xml:11659(screen)
#, no-wrap
msgid ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"
msgstr ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"

#: build/en/book.xml:11668(para)
msgid "Lastly, load the individual dump files into their respective locations in the new repository:"
msgstr "最后，将转储文件分别装载到各自的目录中："

#: build/en/book.xml:11671(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11681(para)
#, fuzzy
msgid "We'll mention one final way to use the Subversion repository dump format—conversion from a different storage mechanism or version control system altogether. Because the dump file format is, for the most part, human-readable, it should be relatively easy to describe generic sets of changes—each of which should be treated as a new revision—using this file format. In fact, the <command moreinfo=\"none\">cvs2svn</command> utility (see <xref linkend=\"svn.forcvs.convert\"/>) uses the dump format to represent the contents of a CVS repository so that those contents can be copied into a Subversion repository."
msgstr "我们再介绍一下Subversion版本库转储数据的最后一种用途——在不同的存储机制或版本控制系统之间转换。因为转储数据的格式的大部分是可以阅读的，<footnote><placeholder-1/></footnote>所以使用这种格式描述变更集（每个变更集对应一个新的修订版本）会相对容易一些。事实上，<command moreinfo=\"none\">cvs2svn</command>工具（参见 <xref linkend=\"svn.forcvs.convert\"/>）正是将CVS版本库的内容转换为转储数据格式，如此才能将CVS版本库的数据导入Subversion版本库之中。"

#: build/en/book.xml:11696(title)
#, fuzzy
msgid "Filtering Repository History"
msgstr "比较版本库与版本库"

#: build/en/book.xml:11698(para)
#, fuzzy
msgid "Since Subversion stores your versioned history using, at the very least, binary differencing algorithms and data compression (optionally in a completely opaque database system), attempting manual tweaks is unwise, if not quite difficult, and at any rate strongly discouraged. And once data has been stored in your repository, Subversion generally doesn't provide an easy way to remove that data. <placeholder-1/> But inevitably, there will be times when you would like to manipulate the history of your repository. You might need to strip out all instances of a file that was accidentally added to the repository (and shouldn't be there for whatever reason). <placeholder-2/> Or, perhaps you have multiple projects sharing a single repository, and you decide to split them up into their own repositories. To accomplish tasks like this, administrators need a more manageable and malleable representation of the data in their repositories—the Subversion repository dump format."
msgstr "因为Subversion使用底层的数据库储存各类数据，手工调整是不明智的，即使这样做并不困难。何况，一旦你的数据存进了版本库，通常很难再将它们从版本库中删除。<footnote><placeholder-1/></footnote>但是不可避免的，总会有些时候你需要处理版本库的历史数据。你也许想把一个不应该出现的文件从版本库中彻底清除。或者，你曾经用一个版本库管理多个工程，现在又想把它们分开。要完成这样的工作，管理员们需要更易于管理和扩展的方法表示版本库中的数据，Subversion版本库转储文件格式就是一个很好的选择。"

#: build/en/book.xml:11706(para)
msgid "That's rather the reason you use version control at all, right?"
msgstr ""

#: build/en/book.xml:1171(para)
msgid "When a client reads data from the repository, it normally sees only the latest version of the filesystem tree. But the client also has the ability to view <emphasis>previous</emphasis> states of the filesystem. For example, a client can ask historical questions like, <quote>What did this directory contain last Wednesday?</quote> or <quote>Who was the last person to change this file, and what changes did he make?</quote> These are the sorts of questions that are at the heart of any <firstterm>version control system</firstterm>: systems that are designed to record and track changes to data over time."
msgstr "一般情况下，客户端从版本库中获取的数据是文件系统树中的最新数据。但是客户端也具备查看文件系统树<emphasis>以前</emphasis>任何一个状态的能力。举个例子，客户端有时会对一些历史性问题感兴趣，比如<quote>上星期三时的目录结构是什么样的？</quote>或者<quote>谁最后一个修改了这个文件，都修改了什么？</quote>为了回答类似的问题，<firstterm>版本控制系统</firstterm>产生了。它的主要设计目的即是记录和跟踪数据的变化。"

#: build/en/book.xml:11715(para)
msgid "Conscious, cautious removal of certain bits of versioned data is actually supported by real use-cases. That's why an <quote>obliterate</quote> feature has been one of the most highly requested Subversion features, and one which the Subversion developers hope to soon provide."
msgstr ""

#: build/en/book.xml:11729(para)
#, fuzzy
msgid "As we described in <xref linkend=\"svn.reposadmin.maint.migrate\"/>, the Subversion repository dump format is a human-readable representation of the changes that you've made to your versioned data over time. You use the <command moreinfo=\"none\">svnadmin dump</command> command to generate the dump data, and <command moreinfo=\"none\">svnadmin load</command> to populate a new repository with it (see <xref linkend=\"svn.reposadmin.maint.migrate\"/>). The great thing about the human-readability aspect of the dump format is that, if you aren't careless about it, you can manually inspect and modify it. Of course, the downside is that if you have three years' worth of repository activity encapsulated in what is likely to be a very large dump file, it could take you a long, long time to manually inspect and modify it."
msgstr "Subversion版本库转储文件记录了所有版本数据的变更信息，而且以易于阅读的格式保存。可以使用<command moreinfo=\"none\">svnadmin dump</command>命令生成转储文件，然后用<command moreinfo=\"none\">svnadmin load</command>命令生成一个新的版本库。（参见 <xref linkend=\"svn.reposadmin.maint.migrate\"/>）。转储文件易于阅读意味着你可以小心翼翼的查看和修改它。当然，问题是如果你有一个运行了两年的版本库，那么生成的转储文件会很庞大，阅读和手工修改起来都会花费很多时间。"

#: build/en/book.xml:11744(para)
#, fuzzy
msgid "That's where <command moreinfo=\"none\">svndumpfilter</command> becomes useful. This program acts as path-based filter for repository dump streams. Simply give it either a list of paths you wish to keep, or a list of paths you wish to not keep, then pipe your repository dump data through this filter. The result will be a modified stream of dump data that contains only the versioned paths you (explicitly or implicitly) requested."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:11753(para)
msgid "Let's look a realistic example of how you might use this program. We discuss elsewhere (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>) the process of deciding how to choose a layout for the data in your repositories—using one repository per project or combining them, arranging stuff within your repository, and so on. But sometimes after new revisions start flying in, you rethink your layout and would like to make some changes. A common change is the decision to move multiple projects which are sharing a single repository into separate repositories for each project."
msgstr "现在我来演示如何使用这个命令。我们会在其它章节（参见 <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>）讨论关于如何选择设定版本库布局的问题，比如应该使用一个版本库管理多个项目还是使用一个版本库管理一个项目，或者如何在版本库中安排数据等等。不过，有些时候，即使在项目已经展开以后，你还是希望对版本库的布局做一些调整。最常见的情况是，把原来存放在同一个版本库中的几个项目分开，各自成家。"

#: build/en/book.xml:11764(para)
msgid "Our imaginary repository contains three projects: <literal moreinfo=\"none\">calc</literal>, <literal moreinfo=\"none\">calendar</literal>, and <literal moreinfo=\"none\">spreadsheet</literal>. They have been living side-by-side in a layout like this:"
msgstr "假设有一个包含三个项目的版本库： <literal moreinfo=\"none\">calc</literal>，<literal moreinfo=\"none\">calendar</literal>，和 <literal moreinfo=\"none\">spreadsheet</literal>。它们在版本库中的布局如下："

#: build/en/book.xml:11769(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
msgstr ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"

#: build/en/book.xml:11785(para)
msgid "To get these three projects into their own repositories, we first dump the whole repository:"
msgstr "现在要把这三个项目转移到三个独立的版本库中。首先，转储整个版本库："

#: build/en/book.xml:11788(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"

#: build/en/book.xml:11798(para)
msgid "Next, run that dump file through the filter, each time including only one of our top-level directories, and resulting in three new dump files:"
msgstr "然后，将转储文件三次送入过滤器，每次仅保留一个顶级目录，就可以得到三个转储文件："

#: build/en/book.xml:118(para)
msgid "What I love about this book is that it grew out of just such a process, and shows it on every page. It is the direct result of the authors' encounters with users. It began with Ben Collins-Sussman's observation that people were asking the same basic questions over and over on the Subversion mailing lists: What are the standard workflows to use with Subversion? Do branches and tags work the same way as in other version control systems? How can I find out who made a particular change?"
msgstr "我很喜欢这本书，因为它正是按照这种精神建立起来的，这种精神体现在本书的每一页中。这是作者与用户直接交流的结果。而这一切是源于Ben Collins-Sussman's对于Subversion常见问题邮件列表的研究。他发现人们总是在邮件列表中重复询问一些基本问题：使用subversion的一般程序是怎样的？分支与标签同其它版本控制系统的工作方式一样吗？我怎样知道某一处修改是谁做的？"

#: build/en/book.xml:11802(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11812(para)
msgid "At this point, you have to make a decision. Each of your dump files will create a valid repository, but will preserve the paths exactly as they were in the original repository. This means that even though you would have a repository solely for your <literal moreinfo=\"none\">calc</literal> project, that repository would still have a top-level directory named <filename moreinfo=\"none\">calc</filename>. If you want your <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> directories to live in the root of your repository, you might wish to edit your dump files, tweaking the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers to no longer have that first <filename moreinfo=\"none\">calc/</filename> path component. Also, you'll want to remove the section of dump data that creates the <filename moreinfo=\"none\">calc</filename> directory. It will look something like:"
msgstr "现在你必须要作出一个决定了。这三个转储文件中，每个都可以用来创建一个可用的版本库，不过它们保留了原版本库的精确路径结构。也就是说，虽然项目<literal moreinfo=\"none\">calc</literal>现在独占了一个版本库，但版本库中还保留着名为<filename moreinfo=\"none\">calc</filename>的顶级目录。如果希望<filename moreinfo=\"none\">trunk</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">branches</filename>这三个目录直接位于版本库的根路径下，你可能需要编辑转储文件，调整<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>头参数，将路径<filename moreinfo=\"none\">calc/</filename>删除。同时，你还要删除转储数据中创建<filename moreinfo=\"none\">calc</filename>目录的部分。一般来说，就是如下的一些内容："

#: build/en/book.xml:11829(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"  \n"
msgstr ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"\n"

#: build/en/book.xml:11838(para)
#, fuzzy
msgid "If you do plan on manually editing the dump file to remove a top-level directory, make sure that your editor is not set to automatically convert end-lines to the native format (e.g. \\r\\n to \\n) as the content will then not agree with the metadata. This will render the dump file useless."
msgstr "如果你打算通过手工编辑转储文件来移除一个顶级目录，注意不要让你的编辑器将换行符转换为本地格式（比如将\\r\\n转换为\\n）。否则文件的内容就与所需的格式不相符，这个转储文件也就失效了。"

#: build/en/book.xml:11846(para)
msgid "All that remains now is to create your three new repositories, and load each dump file into the right repository:"
msgstr "剩下的工作就是创建三个新的版本库，然后将三个转储文件分别导入："

#: build/en/book.xml:11850(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"

#: build/en/book.xml:11869(para)
msgid "Both of <command moreinfo=\"none\">svndumpfilter</command>'s subcommands accept options for deciding how to deal with <quote>empty</quote> revisions. If a given revision contained only changes to paths that were filtered out, that now-empty revision could be considered uninteresting or even unwanted. So to give the user control over what to do with those revisions, <command moreinfo=\"none\">svndumpfilter</command> provides the following command-line options:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的两个子命令都可以通过选项设定如何处理<quote>空</quote>修订版本。如果某个指定的修订版本仅包含路径的更改，过滤器就会将它删除，因为当前为空的修订版本通常是无用的甚至是让人讨厌的。为了让用户有选择的处理这些修订版本，<command moreinfo=\"none\">svndumpfilter</command>提供了以下命令行选项："

#: build/en/book.xml:11880(option)
msgid "--drop-empty-revs"
msgstr "--drop-empty-revs"

#: build/en/book.xml:11882(para)
msgid "Do not generate empty revisions at all—just omit them."
msgstr "不生成任何空修订版本，忽略它们。"

#: build/en/book.xml:11887(option)
msgid "--renumber-revs"
msgstr "--renumber-revs"

#: build/en/book.xml:11889(para)
msgid "If empty revisions are dropped (using the <option>--drop-empty-revs</option> option), change the revision numbers of the remaining revisions so that there are no gaps in the numeric sequence."
msgstr "如果空修订版本被剔除（通过使用<option>--drop-empty-revs</option>选项），依次修改其它修订版本的编号，确保编号序列是连续的。"

#: build/en/book.xml:1189(title)
msgid "Versioning Models"
msgstr "版本模型"

#: build/en/book.xml:11896(option)
msgid "--preserve-revprops"
msgstr "--preserve-revprops"

#: build/en/book.xml:11898(para)
msgid "If empty revisions are not dropped, preserve the revision properties (log message, author, date, custom properties, etc.) for those empty revisions. Otherwise, empty revisions will only contain the original datestamp, and a generated log message that indicates that this revision was emptied by <command moreinfo=\"none\">svndumpfilter</command>."
msgstr "如果空修订版本被保留，保持这些空修订版本的属性（日志信息，作者，日期，自定义属性，等等）。如果不设定这个选项，空修订版本将仅保留初始时间戳，以及一个自动生成的日志信息，表明此修订版本由<command moreinfo=\"none\">svndumpfilter</command>处理过。"

#: build/en/book.xml:11909(para)
msgid "While <command moreinfo=\"none\">svndumpfilter</command> can be very useful, and a huge timesaver, there are unfortunately a couple of gotchas. First, this utility is overly sensitive to path semantics. Pay attention to whether paths in your dump file are specified with or without leading slashes. You'll want to look at the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers."
msgstr "尽管<command moreinfo=\"none\">svndumpfilter</command>十分有用，能节省大量的时间，但它却是把不折不扣的双刃剑。首先，这个工具对路径语义极为敏感。仔细检查转储文件中的路径是不是以斜线开头。也许<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>这两个头参数对你有些帮助。"

#: build/en/book.xml:1191(para)
msgid "The core mission of a version control system is to enable collaborative editing and sharing of data. But different systems use different strategies to achieve this. It's important to understand these different strategies for a couple of reasons. First, it will help you compare and contrast existing version control systems, in case you encounter other systems similar to Subversion. Beyond that, it will also help you make more effective use of Subversion, since Subversion itself supports a couple of different ways of working."
msgstr ""

#: build/en/book.xml:11917(screen)
#, no-wrap
msgid ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"
msgstr ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"

#: build/en/book.xml:11923(para)
#, fuzzy
msgid "If the paths have leading slashes, you should include leading slashes in the paths you pass to <command moreinfo=\"none\">svndumpfilter include</command> and <command moreinfo=\"none\">svndumpfilter exclude</command> (and if they don't, you shouldn't). Further, if your dump file has an inconsistent usage of leading slashes for some reason, <placeholder-1/> you should probably normalize those paths so they all have, or lack, leading slashes."
msgstr "如果这些路径以斜线开头，那么你传递给<command moreinfo=\"none\">svndumpfilter include</command>和<command moreinfo=\"none\">svndumpfilter exclude</command>的路径也必须以斜线开头（反之亦然）。如果因为某些原因转储文件中的路径没有统一使用或不使用斜线开头，<footnote><placeholder-1/></footnote>也许需要修正这些路径，统一使用斜线开头或不使用斜线开头。"

#: build/en/book.xml:11930(para)
msgid "While <command moreinfo=\"none\">svnadmin dump</command> has a consistent leading slash policy—to not include them—other programs which generate dump data might not be so consistent."
msgstr "尽管<command moreinfo=\"none\">svnadmin dump</command>对是否以斜线作为路径的开头有统一的规定——这个规定就是不以斜线作为路径的开头——其它生成转储文件的程序不一定会遵守这个规定。"

#: build/en/book.xml:11938(para)
msgid "Also, copied paths can give you some trouble. Subversion supports copy operations in the repository, where a new path is created by copying some already existing path. It is possible that at some point in the lifetime of your repository, you might have copied a file or directory from some location that <command moreinfo=\"none\">svndumpfilter</command> is excluding, to a location that it is including. In order to make the dump data self-sufficient, <command moreinfo=\"none\">svndumpfilter</command> needs to still show the addition of the new path—including the contents of any files created by the copy—and not represent that addition as a copy from a source that won't exist in your filtered dump data stream. But because the Subversion repository dump format only shows what was changed in each revision, the contents of the copy source might not be readily available. If you suspect that you have any copies of this sort in your repository, you might want to rethink your set of included/excluded paths."
msgstr "此外，复制操作生成的路径也会带来麻烦。Subversion支持在版本库中进行复制操作，也就是复制一个存在的路径，生成一个新的路径。问题是，<command moreinfo=\"none\">svndumpfilter</command>保留的某个文件或目录可能是由某个<command moreinfo=\"none\">svndumpfilter</command>排除的文件或目录复制而来的。也就是说，为了确保转储数据的完整性，<command moreinfo=\"none\">svndumpfilter</command>需要切断这些复制自被排除路径的文件与源文件的关系，还要将这些文件的内容以新建的方式添加到转储数据中。但是由于Subversion版本库转储文件格式中仅包含了修订版本的更改信息，因此源文件的内容基本上无法获得。如果你不能确定版本库中是否存在类似的情况，最好重新考虑一下到底保留/排除哪些路径。"

#: build/en/book.xml:11957(para)
msgid "Finally, <command moreinfo=\"none\">svndumpfilter</command> takes path filtering quite literally. If you are trying to copy the history of a project rooted at <filename moreinfo=\"none\">trunk/my-project</filename> and move it into a repository of its own, you would, of course, use the <command moreinfo=\"none\">svndumpfilter include</command> command to keep all the changes in and under <filename moreinfo=\"none\">trunk/my-project</filename>. But the resulting dump file makes no assumptions about the repository into which you plan to load this data. Specifically, the dump data might begin with the revision which added the <filename moreinfo=\"none\">trunk/my-project</filename> directory, but it will <emphasis>not</emphasis> contain directives which would create the <filename moreinfo=\"none\">trunk</filename> directory itself (because <filename moreinfo=\"none\">trunk</filename> doesn't match the include filter). You'll need to make sure that any directories which the new dump stream expect to exist actually do exist in the target repository before trying to load the stream into that repository."
msgstr ""

#: build/en/book.xml:11981(title)
#, fuzzy
msgid "Repository Replication"
msgstr "版本库的恢复"

#: build/en/book.xml:11983(para)
msgid "There are several scenarios in which it is quite handy to have a Subversion repository whose version history is exactly the same as some other repository's. Perhaps the most obvious one is the maintenance of a simple backup repository, used when the primary repository has become inaccessible due to a hardware failure, network outage, or other such annoyance. Other scenarios include deploying mirror repositories to distribute heavy Subversion load across multiple servers, use as a soft-upgrade mechanism, and so on."
msgstr ""

#: build/en/book.xml:11993(para)
msgid "As of version 1.4, Subversion provides a program for managing scenarios like these—<command moreinfo=\"none\">svnsync</command>. <command moreinfo=\"none\">svnsync</command> works by essentially asking the Subversion server to <quote>replay</quote> revisions, one at a time. It then uses that revision information to mimic a commit of the same to another repository. Neither repository needs to be locally accessible to machine on which <command moreinfo=\"none\">svnsync</command> is running—its parameters are repository URLs, and it does all its work through Subversion's repository access (RA) interfaces. All it requires is read access to the source repository and read/write access to the destination repository."
msgstr ""

#. don't seem to render it.
#: build/en/book.xml:12(subtitle)
#, fuzzy
msgid "(Compiled from r2789)"
msgstr "(本书由 r2788 版本构建)"

#: build/en/book.xml:12008(para)
msgid "When using <command moreinfo=\"none\">svnsync</command> against a remote source repository, the Subversion server for that repository must be running Subversion version 1.4 or better."
msgstr ""

#: build/en/book.xml:12013(para)
msgid "Assuming you already have a source repository that you'd like to mirror, the next thing you need is an empty target repository which will actually serve as that mirror. This target repository can use either of the available filesystem data-store back-ends (see <xref linkend=\"svn.reposadmin.basics.backends\"/>), but it must not yet have any version history in it. The protocol via which <command moreinfo=\"none\">svnsync</command> communicates revision information is highly sensitive to mismatches between the versioned histories contained in the source and target repositories. For this reason, while <command moreinfo=\"none\">svnsync</command> cannot <emphasis>demand</emphasis> that the target repository be read-only, <placeholder-1/> allowing the revision history in the target repository to change by any mechanism other than the mirroring process is a recipe for disaster."
msgstr ""

#: build/en/book.xml:12026(para)
msgid "In fact, it can't truly be read-only, or <command moreinfo=\"none\">svnsync</command> itself would have a tough time copying revision history into it."
msgstr ""

#: build/en/book.xml:1203(title)
msgid "The Problem of File-Sharing"
msgstr "文件共享的问题"

#: build/en/book.xml:12035(para)
msgid "Do <emphasis>not</emphasis> modify a mirror repository in such a way as to cause its version history to deviate from that of the repository it mirrors. The only commits and revision property modifications that ever occur on that mirror repository should be those performed by the <command moreinfo=\"none\">svnsync</command> tool."
msgstr ""

#: build/en/book.xml:12043(para)
msgid "Another requirement of the target repository is that the <command moreinfo=\"none\">svnsync</command> process be allowed to modify certain revision properties. <command moreinfo=\"none\">svnsync</command> stores its bookkeeping information in special revision properties on revision 0 of the destination repository. Because <command moreinfo=\"none\">svnsync</command> works within the framework of that repository's hook system, the default state of the repository (which is to disallow revision property changes; see <xref linkend=\"svn.ref.reposhooks.pre-revprop-change\"/>) is insufficient. You'll need to explicitly implement the pre-revprop-change hook, and your script must allow <command moreinfo=\"none\">svnsync</command> to set and change its special properties. With those provisions in place, you are ready to start mirroring repository revisions."
msgstr ""

#: build/en/book.xml:1205(para)
msgid "All version control systems have to solve the same fundamental problem: how will the system allow users to share information, but prevent them from accidentally stepping on each other's feet? It's all too easy for users to accidentally overwrite each other's changes in the repository."
msgstr "所有的版本控制系统都需要解决这样一个基础问题：怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？版本库里意外覆盖别人的更改非常的容易。"

#: build/en/book.xml:12059(para)
msgid "It's a good idea to implement authorization measures which allow your repository replication process to perform its tasks while preventing other users from modifying the contents of your mirror repository at all."
msgstr ""

#: build/en/book.xml:12065(para)
msgid "Let's walk through the use of <command moreinfo=\"none\">svnsync</command> in a somewhat typical mirroring scenario. We'll pepper this discourse with practical recommendations which you are free to disregard if they aren't required by or suitable for your environment."
msgstr ""

#: build/en/book.xml:12071(para)
msgid "As a service to the fine developers of our favorite version control system, we will be mirroring the public Subversion source code repository and exposing that mirror publicly on the Internet, hosted on a different machine than the one on which the original Subversion source code repository lives. This remote host has a global configuration which permits anonymous users to read the contents of repositories on the host, but requires users to authenticate in order to modify those repositories. (Please forgive us for glossing over the details of Subversion server configuration for the moment—those are covered thoroughly in <xref linkend=\"svn.serverconfig\"/>.) And for no other reason than that it makes for a more interesting example, we'll be driving the replication process from a third machine, the one which we currently find ourselves using."
msgstr ""

#: build/en/book.xml:12086(para)
msgid "First, we'll create the repository which will be our mirror. This and the next couple of steps do require shell access to the machine on which the mirror repository will live. Once the repository is all configured, though, we shouldn't need to touch it directly again."
msgstr ""

#: build/en/book.xml:12092(screen)
#, no-wrap
msgid ""
"\n"
"$ ssh admin@svn.example.com \\\n"
"      \"svnadmin create /path/to/repositories/svn-mirror\"\n"
"admin@svn.example.com's password: ********\n"
"$\n"
msgstr ""

#: build/en/book.xml:12099(para)
msgid "At this point, we have our repository, and due to our server's configuration, that repository is now <quote>live</quote> on the Internet. Now, because we don't want anything modifying the repository except our replication process, we need a way to distinguish that process from other would-be committers. To do so, we use a dedicated username for our process. Only commits and revision property modifications performed by the special username <literal moreinfo=\"none\">syncuser</literal> will be allowed."
msgstr ""

#: build/en/book.xml:12109(para)
msgid "We'll use the repository's hook system both to allow the replication process to do what it needs to do, and to enforce that only it is doing those things. We accomplish this by implementing two of the repository event hooks—pre-revprop-change and start-commit. Our <filename moreinfo=\"none\">pre-revprop-change</filename> hook script is found in <xref linkend=\"svn.reposadmin.maint.replication.pre-revprop-change\"/>, and basically verifies that the user attempting the property changes is our <literal moreinfo=\"none\">syncuser</literal> user. If so, the change is allowed; otherwise, it is denied."
msgstr ""

#: build/en/book.xml:1212(para)
msgid "Consider the scenario shown in <xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>. Suppose we have two co-workers, Harry and Sally. They each decide to edit the same repository file at the same time. If Harry saves his changes to the repository first, then it's possible that (a few moments later) Sally could accidentally overwrite them with her own new version of the file. While Harry's version of the file won't be lost forever (because the system remembers every change), any changes Harry made <emphasis>won't</emphasis> be present in Sally's newer version of the file, because she never saw Harry's changes to begin with. Harry's work is still effectively lost—or at least missing from the latest version of the file—and probably by accident. This is definitely a situation we want to avoid!"
msgstr "考虑<xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>的情景，我们有两个共同工作者，Harry和Sally，他们想同时编辑版本库里的同一个文件，如果首先Harry保存它的修改，过了一会，Sally可能凑巧用自己的版本覆盖了这些文件，Harry的更改不会永远消失（因为系统记录了每次修改），Harry所有的修改<emphasis>不会</emphasis>出现在Sally的文件中，所以Harry的工作还是丢失了—至少是从最新的版本中丢失了—而且是意外的，这就是我们要明确避免的情况！"

#: build/en/book.xml:12120(title)
msgid "Mirror repository's pre-revprop-change hook script"
msgstr ""

#: build/en/book.xml:12122(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$3\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may change revision properties\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""

#: build/en/book.xml:12134(para)
msgid "That covers revision property changes. Now we need to ensure that only the <literal moreinfo=\"none\">syncuser</literal> user is permitted to commit new revisions to the repository. We do this using a <filename moreinfo=\"none\">start-commit</filename> hook scripts like the one in <xref linkend=\"svn.reposadmin.maint.replication.start-commit\"/>."
msgstr ""

#: build/en/book.xml:12141(title)
msgid "Mirror repository's start-commit hook script"
msgstr ""

#: build/en/book.xml:12143(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$2\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may commit new revisions\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""

#: build/en/book.xml:12155(para)
msgid "After installing our hook scripts and ensuring that they are executable by the Subversion server, we're finished with the setup of the mirror repository. Now, we get to actually do the mirroring."
msgstr ""

#: build/en/book.xml:12160(para)
msgid "The first thing we need to do with <command moreinfo=\"none\">svnsync</command> is to register in our target repository the fact that it will be a mirror of the source repository. We do this using the <command moreinfo=\"none\">svnsync initialize</command> subcommand. Note that the various <command moreinfo=\"none\">svnsync</command> subcommands provide several of the same authentication-related options that <command moreinfo=\"none\">svn</command> does: <option>--username</option>, <option>--password</option>, <option>--non-interactive</option>, <option>--config-dir</option>, and <option>--no-auth-cache</option>."
msgstr ""

#: build/en/book.xml:12173(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help init\n"
"initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL\n"
"\n"
"Initialize a destination repository for synchronization from\n"
"another repository.\n"
"\n"
"The destination URL must point to the root of a repository with\n"
"no committed revisions.  The destination repository must allow\n"
"revision property changes.\n"
"\n"
"You should not commit to, or make revision property changes in,\n"
"the destination repository by any method other than 'svnsync'.\n"
"In other words, the destination repository should be a read-only\n"
"mirror of the source repository.\n"
"\n"
"Valid options:\n"
"  --non-interactive        : do no interactive prompting\n"
"  --no-auth-cache          : do not cache authentication tokens\n"
"  --username arg           : specify a username ARG\n"
"  --password arg           : specify a password ARG\n"
"  --config-dir arg         : read user configuration files from directory ARG\n"
"\n"
"$ svnsync initialize http://svn.example.com/svn-mirror \\\n"
"                     http://svn.collab.net/repos/svn \\\n"
"                     --username syncuser --password syncpass\n"
"Copied properties for revision 0.\n"
"$\n"
msgstr ""

#: build/en/book.xml:12203(para)
msgid "Our target repository will now remember that it is a mirror of the public Subversion source code repository. Notice that we provided a username and password as arguments to <command moreinfo=\"none\">svnsync</command>—that was required by the pre-revprop-change hook on our mirror repository."
msgstr ""

#: build/en/book.xml:12210(para)
msgid "The URLs provided to <command moreinfo=\"none\">svnsync</command> must point to the root directories of the target and source repositories, respectively. The tool does not handle mirroring of repository subtrees."
msgstr ""

#: build/en/book.xml:12217(para)
msgid "The initial release of <command moreinfo=\"none\">svnsync</command> (in Subversion 1.4) has a small shortcoming—the values given to the <option>--username</option> and <option>--password</option> command-line options get used for authentication against both the source and destination repositories. Obviously, there's no guarantee that the synchronizing user's credentials are the same in both places. In the event that they are not the same, users trying to run <command moreinfo=\"none\">svnsync</command> in non-interactive mode (with the <option>--non-interactive</option> option) might experience problems."
msgstr ""

#: build/en/book.xml:12230(para)
msgid "And now comes the fun part. With a single subcommand, we can tell <command moreinfo=\"none\">svnsync</command> to copy all the as-yet-unmirrored revisions from the source repository to the target. <placeholder-1/> The <command moreinfo=\"none\">svnsync synchronize</command> subcommand will peek into the special revision properties previously stored on the target repository, and determine what repository it is mirroring and that the most recently mirrored revision was revision 0. Then it will query the source repository and determine what the latest revision in that repository is. Finally, it asks the source repository's server to start replaying all the revisions between 0 and that latest revision. As <command moreinfo=\"none\">svnsync</command> get the resulting response from the source repository's server, it begins forwarding those revisions to the target repository's server as new commits."
msgstr ""

#: build/en/book.xml:12235(para)
msgid "Be forewarned that while it will take only a few seconds for the average reader to parse this paragraph and the sample output which follows it, the actual time required to complete such a mirroring operation is, shall we say, quite a bit longer."
msgstr ""

#: build/en/book.xml:12254(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help synchronize\n"
"synchronize (sync): usage: svnsync synchronize DEST_URL\n"
"\n"
"Transfer all pending revisions from source to destination.\n"
"…\n"
"$ svnsync synchronize http://svn.example.com/svn-mirror \\\n"
"                      --username syncuser --password syncpass\n"
"Committed revision 1.\n"
"Copied properties for revision 1.\n"
"Committed revision 2.\n"
"Copied properties for revision 2.\n"
"Committed revision 3.\n"
"Copied properties for revision 3.\n"
"…\n"
"Committed revision 23406.\n"
"Copied properties for revision 23406.\n"
"Committed revision 23407.\n"
"Copied properties for revision 23407.\n"
"Committed revision 23408.\n"
"Copied properties for revision 23408.\n"
msgstr ""

#: build/en/book.xml:12277(para)
msgid "Of particular interest here is that for each mirrored revision, there is first a commit of that revision to the target repository, and then property changes follow. This is because the initial commit is performed by (and attributed to) the user <literal moreinfo=\"none\">syncuser</literal>, and datestamped with the time as of that revision's creation. Also, Subversion's underlying repository access interfaces don't provide a mechanism for setting arbitary revision properties as part of a commit. So <command moreinfo=\"none\">svnsync</command> follows up with an immediate series of property modifications which copy all the revision properties found for that revision in the source repository into the target repository. This also has the effect of fixing the author and datestamp of the revision to match that of the source repository."
msgstr ""

#: build/en/book.xml:1228(title)
msgid "The problem to avoid"
msgstr "需要避免的问题"

#: build/en/book.xml:12292(para)
msgid "Also noteworthy is that <command moreinfo=\"none\">svnsync</command> performs careful bookkeeping that allows it to be safely interrupted and restarted without ruining the integrity of the mirrored data. If a network glitch occurs while mirroring a repository, simply repeat the <command moreinfo=\"none\">svnsync synchronize</command> command and it will happily pick up right where it left off. In fact, as new revisions appear in the source repository, this is exactly what you to do in order to keep your mirror up-to-date."
msgstr ""

#: build/en/book.xml:12302(para)
msgid "There is, however, one bit of inelegance in the process. Because Subversion revision properties can be changed at any time throughout the lifetime of the repository, and don't leave an audit trail that indicates when they were changed, replication processes have to pay special attention to them. If you've already mirror the first 15 revisions of a repository and someone then changes a revision property on revision 12, <command moreinfo=\"none\">svnsync</command> won't know to go back and patch up its copy of revision 12. You'll need to tell it to do so manually by using (or with some additionally tooling around) the <command moreinfo=\"none\">svnsync copy-revprops</command> subcommand, which simply re-replicates all the revision properties for a particular revision."
msgstr ""

#: build/en/book.xml:12316(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help copy-revprops\n"
"copy-revprops: usage: svnsync copy-revprops DEST_URL REV\n"
"\n"
"Copy all revision properties for revision REV from source to\n"
"destination.\n"
"…\n"
"$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \\\n"
"                        --username syncuser --password syncpass\n"
"Copied properties for revision 12.\n"
"$\n"
msgstr ""

#: build/en/book.xml:12329(para)
msgid "That's repository replication in a nutshell. You'll likely want some automation around such a process. For example, while our example was a pull-and-push setup, you might wish to have your primary repository push changes to one or more blessed mirrors as part of its post-commit and post-revprop-change hook implementations. This would enable the mirror to be up-to-date in as near to realtime as is likely possible."
msgstr ""

#: build/en/book.xml:12338(para)
msgid "Also, while it isn't very commonplace to do so, <command moreinfo=\"none\">svnsync</command> does gracefully mirror repositories in which the user as whom it authenticates only has partial read access. It simply copies only the bits of the repository that it is permitted to see. Obviously such a mirror is not useful as a backup solution."
msgstr ""

#: build/en/book.xml:12345(para)
msgid "As far as user interaction with repositories and mirrors goes, it <emphasis>is</emphasis> possible to have a single working copy that interacts with both, but you'll have to jump through some hoops to make it happen. First, you need to ensure that both the primary and mirror repositories have the same repository UUID (which is not the case by default). You can set the mirror repository's UUID by loading a dump file stub into it which contains the UUID of the primary repository, like so:"
msgstr ""

#: build/en/book.xml:12355(screen)
#, no-wrap
msgid ""
"\n"
"$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest\n"
"SVN-fs-dump-format-version: 2\n"
"\n"
"UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e\n"
"EOF\n"
"$\n"
msgstr ""

#: build/en/book.xml:1236(title)
msgid "The Lock-Modify-Unlock Solution"
msgstr "锁定-修改-解锁 方案"

#: build/en/book.xml:12364(para)
msgid "Now that the two repositories have the same UUID, you can use <command moreinfo=\"none\">svn switch --relocate</command> to point your working copy to whichever of the repositories you wish to operate against, a process which is described in <xref linkend=\"svn.ref.svn.c.switch\"/>. There is a possible danger here, though, in that if the primary and mirror repositories aren't in close synchronization, a working copy up-to-date with and pointing to the primary repository will, if relocated to point to an out-of-date mirror, become confused about the apparent sudden loss of revisions it fully expects to be present."
msgstr ""

#: build/en/book.xml:12375(para)
msgid "Finally, be aware that the revision-based replication provided by <command moreinfo=\"none\">svnsync</command> is only that—replication of revisions. It does not include such things as the hook implementations, repository or server configuration data, uncommitted transactions, or information about user locks on repository paths. Only information carried by the Subversion repository dump file format is available for replication."
msgstr ""

#: build/en/book.xml:1238(para)
msgid "Many version control systems use a <firstterm>lock-modify-unlock</firstterm> model to address the problem of many authors clobbering each other's work. In this model, the repository allows only one person to change a file at a time. This exclusivity policy is managed using locks. Harry must <quote>lock</quote> a file before he can begin making changes to it. If Harry has locked a file, then Sally cannot also lock it, and therefore cannot make any changes to that file. All she can do is read the file, and wait for Harry to finish his changes and release his lock. After Harry unlocks the file, Sally can take her turn by locking and editing the file. <xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/> demonstrates this simple solution."
msgstr "许多版本控制系统使用<firstterm>锁定-修改-解锁</firstterm>这种机制解决这种问题，在这样的模型里，在一个时间段里版本库的一个文件只允许被一个人修改。首先在修改之前，Harry要<quote>锁定</quote>住这个文件，锁定很像是从图书馆借一本书，如果Harry锁住这个文件，Sally不能做任何修改，如果Sally想请求得到一个锁，版本库会拒绝这个请求。在Harry结束编辑并且放开这个锁之前，她只可以阅读文件。Harry解锁后，就要换班了，Sally得到自己的轮换位置，锁定并且开始编辑这个文件。<xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/>描述了这样的解决方案。"

#: build/en/book.xml:12388(title)
msgid "Repository Backup"
msgstr "版本库备份"

#: build/en/book.xml:12390(para)
msgid "Despite numerous advances in technology since the birth of the modern computer, one thing unfortunately rings true with crystalline clarity—sometimes, things go very, very awry. Power outages, network connectivity dropouts, corrupt RAM and crashed hard drives are but a taste of the evil that Fate is poised to unleash on even the most conscientious administrator. And so we arrive at a very important topic—how to make backup copies of your repository data."
msgstr "尽管现代计算机的诞生带来了许多便利，但有一件事听起来是完全正确的—有时候，事情变的糟糕，很糟糕，动力损耗、网络中断、坏掉的内存和损坏的硬盘都是对魔鬼的一种体验，即使对于最尽职的管理员，命运也早已注定。所以我们来到了这个最重要的主题—怎样备份你的版本库数据。"

#: build/en/book.xml:12400(para)
msgid "There are two types of backup methods available for Subversion repository administrators—full and incremental. A full backup of the repository involves squirreling away in one sweeping action all the information required to fully reconstruct that repository in the event of a catastrophe. Usually, it means quite literally the duplication of the entire repository directory (which includes either a Berkeley DB or FSFS environment). Incremental backups are lesser things, backups of only the portion of the repository data that has changed since the previous backup."
msgstr ""

#: build/en/book.xml:12412(para)
msgid "As far as full backups go, the naive approach might seem like a sane one, but unless you temporarily disable all other access to your repository, simply doing a recursive directory copy runs the risk of generating a faulty backup. In the case of Berkeley DB, the documentation describes a certain order in which database files can be copied that will guarantee a valid backup copy. A similar ordering exists for FSFS data. But you don't have to implement these algorithms yourself, because the Subversion development team has already done so. The <command moreinfo=\"none\">svnadmin hotcopy</command> command takes care of the minutia involved in making a hot backup of your repository. And its invocation is as trivial as Unix's <command moreinfo=\"none\">cp</command> or Windows' <command moreinfo=\"none\">copy</command> operations:"
msgstr ""

#: build/en/book.xml:12427(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"
msgstr ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"

#: build/en/book.xml:12431(para)
msgid "The resulting backup is a fully functional Subversion repository, able to be dropped in as a replacement for your live repository should something go horribly wrong."
msgstr "作为结果的备份是一个完全功能的版本库，当发生严重错误时可以作为你的活动版本库的替换。"

#: build/en/book.xml:12435(para)
msgid "When making copies of a Berkeley DB repository, you can even instruct <command moreinfo=\"none\">svnadmin hotcopy</command> to purge any unused Berkeley DB logfiles (see <xref linkend=\"svn.reposadmin.maint.diskspace.bdblogs\"/>) from the original repository upon completion of the copy. Simply provide the <option>--clean-logs</option> option on the command-line."
msgstr ""

#: build/en/book.xml:12442(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup\n"
msgstr ""

#: build/en/book.xml:12446(para)
msgid "Additional tooling around this command is available, too. The <filename moreinfo=\"none\">tools/backup/</filename> directory of the Subversion source distribution holds the <command moreinfo=\"none\">hot-backup.py</command> script. This script adds a bit of backup management atop <command moreinfo=\"none\">svnadmin hotcopy</command>, allowing you to keep only the most recent configured number of backups of each repository. It will automatically manage the names of the backed-up repository directories to avoid collisions with previous backups, and will <quote>rotate off</quote> older backups, deleting them so only the most recent ones remain. Even if you also have an incremental backup, you might want to run this program on a regular basis. For example, you might consider using <command moreinfo=\"none\">hot-backup.py</command> from a program scheduler (such as <command moreinfo=\"none\">cron</command> on Unix systems) which will cause it to run nightly (or at whatever granularity of Time you deem safe enough for you)."
msgstr ""

#: build/en/book.xml:12464(para)
msgid "Some administrators use a different backup mechanism built around generating and storing repository dump data. We described in <xref linkend=\"svn.reposadmin.maint.migrate\"/> how to use <command moreinfo=\"none\">svnadmin dump --incremental</command> to perform an incremental backup of a given revision or range of revisions. And of course, there is a full backup variation of this achieved by omitting the <option>--incremental</option> option to that command. There is some value in these methods in that the format of your backed-up information is flexible—it's not tied to a particular platform, versioned filesystem type, or release of Subversion or Berkeley DB. But that flexibility comes at a cost, namely that restoring that data can take a long time—longer with each new revision committed to your repository. Also, as is the case with so many of the various backup methods, revision property changes made to already-backed-up revisions won't get picked up by a non-overlapping, incremental dump generation. For these reasons, we recommend against relying solely on dump-based backup approaches."
msgstr ""

#: build/en/book.xml:12484(para)
#, fuzzy
msgid "As you can see, each of the various backup types and methods has its advantages and disadvantages. The easiest is by far the full hot backup, which will always result in a perfect working replica of your repository. Should something bad happen to your live repository, you can restore from the backup with a simple recursive directory copy. Unfortunately, if you are maintaining multiple backups of your repository, these full copies will each eat up just as much disk space as your live repository. Incremental backups, by contrast, tend to be quicker to generate and smaller to store. But the restoration process can be a pain, often involving applying multiple incremental backups. And other methods have their own peculiarities. Administators need to find the balance between the cost of making the backup and the cost of restoring it."
msgstr "两种备份方式都有各自的优点，最简单的方式是完全备份，将会每次建立版本库的完美复制品，这意味着如果当你的活动版本库发生了什么事情，你可以用备份恢复。但不幸的是，如果你维护多个备份，每个完全的备份会吞噬掉和你的活动版本库同样的空间。"

#: build/en/book.xml:12500(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program (see <xref linkend=\"svn.reposadmin.maint.replication\"/>) actually provides a rather handy middle-ground approach. If you are regularly synchronizing a read-only mirror with your main repository, then in a pinch, your read-only mirror is probably a good candidate for replacing that main repository if it falls over. The primary disadvantage of this method is that only the versioned repository data gets synchronized—repository configuration files, user-specified repository path locks, and other items which might live in the physical repository directory but not <emphasis>inside</emphasis> the repository's virtual versioned filesystem are not handled by svnsync."
msgstr ""

#: build/en/book.xml:12513(para)
#, fuzzy
msgid "In any backup scenario, repository administrators need to be aware of how modifications to unversioned revision properties affect their backups. Since these changes do not themselves generate new revisions, they will not trigger post-commit hooks, and may not even trigger the pre-revprop-change and post-revprop-change hooks. <placeholder-1/> And since you can change revision properties without respect to chronological order—you can change any revision's properties at any time—an incremental backup of the latest few revisions might not catch a property modification to a revision that was included as part of a previous backup."
msgstr "在每一种备份情境下，版本库管理员需要意识到对未版本化的修订版本属性的修改对备份的影响，因为这些修改本身不会产生新的修订版本，所以不会触发post-commit的钩子程序，也不会触发pre-revprop-change和post-revprop-change的钩子。 <footnote><placeholder-1/></footnote> 而且因为你可以改变修订版本的属性，而不需要遵照时间顺序—你可在任何时刻修改任何修订版本的属性—因此最新版本的增量备份不会捕捉到以前特定修订版本的属性修改。"

#: build/en/book.xml:12520(para)
msgid "<command moreinfo=\"none\">svnadmin setlog</command> can be called in a way that bypasses the hook interface altogether."
msgstr "<command moreinfo=\"none\">svnadmin setlog</command>可以被绕过钩子程序被调用。"

#: build/en/book.xml:1253(title)
msgid "The lock-modify-unlock solution"
msgstr "锁定-修改-解锁 方案2"

#: build/en/book.xml:12530(para)
#, fuzzy
msgid "Generally speaking, only the truly paranoid would need to backup their entire repository, say, every time a commit occurred. However, assuming that a given repository has some other redundancy mechanism in place with relatively fine granularity (like per-commit emails or incremental dumps), a hot backup of the database might be something that a repository administrator would want to include as part of a system-wide nightly backup. It's your data—protect it as much as you'd like."
msgstr "通常说来，在每次提交时，只有妄想狂才会备份整个版本库，然而，假设一个给定的版本库拥有一些恰当粒度的冗余机制（如每次提交的邮件）。版本库管理员也许会希望将版本库的热备份引入到系统级的每夜备份，对大多数版本库，归档的提交邮件为保存资源提供了足够的冗余措施，至少对于最近的提交。但是它是你的数据—你喜欢怎样保护都可以。"

#: build/en/book.xml:12540(para)
#, fuzzy
msgid "Often, the best approach to repository backups is a diversified one which leverages combinations of the methods described here. The Subversion developers, for example, back up the Subversion source code repository nightly using <command moreinfo=\"none\">hot-backup.py</command> and an offsite <command moreinfo=\"none\">rsync</command> of those full backups; keep multiple archives of all the commit and property change notification emails; and have repository mirrors maintained by various volunteers using <command moreinfo=\"none\">svnsync</command>. Your solution might be similar, but should be catered to your needs and that delicate balance of convenience with paranoia. And whatever you do, validate your backups from time to time—what good is a spare tire that has a hole in it? While all of this might not save your hardware from the iron fist of Fate, <placeholder-1/> it should certainly help you recover from those trying times."
msgstr "通常情况下，最好的版本库备份方式是混合的，你可以平衡完全和增量备份，另外配合提交邮件的归档，Subversion开发者，举个例子，在每个新的修订版本建立时备份Subversion的源代码版本库，并且保留所有的提交和属性修改通知文件。你的解决方案类似，必须迎合你的需要，平衡便利和你的偏执。然而这些不会改变你的硬件来自钢铁的命运。<footnote><placeholder-1/></footnote> 这一定会帮助你减少尝试的时间。"

#: build/en/book.xml:12555(para)
msgid "You know—the collective term for all of her <quote>fickle fingers</quote>."
msgstr "你知道的—只是对各种变化莫测的问题的统称。"

#: build/en/book.xml:12569(title) build/en/book.xml:2047(title)
#: build/en/book.xml:3978(title) build/en/book.xml:9639(title)
msgid "Summary"
msgstr "概要"

#: build/en/book.xml:1257(para)
msgid "The problem with the lock-modify-unlock model is that it's a bit restrictive, and often becomes a roadblock for users:"
msgstr "锁定-修改-解锁模型有一点问题就是限制太多，经常会成为用户的障碍："

#: build/en/book.xml:12571(para)
msgid "By now you should have a basic understanding of how to create, configure, and maintain Subversion repositories. We've introduced you to the various tools that will assist you with this task. Throughout the chapter, we've noted common administration pitfalls, and suggestions for avoiding them."
msgstr "现在，你应该已经对如何创建、配置以及维护Subversion版本库有了个基本的认识。我们向您介绍了几个可以帮助您工作的工具。通过这一章，我们说明了一些常见的管理误区，并提出了避免陷入误区的建议。"

#: build/en/book.xml:12578(para)
msgid "All that remains is for you to decide what exciting data to store in your repository, and finally, how to make it available over a network. The next chapter is all about networking."
msgstr "剩下的，就是由你决定在你的版本库中存放一些什么有趣的资料，并最终通过网络获得这些资料。下一章是关于网络的内容。"

#: build/en/book.xml:12592(title)
msgid "Server Configuration"
msgstr "配置服务器"

#: build/en/book.xml:12594(para)
#, fuzzy
msgid "A Subversion repository can be accessed simultaneously by clients running on the same machine on which the repository resides using the <literal moreinfo=\"none\">file://</literal> method. But the typical Subversion setup involves a single server machine being accessed from clients on computers all over the office—or, perhaps, all over the world."
msgstr "一个Subversion的版本库可以和客户端同时运行在同一个机器上，使用<literal moreinfo=\"none\">file:///</literal>访问，但是一个典型的Subversion设置应该包括一个单独的服务器，可以被办公室的所有客户端访问—或者有可能是整个世界。"

#: build/en/book.xml:12601(para)
#, fuzzy
msgid "This chapter describes how to get your Subversion repository exposed outside its host machine for use by remote clients. We will cover Subversion's currently available server mechanisms, discussing the configuration and use of each. After reading this section, you should be able to decide which networking setup is right for your needs, and understand how to enable such a setup on your host computer."
msgstr "本小节描述了怎样将一个Subversion的版本库暴露给远程客户端，我们会覆盖Subversion已存在的服务器机制，讨论各种方式的配置和使用。经过阅读本小节，你可以决定你需要哪种网络设置，并且明白怎样在你的主机上进行配置。"

#: build/en/book.xml:12615(title)
msgid "Overview"
msgstr "概述"

#: build/en/book.xml:12617(para)
#, fuzzy
msgid "Subversion was designed with an abstract network layer. This means that a repository can be programmatically accessed by any sort of server process, and the client <quote>repository access</quote> API allows programmers to write plugins that speak relevant network protocols. In theory, Subversion can use an infinite number of network implementations. In practice, there are only two servers at the time of this writing."
msgstr "Subversion的设计包括一个抽象的网络层，这意味着版本库可以通过各种服务器进程访问，而且客户端<quote>版本库访问</quote>的API允许程序员写出相关协议的插件，理论上讲，Subversion可以使用无限数量的网络协议实现，目前实践中存在着两种服务器。"

#: build/en/book.xml:12625(para)
#, fuzzy
msgid "Apache is an extremely popular webserver; using the <command moreinfo=\"none\">mod_dav_svn</command> module, Apache can access a repository and make it available to clients via the WebDAV/DeltaV protocol, which is an extension of HTTP. Because Apache is an extremely extensible web server, it provides a number of features <quote>for free</quote>, such as encrypted SSL communication, logging, integration with a number of third-party authentication systems, and limited built-in web browsing of repositories."
msgstr "Apache是最流行的web服务器，通过使用<command moreinfo=\"none\">mod_dav_svn</command>模块，Apache可以访问版本库，并且可以使客户端使用HTTP的扩展协议WebDAV/DeltaV进行访问，另一个是<command moreinfo=\"none\">svnserve</command>：一个小的，独立服务器，使用自己定义的协议和客户端，表格6-1比较了这两种服务器。"

#: build/en/book.xml:1263(para)
#, fuzzy
msgid "<emphasis>Locking may cause administrative problems.</emphasis> Sometimes Harry will lock a file and then forget about it. Meanwhile, because Sally is still waiting to edit the file, her hands are tied. And then Harry goes on vacation. Now Sally has to get an administrator to release Harry's lock. The situation ends up causing a lot of unnecessary delay and wasted time."
msgstr "<emphasis>锁定可能导致管理问题。</emphasis>有时候Harry会锁住文件然后忘了此事，这就是说Sally一直等待解锁来编辑这些文件，她在这里僵住了。然后Harry去旅行了，现在Sally只好去找管理员放开锁，这种情况会导致不必要的耽搁和时间浪费。"

#: build/en/book.xml:12635(para)
msgid "In the other corner is <command moreinfo=\"none\">svnserve</command>: a small, lightweight server program that speaks a custom protocol with clients. Because its protocol is explicitly designed for Subversion and is stateful (unlike HTTP), it provides significantly faster network operations—but at the cost of some features as well. It only understands CRAM-MD5 authentication, has no logging, no web-browsing, and no option to encrypt network traffic. It is, however, extremely easy to set up and is often the best option for small teams just starting out with Subversion."
msgstr ""

#: build/en/book.xml:12646(para)
msgid "A third option is to use <command moreinfo=\"none\">svnserve</command> tunneled over an SSH connection. Even though this scenario still uses <command moreinfo=\"none\">svnserve</command>, it differs quite a bit in features from a traditional <command moreinfo=\"none\">svnserve</command> deployment. SSH is used to encrypt all communication. SSH is also used exclusively to authenticate, so real system accounts are required on the server host (unlike vanilla <command moreinfo=\"none\">svnserve</command>, which has its own private user accounts.) Finally, because this setup requires that each user spawn a private, temporary <command moreinfo=\"none\">svnserve</command> process, it's equivalent (from a permissions point of view) to allowing a group of local users to all access the repository via <literal moreinfo=\"none\">file://</literal> URLs. Path-based access control has no meaning, since each user is accessing the repository database files directly."
msgstr ""

#: build/en/book.xml:12662(para)
msgid "Here's a quick summary of the three typical server deployments."
msgstr ""

#: build/en/book.xml:12666(title)
msgid "Comparison of Subversion Server Options"
msgstr ""

#: build/en/book.xml:12671(entry)
msgid "Apache + mod_dav_svn"
msgstr "Apache + mod_dav_svn"

#: build/en/book.xml:12673(entry)
#, fuzzy
msgid "svnserve over SSH"
msgstr "svnserve"

#: build/en/book.xml:12678(entry)
msgid "Authentication options"
msgstr "认证选项"

#: build/en/book.xml:12679(entry)
msgid "HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or any other mechanism available to Apache httpd"
msgstr "HTTP(S) basic auth、X.509 certificates、LDAP、NTLM或任何Apache httpd已经具备的方式"

#: build/en/book.xml:12681(entry)
msgid "CRAM-MD5"
msgstr "CRAM-MD5"

#: build/en/book.xml:12682(entry)
msgid "SSH"
msgstr "SSH"

#: build/en/book.xml:12686(entry)
msgid "User account options"
msgstr "用户帐号选项"

#: build/en/book.xml:12687(entry) build/en/book.xml:12688(entry)
msgid "private 'users' file"
msgstr "私有的'users'文件"

#: build/en/book.xml:12689(entry)
msgid "system accounts"
msgstr "系统帐号"

#: build/en/book.xml:12693(entry)
msgid "Authorization options"
msgstr "授权选项"

#: build/en/book.xml:12694(entry) build/en/book.xml:12696(entry)
msgid "read/write access can be granted over whole repository, or specified per-path."
msgstr ""

#: build/en/book.xml:12698(entry)
msgid "read/write access only grantable over whole repository"
msgstr ""

#: build/en/book.xml:127(para)
msgid "Frustrated at seeing the same questions day after day, Ben worked intensely over a month in the summer of 2002 to write <citetitle>The Subversion Handbook</citetitle>, a sixty page manual that covered all the basics of using Subversion. The manual made no pretense of being complete, but it was distributed with Subversion and got users over that initial hump in the learning curve. When O'Reilly and Associates decided to publish a full-length Subversion book, the path of least resistance was obvious: just expand the Subversion handbook."
msgstr "日复一日看到相同问题的烦闷，促使Ben在2002年的夏天努力工作了一个月，撰写了一本<citetitle>Subversion手册</citetitle>，一本六十页厚的、涵盖了所有Subversion使用基础知识的手册。这本手册没有说明最终定稿的时间，但它随着Subversion的每个版本一起发布，帮助许多用户跨过学习之初的艰难。当O'Reilly和Associates决定出版一本完备的Subversion图书的时候，一条捷径浮出水面：扩充Subversion手册。"

#: build/en/book.xml:12703(entry)
msgid "Encryption"
msgstr "加密"

#: build/en/book.xml:12704(entry)
msgid "via optional SSL"
msgstr "通过选择SSL"

#: build/en/book.xml:12705(entry)
msgid "none"
msgstr "无"

#: build/en/book.xml:12706(entry)
msgid "SSH tunneled"
msgstr ""

#: build/en/book.xml:12710(entry)
msgid "Logging"
msgstr "日志"

#: build/en/book.xml:12711(entry)
msgid "full Apache logs of each HTTP request, with optional <placeholder-1/> logging of general client operations"
msgstr ""

#: build/en/book.xml:12712(quote)
msgid "high-level"
msgstr ""

#: build/en/book.xml:12714(entry) build/en/book.xml:12715(entry)
msgid "no logging"
msgstr ""

#: build/en/book.xml:12719(entry)
msgid "Interoperability"
msgstr "交互性"

#: build/en/book.xml:12720(entry)
msgid "partially usable by other WebDAV clients"
msgstr "可以部分的被其他WebDAV客户端使用"

#: build/en/book.xml:12721(entry) build/en/book.xml:12722(entry)
msgid "only talks to svn clients"
msgstr ""

#: build/en/book.xml:12726(entry)
msgid "Web viewing"
msgstr "Web浏览能力"

#: build/en/book.xml:12727(entry)
msgid "limited built-in support, or via 3rd-party tools such as ViewVC"
msgstr "有限的内置支持，或者通过第三方工具，如ViewVC"

#: build/en/book.xml:12729(entry) build/en/book.xml:12730(entry)
#, fuzzy
msgid "only via 3rd-party tools such as ViewVC"
msgstr "通过第三方工具，如ViewVC"

#: build/en/book.xml:12734(entry)
msgid "Speed"
msgstr "速度"

#: build/en/book.xml:12735(entry)
msgid "somewhat slower"
msgstr "有些慢"

#: build/en/book.xml:12736(entry) build/en/book.xml:12737(entry)
msgid "somewhat faster"
msgstr "快一点"

#: build/en/book.xml:12741(entry) build/en/book.xml:13603(title)
msgid "Initial setup"
msgstr "初始设置"

#: build/en/book.xml:12742(entry)
msgid "somewhat complex"
msgstr "有些复杂"

#: build/en/book.xml:12743(entry)
msgid "extremely simple"
msgstr "极为简单"

#: build/en/book.xml:12744(entry)
#, fuzzy
msgid "moderately simple"
msgstr "相当简单"

#: build/en/book.xml:1275(para)
#, fuzzy
msgid "<emphasis>Locking may cause unnecessary serialization.</emphasis> What if Harry is editing the beginning of a text file, and Sally simply wants to edit the end of the same file? These changes don't overlap at all. They could easily edit the file simultaneously, and no great harm would come, assuming the changes were properly merged together. There's no need for them to take turns in this situation."
msgstr "<emphasis>锁定可能导致不必要的线性化开发。</emphasis>如果Harry编辑一个文件的开始，Sally想编辑同一个文件的结尾，这种修改不会冲突，设想修改可以正确的合并到一起，他们可以轻松的并行工作而没有太多的坏处，没有必要让他们轮流工作。"

#: build/en/book.xml:12755(title)
#, fuzzy
msgid "Choosing a Server Configuration"
msgstr "配置服务器"

#: build/en/book.xml:12757(para)
msgid "So, which server should you use? Which is best?"
msgstr ""

#: build/en/book.xml:12759(para)
msgid "Obviously, there's no right answer to that question. Every team has different needs, and the different servers all represent different sets of tradeoffs. The Subversion project itself doesn't endorse one server or another, or consider either server more <quote>official</quote> than another."
msgstr ""

#: build/en/book.xml:12765(para)
msgid "Here are some reasons why you might choose one deployment over another, as well as reasons you might <emphasis>not</emphasis> choose one."
msgstr ""

#: build/en/book.xml:12771(title)
#, fuzzy
msgid "The <command moreinfo=\"none\">svnserve</command> Server"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:12775(term) build/en/book.xml:12826(term)
#: build/en/book.xml:12874(term)
msgid "Why you might want to use it:"
msgstr ""

#: build/en/book.xml:12779(para)
msgid "Quick and easy to set up."
msgstr ""

#: build/en/book.xml:12782(para) build/en/book.xml:12830(para)
msgid "Network protocol is stateful and noticeably faster than WebDAV."
msgstr ""

#: build/en/book.xml:12785(para) build/en/book.xml:12882(para)
msgid "No need to create system accounts on server."
msgstr ""

#: build/en/book.xml:12788(para)
msgid "Password is not passed over the network."
msgstr ""

#: build/en/book.xml:12796(term) build/en/book.xml:12844(term)
#: build/en/book.xml:12905(term)
msgid "Why you might want to avoid it:"
msgstr ""

#: build/en/book.xml:12800(para)
msgid "Network protocol is not encrypted."
msgstr ""

#: build/en/book.xml:12803(para) build/en/book.xml:12848(para)
#, fuzzy
msgid "Only one choice of authentication method."
msgstr "回应所有的认证请求。"

#: build/en/book.xml:12806(para)
#, fuzzy
msgid "Password is stored in the clear on the server."
msgstr "在服务器这个项目有了新的修订版本。"

#: build/en/book.xml:12809(para) build/en/book.xml:12851(para)
msgid "No logging of any kind, not even errors."
msgstr ""

#: build/en/book.xml:12822(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> over SSH"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:12833(para)
msgid "You can take advantage of existing ssh accounts and user infrastructure."
msgstr ""

#: build/en/book.xml:12836(para)
msgid "All network traffic is encrypted."
msgstr ""

#: build/en/book.xml:12854(para)
msgid "Requires users to be in same system group, or use a shared ssh key."
msgstr ""

#: build/en/book.xml:12857(para)
msgid "Can lead to file permissions problems."
msgstr ""

#: build/en/book.xml:12870(title)
#, fuzzy
msgid "The Apache HTTP Server"
msgstr "httpd，Apache的HTTP服务器"

#: build/en/book.xml:12878(para)
msgid "Allows Subversion to use any of the numerous authentication systems already integrated with Apache."
msgstr ""

#: build/en/book.xml:1288(para)
#, fuzzy
msgid "<emphasis>Locking may create a false sense of security.</emphasis> Suppose Harry locks and edits file A, while Sally simultaneously locks and edits file B. But what if A and B depend on one another, and the changes made to each are semantically incompatible? Suddenly A and B don't work together anymore. The locking system was powerless to prevent the problem—yet it somehow provided a false sense of security. It's easy for Harry and Sally to imagine that by locking files, each is beginning a safe, insulated task, and thus not bother discussing their incompatible changes early on. Locking often becomes a substitute for real communication."
msgstr "<emphasis>锁定可能导致错误的安全状态。</emphasis>假设Harry锁定和编辑一个文件A，同时Sally锁定并编辑文件B，如果A和B互相依赖，这种变化是必须同时作的，这样A和B不能正确的工作了，锁定机制对防止此类问题将无能为力—从而产生了一种处于安全状态的假相。很容易想象Harry和Sally都以为自己锁住了文件，而且从一个安全，孤立的情况开始工作，因而没有尽早发现他们不匹配的修改。"

#: build/en/book.xml:12885(para)
msgid "Full Apache logging."
msgstr ""

#: build/en/book.xml:12887(para)
msgid "Network traffic can be encrypted via SSL."
msgstr ""

#: build/en/book.xml:12890(para)
msgid "HTTP(S) can usually go through corporate firewalls."
msgstr ""

#: build/en/book.xml:12893(para)
msgid "Built-in repository browsing via web browser."
msgstr ""

#: build/en/book.xml:12896(para)
#, fuzzy
msgid "Repository can be mounted as a network drive for transparent version control. (See <xref linkend=\"svn.webdav.autoversioning\"/>.)"
msgstr "如果出现，则修订版本是通过自动版本化特性创建，见<xref linkend=\"svn.webdav.autoversioning\"/>。"

#: build/en/book.xml:12909(para)
msgid "Noticeably slower than svnserve, because HTTP is a stateless protocol and requires more turnarounds."
msgstr ""

#: build/en/book.xml:12913(para)
#, fuzzy
msgid "Initial setup can be complex."
msgstr "初始设置"

#: build/en/book.xml:12925(title)
msgid "Recommendations"
msgstr "忠告"

#: build/en/book.xml:12927(para)
msgid "In general, the authors of this book recommend a vanilla <command moreinfo=\"none\">svnserve</command> installation for small teams just trying to get started with a Subversion server; it's the simplest to set up, and has the fewest maintenance issues. Remember, you can always switch to a more complex server deployment as your needs change."
msgstr ""

#: build/en/book.xml:12934(para)
msgid "Here are some general recommendations and tips, based on years of supporting users:"
msgstr ""

#: build/en/book.xml:12939(para)
msgid "If you're trying to set up the simplest possible server for your group, then a vanilla <command moreinfo=\"none\">svnserve</command> installation is the easiest, fastest route. Note, however, that your repository data will be transmitted in the clear over the network. If your deployment is entirely within your company's LAN or VPN, this isn't an issue. If the repository is exposed to the wide-open internet, then you might want to make sure the repository's contents aren't sensitive (e.g. it contains only open-source code.)"
msgstr ""

#: build/en/book.xml:12952(para)
msgid "If you need to integrate with existing identity systems (LDAP, Active Directory, NTLM, X.509, etc.), then an Apache-based server is your only real option. Similarly, if you absolutely need server-side logs of either server errors or client activities, then an Apache-based server is required."
msgstr ""

#: build/en/book.xml:12961(para)
msgid "If you've decided to use either Apache or stock <command moreinfo=\"none\">svnserve</command>, create a single <literal moreinfo=\"none\">svn</literal> user on your system and run the server process as that user. Be sure to make the repository directory wholly owned by the <literal moreinfo=\"none\">svn</literal> user as well. From a security point of view, this keeps the repository data nicely siloed and protected by operating system filesystem permissions, changeable by only the Subversion server process itself."
msgstr ""

#: build/en/book.xml:12974(para)
msgid "If you have an existing infrastructure heavily based on SSH accounts, and if your users already have system accounts on your server machine, then it makes sense to deploy an svnserve-over-ssh solution. Otherwise, we don't widely recommend this option to the public. It's generally considered safer to have your users access the repository via (imaginary) accounts managed by <command moreinfo=\"none\">svnserve</command> or Apache, rather than by full-blown system accounts. If your deep desire for encrypted communication still draws you to this option, we recommend using Apache with SSL instead."
msgstr ""

#: build/en/book.xml:12988(para)
msgid "Do <emphasis>not</emphasis> be seduced by the simple idea of having all of your users access a repository directly via <literal moreinfo=\"none\">file://</literal> URLs. Even if the repository is readily available to everyone via network share, this is a bad idea. It removes any layers of protection between the users and the repository: users can accidentally (or intentionally) corrupt the repository database, it becomes hard to take the repository offline for inspection or upgrade, and it can lead to a mess of file-permissions problems (see <xref linkend=\"svn.serverconfig.multimethod\"/>.) Note that this is also one of the reasons we warn against accessing repositories via <literal moreinfo=\"none\">svn+ssh://</literal> URLs — from a security standpoint, it's effectively the same as local users accessing via <literal moreinfo=\"none\">file://</literal>, and can entail all the same problems if the administrator isn't careful."
msgstr ""

#: build/en/book.xml:13017(title)
msgid "svnserve, a custom server"
msgstr "svnserve，一个自定义的服务器"

#: build/en/book.xml:13019(para)
msgid "The <command moreinfo=\"none\">svnserve</command> program is a lightweight server, capable of speaking to clients over TCP/IP using a custom, stateful protocol. Clients contact an <command moreinfo=\"none\">svnserve</command> server by using URLs that begin with the <literal moreinfo=\"none\">svn://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> schema. This section will explain the different ways of running <command moreinfo=\"none\">svnserve</command>, how clients authenticate themselves to the server, and how to configure appropriate access control to your repositories."
msgstr "<command moreinfo=\"none\">svnserve</command>是一个轻型的服务器，可以同客户端通过在TCP/IP基础上的自定义有状态协议通讯，客户端通过使用开头为<literal moreinfo=\"none\">svn://</literal>或者<literal moreinfo=\"none\">svn+ssh://</literal><command moreinfo=\"none\">svnserve</command>的URL来访问一个<command moreinfo=\"none\">svnserve</command>服务器。这一小节将会解释运行<command moreinfo=\"none\">svnserve</command>的不同方式，客户端怎样实现服务器的认证，怎样配置版本库恰当的访问控制。"

#: build/en/book.xml:13031(title)
msgid "Invoking the Server"
msgstr "调用服务器"

#: build/en/book.xml:13033(para)
#, fuzzy
msgid "There are a few different ways to run the <command moreinfo=\"none\">svnserve</command> program:"
msgstr "这是使用<command moreinfo=\"none\">svn revert</command>的好机会。"

#: build/en/book.xml:13037(para)
#, fuzzy
msgid "Run <command moreinfo=\"none\">svnserve</command> as a standalone daemon, listening for requests."
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:13040(para)
#, fuzzy
msgid "Have the Unix <command moreinfo=\"none\">inetd</command> daemon temporarily spawn <command moreinfo=\"none\">svnserve</command> whenever a request comes in on a certain port."
msgstr "像<command moreinfo=\"none\">svnserve</command>，<command moreinfo=\"none\">svnversion</command>没有子命令，只有选项。"

#: build/en/book.xml:13043(para)
#, fuzzy
msgid "Have SSH invoke a temporary <command moreinfo=\"none\">svnserve</command> over an encrypted tunnel."
msgstr "如果一个客户端连接到<command moreinfo=\"none\">svnserve</command>进程，如下事情会发生："

#: build/en/book.xml:13046(para)
#, fuzzy
msgid "Run <command moreinfo=\"none\">svnserve</command> as a Windows service."
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13052(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> as Daemon"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13054(para)
#, fuzzy
msgid "The easiest option is to run <command moreinfo=\"none\">svnserve</command> as a standalone <quote>daemon</quote> process. Use the <option>-d</option> option for this:"
msgstr "<command moreinfo=\"none\">svnserve</command>的第二个选项是作为独立<quote>守护</quote>进程，为此要使用<option>-d</option>选项："

#: build/en/book.xml:13058(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -d\n"
"$               # svnserve is now running, listening on port 3690\n"
msgstr ""
"\n"
"$ svnserve -d\n"
"$               # svnserve is now running, listening on port 3690\n"

#: build/en/book.xml:13063(para)
msgid "When running <command moreinfo=\"none\">svnserve</command> in daemon mode, you can use the <option>--listen-port=</option> and <option>--listen-host=</option> options to customize the exact port and hostname to <quote>bind</quote> to."
msgstr "当以守护模式运行<command moreinfo=\"none\">svnserve</command>时，你可以使用<option>--listen-port=</option>和<option>--listen-host=</option>选项来自定义<quote>绑定</quote>的端口和主机名。"

#: build/en/book.xml:13068(para)
#, fuzzy
msgid "Once the <command moreinfo=\"none\">svnserve</command> program is running, it makes every repository on your system available to the network. A client needs to specify an <emphasis>absolute</emphasis> path in the repository URL. For example, if a repository is located at <filename moreinfo=\"none\">/usr/local/repositories/project1</filename>, then a client would reach it via <uri>svn://host.example.com/usr/local/repositories/project1</uri>. To increase security, you can pass the <option>-r</option> option to <command moreinfo=\"none\">svnserve</command>, which restricts it to exporting only repositories below that path. For example:"
msgstr "一旦<command moreinfo=\"none\">svnserve</command>已经运行，它会将你系统中所有版本库发布到网络，一个客户端需要指定版本库在URL中的<emphasis>绝对</emphasis>路径，举个例子，如果一个版本库是位于<filename moreinfo=\"none\">/usr/local/repositories/project1</filename>，则一个客户端可以使用<systemitem class=\"url\" moreinfo=\"none\">svn://host.example.com/usr/local/repositories/project1 </systemitem>来进行访问，为了提高安全性，你可以使用<command moreinfo=\"none\">svnserve</command>的<option>-r</option>选项，这样会限制只输出指定路径下的版本库："

#: build/en/book.xml:13080(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -d -r /usr/local/repositories\n"
"…\n"
msgstr ""
"\n"
"$ svnserve -d -r /usr/local/repositories\n"
"…\n"

#: build/en/book.xml:13085(para)
msgid "Using the <option>-r</option> option effectively modifies the location that the program treats as the root of the remote filesystem space. Clients then use URLs that have that path portion removed from them, leaving much shorter (and much less revealing) URLs:"
msgstr "使用<option>-r</option>可以有效地改变文件系统的根位置，客户端可以使用去掉前半部分的路径，留下的要短一些的（更加有提示性）URL："

#: build/en/book.xml:1309(title)
msgid "The Copy-Modify-Merge Solution"
msgstr "拷贝-修改-合并 方案1"

#: build/en/book.xml:13091(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout svn://host.example.com/project1\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout svn://host.example.com/project1\n"
"…\n"

#: build/en/book.xml:13100(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> via <command moreinfo=\"none\">inetd</command>"
msgstr "像<command moreinfo=\"none\">svnserve</command>，<command moreinfo=\"none\">svnversion</command>没有子命令，只有选项。"

#: build/en/book.xml:13102(para)
#, fuzzy
msgid "If you want <command moreinfo=\"none\">inetd</command> launch the process, then you can pass the <option>-i</option> (<option>--inetd</option>) option:"
msgstr "还有一个<command moreinfo=\"none\">proplist</command>变种命令会列出所有属性的名称和值，只需要设置<option>--verbose</option>（<option>-v</option>）选项。"

#: build/en/book.xml:13106(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -i\n"
"( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"
msgstr ""
"\n"
"$ svnserve -i\n"
"( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"

#: build/en/book.xml:1311(para)
#, fuzzy
msgid "Subversion, CVS, and a number of other version control systems use a <firstterm>copy-modify-merge</firstterm> model as an alternative to locking. In this model, each user's client contacts the project repository and creates a personal <firstterm>working copy</firstterm>—a local reflection of the repository's files and directories. Users then work simultaneously and independently, modifying their private copies. Finally, the private copies are merged together into a new, final version. The version control system often assists with the merging, but ultimately a human being is responsible for making it happen correctly."
msgstr "Subversion，CVS和一些版本控制系统使用<firstterm>拷贝-修改-合并</firstterm>模型，在这种模型里，每一个客户联系项目版本库建立一个个人<firstterm>工作拷贝</firstterm>—版本库中文件和目录的本地映射。用户并行工作，修改各自的工作拷贝，最终，各个私有的拷贝合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。"

#: build/en/book.xml:13111(para)
msgid "When invoked with the <option>--inetd</option> option, <command moreinfo=\"none\">svnserve</command> attempts to speak with a Subversion client via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis> using a custom protocol. This is the standard behavior for a program being run via <command moreinfo=\"none\">inetd</command>. The IANA has reserved port 3690 for the Subversion protocol, so on a Unix-like system you can add lines to <filename moreinfo=\"none\">/etc/services</filename> like these (if they don't already exist):"
msgstr "当用参数<option>--inetd</option>调用时，<command moreinfo=\"none\">svnserve</command>会尝试使用自定义协议通过<emphasis>stdin</emphasis>和<emphasis>stdout</emphasis>来与Subversion客户端通话，这是使用<command moreinfo=\"none\">inetd</command>工作的标准方式，IANA为Subversion协议保留3690端口，所以在类Unix系统你可以在<filename moreinfo=\"none\">/etc/services</filename>添加如下的几行（如果他们还不存在）："

#: build/en/book.xml:13121(screen)
#, no-wrap
msgid ""
"\n"
"svn           3690/tcp   # Subversion\n"
"svn           3690/udp   # Subversion\n"
msgstr ""
"\n"
"svn           3690/tcp   # Subversion\n"
"svn           3690/udp   # Subversion\n"

#: build/en/book.xml:13126(para)
msgid "And if your system is using a classic Unix-like <command moreinfo=\"none\">inetd</command> daemon, you can add this line to <filename moreinfo=\"none\">/etc/inetd.conf</filename>:"
msgstr "如果系统是使用经典的类Unix的<command moreinfo=\"none\">inetd</command>守护进程，你可以在<filename moreinfo=\"none\">/etc/inetd.conf</filename>添加这几行："

#: build/en/book.xml:13130(screen)
#, no-wrap
msgid ""
"\n"
"svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"
msgstr ""
"\n"
"svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"

#: build/en/book.xml:13134(para)
#, fuzzy
msgid "Make sure <quote>svnowner</quote> is a user which has appropriate permissions to access your repositories. Now, when a client connection comes into your server on port 3690, <command moreinfo=\"none\">inetd</command> will spawn an <command moreinfo=\"none\">svnserve</command> process to service it. Of course, you may also want to add <option>-r</option> to the configuration line as well, to restrict which repositories are exported."
msgstr "确定<quote>svnowner</quote>用户拥有访问版本库的适当权限，现在如果一个客户连接来到你的服务器的端口3690，<command moreinfo=\"none\">inetd</command>会产生一个<command moreinfo=\"none\">svnserve</command>进程来做服务。"

#: build/en/book.xml:13147(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> over a Tunnel"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13149(para)
#, fuzzy
msgid "A third way to invoke <command moreinfo=\"none\">svnserve</command> is in <quote>tunnel mode</quote>, with the <option>-t</option> option. This mode assumes that a remote-service program such as <command moreinfo=\"none\">RSH</command> or <command moreinfo=\"none\">SSH</command> has successfully authenticated a user and is now invoking a private <command moreinfo=\"none\">svnserve</command> process <emphasis>as that user</emphasis>. The <command moreinfo=\"none\">svnserve</command> program behaves normally (communicating via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis>), and assumes that the traffic is being automatically redirected over some sort of tunnel back to the client. When <command moreinfo=\"none\">svnserve</command> is invoked by a tunnel agent like this, be sure that the authenticated user has full read and write access to the repository database files. It's essentially the same as a local user accessing the repository via <literal moreinfo=\"none\">file://</literal> URLs."
msgstr "也一直有第三种方式，使用<option>-t</option>选项的<quote>管道模式</quote>，这个模式假定一个分布式服务程序如<command moreinfo=\"none\">RSH</command>或<command moreinfo=\"none\">SSH</command>已经验证了一个用户，并且<emphasis>以这个用户</emphasis>调用了一个私有<command moreinfo=\"none\">svnserve</command>进程，<command moreinfo=\"none\">svnserve</command>运作如常（通过<emphasis>stdin</emphasis>和<emphasis>stdout</emphasis>通讯），并且可以设想通讯是自动转向到一种通道传递回客户端，当<command moreinfo=\"none\">svnserve</command>被这样的通道代理调用，确定认证用户对版本数据库有完全的读写权限，（见<xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>。）这与本地用户通过<literal moreinfo=\"none\">file:///</literal>URl访问版本库同样重要。"

#: build/en/book.xml:13166(para)
msgid "This option is described in much more detail in <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr ""

#: build/en/book.xml:13173(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> as Windows Service"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13175(para)
msgid "If your Windows system is a descendant of Windows NT (2000, 2003, XP, Vista), then you can run <command moreinfo=\"none\">svnserve</command> as a standard Windows service. This is typically a much nicer experience than running it as a standalone daemon with the <option>--daemon (-d)</option> option. Using daemon-mode requires launching a console, typing a command, and then leaving the console window running indefinitely. A Windows service, however, runs in the background, can start at boot time automatically, and can be started and stopped using the same consistent administration interface as other Windows services."
msgstr ""

#: build/en/book.xml:13188(para)
msgid "You'll need to define the new service using the command-line tool <command moreinfo=\"none\">SC.EXE</command>. Much like the <command moreinfo=\"none\">inetd</command> configuration line, you must specify an exact invocation of <command moreinfo=\"none\">svnserve</command> for Windows to run at start-up time:"
msgstr ""

#: build/en/book.xml:13194(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"C:\\svn\\bin\\svnserve.exe --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"
msgstr ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"C:\\svn\\bin\\svnserve.exe --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"

#: build/en/book.xml:13202(para)
msgid "This defines a new Windows service named <quote>svn</quote>, and which executes a particular <command moreinfo=\"none\">svnserve.exe</command> command when started (in this case, rooted at <filename moreinfo=\"none\">C:\\repos</filename>.) There are a number of caveats in the prior example, however."
msgstr ""

#: build/en/book.xml:13209(para)
msgid "First, notice that the <command moreinfo=\"none\">svnserve.exe</command> program must always be invoked with the <option>--service</option> option. Any other options to <command moreinfo=\"none\">svnserve</command> must then be specified on the same line, but you cannot add conflicting options such as <option>--daemon (-d)</option>, <option>--tunnel</option>, or <option>--inetd (-i)</option>. Options such as <option>-r</option> or <option>--listen-port</option> are fine, though. Second, be careful about spaces when invoking the <command moreinfo=\"none\">SC.EXE</command> command: the <literal moreinfo=\"none\">key= value</literal> patterns must have no spaces between <literal moreinfo=\"none\">key=</literal> and exactly one space before the <literal moreinfo=\"none\">value</literal>. Lastly, be careful about spaces in your command-line to be invoked. If a directory name contains spaces (or other characters that need escaping), place the entire inner value of <literal moreinfo=\"none\">binpath</literal> in double-quotes, by escaping them:"
msgstr ""

#: build/en/book.xml:13229(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"\\\"C:\\program files\\svn\\bin\\svnserve.exe\\\" --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"
msgstr ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"\\\"C:\\program files\\svn\\bin\\svnserve.exe\\\" --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"

#: build/en/book.xml:1323(para)
msgid "Here's an example. Say that Harry and Sally each create working copies of the same project, copied from the repository. They work concurrently, and make changes to the same file A within their copies. Sally saves her changes to the repository first. When Harry attempts to save his changes later, the repository informs him that his file A is <firstterm>out-of-date</firstterm>. In other words, that file A in the repository has somehow changed since he last copied it. So Harry asks his client to <firstterm>merge</firstterm> any new changes from the repository into his working copy of file A. Chances are that Sally's changes don't overlap with his own; so once he has both sets of changes integrated, he saves his working copy back to the repository. <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/> and <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/> show this process."
msgstr "这是一个例子，Harry和Sally为同一个项目各自建立了一个工作拷贝，工作是并行的，修改了同一个文件A，Sally首先保存修改到版本库，当Harry想去提交修改的时候，版本库提示文件A已经<firstterm>过期</firstterm>，换句话说，A在他上次更新之后已经更改了，所以当他通过客户端请求<firstterm>合并</firstterm>版本库和他的工作拷贝之后，碰巧Sally的修改和他的不冲突，所以一旦他把所有的修改集成到一起，他可以将工作拷贝保存到版本库，<xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/>和<xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/>展示了这一过程。"

#: build/en/book.xml:13237(para)
msgid "Once the service is defined, it can stopped, started, or queried using standard GUI tools (The Services administrative control panel), or at the command line as well:"
msgstr ""

#: build/en/book.xml:13242(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; net stop svn\n"
"C:\\&gt; net start svn\n"
msgstr ""
"\n"
"C:\\&gt; net stop svn\n"
"C:\\&gt; net start svn\n"

#: build/en/book.xml:13247(para)
msgid "The service can also be uninstalled (i.e. undefined) by deleting its definition: <literal moreinfo=\"none\">sc delete svn</literal>. Just be sure to stop the service first! The <command moreinfo=\"none\">SC.EXE</command> program has many other subcommands and options, run <literal moreinfo=\"none\">sc /?</literal> to learn more about it."
msgstr ""

#: build/en/book.xml:13260(title)
msgid "Built-in authentication and authorization"
msgstr "内置的认证和授权"

#: build/en/book.xml:13262(para)
msgid "When a client connects to an <command moreinfo=\"none\">svnserve</command> process, the following things happen:"
msgstr "如果一个客户端连接到<command moreinfo=\"none\">svnserve</command>进程，如下事情会发生："

#: build/en/book.xml:13266(para)
msgid "The client selects a specific repository."
msgstr "客户端选择特定的版本库。"

#: build/en/book.xml:13269(para)
msgid "The server processes the repository's <filename moreinfo=\"none\">conf/svnserve.conf</filename> file, and begins to enforce any authentication and authorization policies defined therein."
msgstr "服务器处理版本库的<filename moreinfo=\"none\">conf/svnserve.conf</filename>文件，并且执行里面定义的所有认证和授权政策。"

#: build/en/book.xml:13274(para)
msgid "Depending on the situation and authorization policies,"
msgstr "依赖于位置和授权政策，"

#: build/en/book.xml:13278(para)
msgid "the client may be allowed to make requests anonymously, without ever receiving an authentication challenge, OR"
msgstr "如果没有收到认证请求，客户端可能被允许匿名访问，或者"

#: build/en/book.xml:13282(para)
msgid "the client may be challenged for authentication at any time, OR"
msgstr "客户端收到认证请求，或者"

#: build/en/book.xml:13285(para)
msgid "if operating in <quote>tunnel mode</quote>, the client will declare itself to be already externally authenticated."
msgstr "如果操作在<quote>通道模式</quote>，客户端会宣布自己已经在外部得到认证。"

#: build/en/book.xml:13293(para)
#, fuzzy
msgid "At the time of writing, the server only knows how to send a CRAM-MD5 <placeholder-1/> authentication challenge. In essence, the server sends a small amount of data to the client. The client uses the MD5 hash algorithm to create a fingerprint of the data and password combined, then sends the fingerprint as a response. The server performs the same computation with the stored password to verify that the result is identical. <emphasis>At no point does the actual password travel over the network.</emphasis>"
msgstr "在撰写本文时，服务器还只知道怎样发送CRAM-MD5<placeholder-1/>认证请求，本质上讲，就是服务器发送一些数据到客户端，客户端使用MD5哈希算法创建这些数据组合密码的指纹，然后返回指纹，服务器执行同样的计算并且来计算结果的一致性，<emphasis>真正的密码并没有在互联网上传递。</emphasis>"

#: build/en/book.xml:13294(para)
msgid "See RFC 2195."
msgstr "见RFC 2195。"

#: build/en/book.xml:13304(para)
msgid "It's also possible, of course, for the client to be externally authenticated via a tunnel agent, such as <command moreinfo=\"none\">SSH</command>. In that case, the server simply examines the user it's running as, and uses it as the authenticated username. For more on this, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr "当然也有可能，如果客户端在外部通过通道代理认证，如<command moreinfo=\"none\">SSH</command>，在那种情况下，服务器简单的检验作为那个用户的运行，然后使用它作为认证用户名，更多信息请看<xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>。"

#: build/en/book.xml:13310(para)
msgid "As you've already guessed, a repository's <filename moreinfo=\"none\">svnserve.conf</filename> file is the central mechanism for controlling authentication and authorization policies. The file has the same format as other configuration files (see <xref linkend=\"svn.advanced.confarea\"/>): section names are marked by square brackets (<literal moreinfo=\"none\">[</literal> and <literal moreinfo=\"none\">]</literal>), comments begin with hashes (<literal moreinfo=\"none\">#</literal>), and each section contains specific variables that can be set (<literal moreinfo=\"none\">variable = value</literal>). Let's walk through this file and learn how to use them."
msgstr "像你已经猜测到的，版本库的<filename moreinfo=\"none\">svnserve.conf</filename>文件是控制认证和授权政策的中央机构，这文件与其它配置文件格式相同（见<xref linkend=\"svn.advanced.confarea\"/>）：小节名称使用方括号标记（<literal moreinfo=\"none\">[</literal>和<literal moreinfo=\"none\">]</literal>），注释以井号（<literal moreinfo=\"none\">#</literal>）开始，每一小节都有一些参数可以设置（<literal moreinfo=\"none\">variable = value</literal>），让我们浏览这个文件并且学习怎样使用它们。"

#: build/en/book.xml:13324(title)
msgid "Create a 'users' file and realm"
msgstr "创建一个用户文件和域"

#: build/en/book.xml:13326(para)
msgid "For now, the <literal moreinfo=\"none\">[general]</literal> section of the <filename moreinfo=\"none\">svnserve.conf</filename> has all the variables you need. Begin by defining a file which contains usernames and passwords, and an authentication realm:"
msgstr "此时，<filename moreinfo=\"none\">svnserve.conf</filename>文件的<literal moreinfo=\"none\">[general]</literal>部分包括所有你需要的变量，开始先定义一个保存用户名和密码的文件和一个认证域："

#: build/en/book.xml:13331(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"

#: build/en/book.xml:13337(para)
msgid "The <literal moreinfo=\"none\">realm</literal> is a name that you define. It tells clients which sort of <quote>authentication namespace</quote> they're connecting to; the Subversion client displays it in the authentication prompt, and uses it as a key (along with the server's hostname and port) for caching credentials on disk (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The <literal moreinfo=\"none\">password-db</literal> variable points to a separate file that contains a list of usernames and passwords, using the same familiar format. For example:"
msgstr "<literal moreinfo=\"none\">realm</literal>是你定义的名称，这告诉客户端连接的<quote>认证命名空间</quote>，Subversion会在认证提示里显示，并且作为凭证缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。）的关键字（还有服务器的主机名和端口），<literal moreinfo=\"none\">password-db</literal>参数指出了保存用户和密码列表文件，这个文件使用同样熟悉的格式，举个例子："

#: build/en/book.xml:13347(screen)
#, no-wrap
msgid ""
"\n"
"[users]\n"
"harry = foopassword\n"
"sally = barpassword\n"
msgstr ""
"\n"
"[users]\n"
"harry = foopassword\n"
"sally = barpassword\n"

#: build/en/book.xml:13353(para)
msgid "The value of <literal moreinfo=\"none\">password-db</literal> can be an absolute or relative path to the users file. For many admins, it's easy to keep the file right in the <filename moreinfo=\"none\">conf/</filename> area of the repository, alongside <filename moreinfo=\"none\">svnserve.conf</filename>. On the other hand, it's possible you may want to have two or more repositories share the same users file; in that case, the file should probably live in a more public place. The repositories sharing the users file should also be configured to have the same realm, since the list of users essentially defines an authentication realm. Wherever the file lives, be sure to set the file's read and write permissions appropriately. If you know which user(s) <command moreinfo=\"none\">svnserve</command> will run as, restrict read access to the user file as necessary."
msgstr "<literal moreinfo=\"none\">password-db</literal>的值可以是用户文件的绝对或相对路径，对许多管理员来说，把文件保存在版本库<filename moreinfo=\"none\">conf/</filename>下的<filename moreinfo=\"none\">svnserve.conf</filename>旁边是一个简单的方法。另一方面，可能你的多个版本库使用同一个用户文件，此时，这个文件应该在更公开的地方，版本库分享用户文件时必须配置为相同的域，因为用户列表本质上定义了一个认证域，无论这个文件在哪里，必须设置好文件的读写权限，如果你知道运行<command moreinfo=\"none\">svnserve</command>的用户，限定这个用户对这个文件有读权限是必须的。"

#: build/en/book.xml:13372(title)
msgid "Set access controls"
msgstr "设置访问控制"

#: build/en/book.xml:13374(para)
msgid "There are two more variables to set in the <filename moreinfo=\"none\">svnserve.conf</filename> file: they determine what unauthenticated (anonymous) and authenticated users are allowed to do. The variables <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> can be set to the values <literal moreinfo=\"none\">none</literal>, <literal moreinfo=\"none\">read</literal>, or <literal moreinfo=\"none\">write</literal>. Setting the value to <literal moreinfo=\"none\">none</literal> restricts all access of any kind; <literal moreinfo=\"none\">read</literal> allows read-only access to the repository, and <literal moreinfo=\"none\">write</literal> allows complete read/write access to the repository. For example:"
msgstr "<filename moreinfo=\"none\">svnserve.conf</filename>有两个或多个参数需要设置：它们确定未认证（匿名）和认证用户可以做的事情，参数<literal moreinfo=\"none\">anon-access</literal>和<literal moreinfo=\"none\">auth-access</literal>可以设置为<literal moreinfo=\"none\">none</literal>、<literal moreinfo=\"none\">read</literal>或者<literal moreinfo=\"none\">write</literal>，设置为<literal moreinfo=\"none\">none</literal>会限制所有方式的访问，<literal moreinfo=\"none\">read</literal>允许只读访问，而<literal moreinfo=\"none\">write</literal>允许对版本库完全的读/写权限："

#: build/en/book.xml:13386(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users can only read the repository\n"
"anon-access = read\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users can only read the repository\n"
"anon-access = read\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"

#: build/en/book.xml:1339(title)
msgid "The copy-modify-merge solution"
msgstr "拷贝-修改-合并 方案"

#: build/en/book.xml:13398(para)
msgid "The example settings are, in fact, the default values of the variables, should you forget to define them. If you want to be even more conservative, you can block anonymous access completely:"
msgstr "实例中的设置实际上是参数的缺省值，你一定不要忘了设置它们，如果你希望更保守一点，你可以完全封锁匿名访问："

#: build/en/book.xml:13403(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users aren't allowed\n"
"anon-access = none\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users aren't allowed\n"
"anon-access = none\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"

#: build/en/book.xml:13415(para)
msgid "The server process not only understands these <quote>blanket</quote> access controls to the repository, but also finer-grained access restrictions placed on specific files and directories within the repository. To make use of this feature, you need to define a file containing more detailed rules, and then set the <literal moreinfo=\"none\">authz-db</literal> variable to point to it:"
msgstr ""

#: build/en/book.xml:13423(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# Specific access rules for specific locations\n"
"authz-db = authzfile\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# Specific access rules for specific locations\n"
"authz-db = authzfile\n"

#: build/en/book.xml:13432(para)
msgid "The syntax of the <filename moreinfo=\"none\">authzfile</filename> file is discussed in detail in <xref linkend=\"svn.serverconfig.pathbasedauthz\"/>. Note that the <literal moreinfo=\"none\">authz-db</literal> variable isn't mutually exclusive with the <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> variables; if all the variables are defined at once, then <emphasis>all</emphasis> of the rules must be satisfied before access is allowed."
msgstr ""

#: build/en/book.xml:1344(title)
msgid "The copy-modify-merge solution (continued)"
msgstr "拷贝-修改-合并 方案（续）"

#: build/en/book.xml:13446(title)
msgid "Tunneling over SSH"
msgstr ""

#: build/en/book.xml:13448(para)
msgid "<command moreinfo=\"none\">svnserve</command>'s built-in authentication can be very handy, because it avoids the need to create real system accounts. On the other hand, some administrators already have well-established SSH authentication frameworks in place. In these situations, all of the project's users already have system accounts and the ability to <quote>SSH into</quote> the server machine."
msgstr "<command moreinfo=\"none\">svnserve</command>的内置认证会非常容易得到，因为它避免了创建真实的系统帐号，另一方面，一些管理员已经创建好了SSH认证框架，在这种情况下，所有的项目用户已经拥有了系统帐号和有能力<quote>SSH到</quote>服务器。"

#: build/en/book.xml:13456(para)
msgid "It's easy to use SSH in conjunction with <command moreinfo=\"none\">svnserve</command>. The client simply uses the <literal moreinfo=\"none\">svn+ssh://</literal> URL schema to connect:"
msgstr "SSH与<command moreinfo=\"none\">svnserve</command>结合很简单，客户端只需要使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL模式来连接："

#: build/en/book.xml:13460(screen)
#, no-wrap
msgid ""
"\n"
"$ whoami\n"
"harry\n"
"\n"
"$ svn list svn+ssh://host.example.com/repos/project\n"
"harry@host.example.com's password:  *****\n"
"\n"
"foo\n"
"bar\n"
"baz\n"
"…\n"
msgstr ""
"\n"
"$ whoami\n"
"harry\n"
"\n"
"$ svn list svn+ssh://host.example.com/repos/project\n"
"harry@host.example.com's password:  *****\n"
"\n"
"foo\n"
"bar\n"
"baz\n"
"…\n"

#: build/en/book.xml:13473(para)
msgid "In this example, the Subversion client is invoking a local <command moreinfo=\"none\">ssh</command> process, connecting to <literal moreinfo=\"none\">host.example.com</literal>, authenticating as the user <literal moreinfo=\"none\">harry</literal>, then spawning a private <command moreinfo=\"none\">svnserve</command> process on the remote machine running as the user <literal moreinfo=\"none\">harry</literal>. The <command moreinfo=\"none\">svnserve</command> command is being invoked in tunnel mode (<option>-t</option>) and its network protocol is being <quote>tunneled</quote> over the encrypted connection by <command moreinfo=\"none\">ssh</command>, the tunnel-agent. <command moreinfo=\"none\">svnserve</command> is aware that it's running as the user <literal moreinfo=\"none\">harry</literal>, and if the client performs a commit, the authenticated username will be attributed as the author of the new revision."
msgstr "在这个例子里，Subversion客户端会调用一个<command moreinfo=\"none\">ssh</command>进程，连接到<literal moreinfo=\"none\">host.example.com</literal>，使用用户<literal moreinfo=\"none\">harry</literal>认证，然后会有一个<command moreinfo=\"none\">svnserve</command>私有进程以用户<literal moreinfo=\"none\">harry</literal>运行。<command moreinfo=\"none\">svnserve</command>是以管道模式调用的（<option>-t</option>），它的网络协议是通过<command moreinfo=\"none\">ssh</command><quote>封装的</quote>，被管道代理的<command moreinfo=\"none\">svnserve</command>会知道程序是以用户<literal moreinfo=\"none\">harry</literal>运行的，如果客户执行一个提交，认证的用户名会作为版本的参数保存到新的修订本。"

#: build/en/book.xml:1348(para)
msgid "But what if Sally's changes <emphasis>do</emphasis> overlap with Harry's changes? What then? This situation is called a <firstterm>conflict</firstterm>, and it's usually not much of a problem. When Harry asks his client to merge the latest repository changes into his working copy, his copy of file A is somehow flagged as being in a state of conflict: he'll be able to see both sets of conflicting changes, and manually choose between them. Note that software can't automatically resolve conflicts; only humans are capable of understanding and making the necessary intelligent choices. Once Harry has manually resolved the overlapping changes—perhaps after a discussion with Sally—he can safely save the merged file back to the repository."
msgstr "但是如果Sally和Harry的修改<emphasis>交迭</emphasis>了该怎么办？这种情况叫做<firstterm>冲突</firstterm>，这通常不是个大问题，当Harry告诉他的客户端去合并版本库的最新修改到自己的工作拷贝时，他的文件A就会处于冲突状态：他可以看到一对冲突的修改集，并手工的选择保留一组修改。需要注意的是软件不能自动的解决冲突，只有人可以理解并作出智能的选择，一旦Harry手工的解决了冲突—也许需要与Sally讨论—它可以安全的把合并的文件保存到版本库。"

#: build/en/book.xml:13488(para)
msgid "The important thing to understand here is that the Subversion client is <emphasis>not</emphasis> connecting to a running <command moreinfo=\"none\">svnserve</command> daemon. This method of access doesn't require a daemon, nor does it notice one if present. It relies wholly on the ability of <command moreinfo=\"none\">ssh</command> to spawn a temporary <command moreinfo=\"none\">svnserve</command> process, which then terminates when the network connection is closed."
msgstr "这里要理解的最重要的事情是Subversion客户端<emphasis>不</emphasis>是连接到运行中的<command moreinfo=\"none\">svnserve</command>守护进程，这种访问方法不需要一个运行的守护进程，也不需要在必要时唤醒一个，它依赖于<command moreinfo=\"none\">ssh</command>来发起一个<command moreinfo=\"none\">svnserve</command>进程，然后网络断开后终止进程。"

#: build/en/book.xml:13497(para)
msgid "When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs to access a repository, remember that it's the <command moreinfo=\"none\">ssh</command> program prompting for authentication, and <emphasis>not</emphasis> the <command moreinfo=\"none\">svn</command> client program. That means there's no automatic password caching going on (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The Subversion client often makes multiple connections to the repository, though users don't normally notice this due to the password caching feature. When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs, however, users may be annoyed by <command moreinfo=\"none\">ssh</command> repeatedly asking for a password for every outbound connection. The solution is to use a separate SSH password-caching tool like <command moreinfo=\"none\">ssh-agent</command> on a Unix-like system, or <command moreinfo=\"none\">pageant</command> on Windows."
msgstr "当使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL访问版本库时，记住是<command moreinfo=\"none\">ssh</command>提示请求认证，而<emphasis>不</emphasis>是<command moreinfo=\"none\">svn</command>客户端程序。这意味着密码不会有自动缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>），Subversion客户端通常会建立多个版本库的连接，但用户通常会因为密码缓存特性而没有注意到这一点，当使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL时，用户会为<command moreinfo=\"none\">ssh</command>在每次建立连接时重复的询问密码感到讨厌，解决方案是用一个独立的SSH密码缓存工具，像类Unix系统的<command moreinfo=\"none\">ssh-agent</command>或者是Windows下的<command moreinfo=\"none\">pageant</command>。"

#: build/en/book.xml:13513(para)
#, fuzzy
msgid "When running over a tunnel, authorization is primarily controlled by operating system permissions to the repository's database files; it's very much the same as if Harry were accessing the repository directly via a <literal moreinfo=\"none\">file://</literal> URL. If multiple system users are going to be accessing the repository directly, you may want to place them into a common group, and you'll need to be careful about umasks. (Be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>.) But even in the case of tunneling, the <filename moreinfo=\"none\">svnserve.conf</filename> file can still be used to block access, by simply setting <literal moreinfo=\"none\">auth-access = read</literal> or <literal moreinfo=\"none\">auth-access = none</literal>. <placeholder-1/>"
msgstr "当在一个管道上运行时，认证通常是基于操作系统对版本库数据库文件的访问控制，这同Harry直接通过<literal moreinfo=\"none\">file:///</literal>的URL直接访问版本库非常类似，如果有多个系统用户要直接访问版本库，你会希望将他们放到一个常见的组里，你应该小心的使用umasks。（确定要阅读<xref linkend=\"svn.serverconfig.multimethod\"/>）但是即使是在管道模式时，文件<filename moreinfo=\"none\">svnserve.conf</filename>还是可以阻止用户访问，如<literal moreinfo=\"none\">auth-access = read</literal>或者<literal moreinfo=\"none\">auth-access = none</literal>。"

#: build/en/book.xml:13526(para)
#, fuzzy
msgid "Note that using any sort of <command moreinfo=\"none\">svnserve</command>-enforced access control at all is a bit pointless; the user already has direct access to the repository database."
msgstr "常规的系统用户连接使用SSH调用的访问版本库的<command moreinfo=\"none\">svnserve</command>进程（以它们自己运行）；"

#: build/en/book.xml:13533(para)
msgid "You'd think that the story of SSH tunneling would end here, but it doesn't. Subversion allows you to create custom tunnel behaviors in your run-time <filename moreinfo=\"none\">config</filename> file (see <xref linkend=\"svn.advanced.confarea\"/>). For example, suppose you want to use RSH instead of SSH. In the <literal moreinfo=\"none\">[tunnels]</literal> section of your <filename moreinfo=\"none\">config</filename> file, simply define it like this:"
msgstr "你会认为SSH管道的故事该结束了，但还不是，Subversion允许你在运行配置文件<filename moreinfo=\"none\">config</filename>（见<xref linkend=\"svn.advanced.confarea\"/>）创建一个自定义的管道行为方式，举个例子，假定你希望使用RSH而不是SSH，在<filename moreinfo=\"none\">config</filename>文件的<literal moreinfo=\"none\">[tunnels]</literal>部分作如下定义："

#: build/en/book.xml:13542(screen)
#, no-wrap
msgid ""
"\n"
"[tunnels]\n"
"rsh = rsh\n"
msgstr ""
"\n"
"[tunnels]\n"
"rsh = rsh\n"

#: build/en/book.xml:13547(para)
msgid "And now, you can use this new tunnel definition by using a URL schema that matches the name of your new variable: <literal moreinfo=\"none\">svn+rsh://host/path</literal>. When using the new URL schema, the Subversion client will actually be running the command <command moreinfo=\"none\">rsh host svnserve -t</command> behind the scenes. If you include a username in the URL (for example, <literal moreinfo=\"none\">svn+rsh://username@host/path</literal>) the client will also include that in its command (<command moreinfo=\"none\">rsh username@host svnserve -t</command>). But you can define new tunneling schemes to be much more clever than that:"
msgstr "现在你可以通过指定与定义匹配的URL模式来使用新的管道定义：<literal moreinfo=\"none\">svn+rsh://host/path</literal>。当使用新的URL模式时，Subversion客户端实际上会在后台运行<command moreinfo=\"none\">rsh host svnserve -t</command>这个命令，如果你在URL中包括一个用户名（例如，<literal moreinfo=\"none\">svn+rsh://username@host/path</literal>），客户端也会在自己的命令中包含这部分（<command moreinfo=\"none\">rsh username@host svnserve -t</command>），但是你可以定义比这个更加智能的新的管道模式："

#: build/en/book.xml:13558(screen)
#, no-wrap
msgid ""
"\n"
"[tunnels]\n"
"joessh = $JOESSH /opt/alternate/ssh -p 29934\n"
msgstr ""
"\n"
"[tunnels]\n"
"joessh = $JOESSH /opt/alternate/ssh -p 29934\n"

#: build/en/book.xml:13563(para)
msgid "This example demonstrates a couple of things. First, it shows how to make the Subversion client launch a very specific tunneling binary (the one located at <filename moreinfo=\"none\">/opt/alternate/ssh</filename>) with specific options. In this case, accessing a <literal moreinfo=\"none\">svn+joessh://</literal> URL would invoke the particular SSH binary with <option>-p 29934</option> as arguments—useful if you want the tunnel program to connect to a non-standard port."
msgstr "这个例子里论证了一些事情，首先，它展现了如何让Subversion客户端启动一个特定的管道程序（这个在<filename moreinfo=\"none\">/opt/alternate/ssh</filename>），在这个例子里，使用<literal moreinfo=\"none\">svn+joessh://</literal>的URL会以<option>-p 29934</option>参数调用特定的SSH程序—对连接到非标准端口的程序非常有用。"

#: build/en/book.xml:13573(para)
msgid "Second, it shows how to define a custom environment variable that can override the name of the tunneling program. Setting the <literal moreinfo=\"none\">SVN_SSH</literal> environment variable is a convenient way to override the default SSH tunnel agent. But if you need to have several different overrides for different servers, each perhaps contacting a different port or passing a different set of options to SSH, you can use the mechanism demonstrated in this example. Now if we were to set the <literal moreinfo=\"none\">JOESSH</literal> environment variable, its value would override the entire value of the tunnel variable—<command moreinfo=\"none\">$JOESSH</command> would be executed instead of <command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>."
msgstr "第二点，它展示了怎样定义一个自定义的环境变量来覆盖管道程序中的名字，设置<literal moreinfo=\"none\">SVN_SSH</literal>环境变量是覆盖缺省的SSH管道的一种简便方法，但是如果你需要为多个服务器做出多个不同的覆盖，或许每一个都联系不同的端口或传递不同的SSH选项，你可以使用本例论述的机制。现在如果我们设置<literal moreinfo=\"none\">JOESSH</literal>环境变量，它的值会覆盖管道中的变量值—会执行<command moreinfo=\"none\">$JOESSH</command>而不是<command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>。"

#: build/en/book.xml:13591(title)
msgid "SSH configuration tricks"
msgstr "SSH配置技巧"

#: build/en/book.xml:13593(para)
msgid "It's not only possible to control the way in which the client invokes <command moreinfo=\"none\">ssh</command>, but also to control the behavior of <command moreinfo=\"none\">sshd</command> on your server machine. In this section, we'll show how to control the exact <command moreinfo=\"none\">svnserve</command> command executed by <command moreinfo=\"none\">sshd</command>, as well as how to have multiple users share a single system account."
msgstr "不仅仅是可以控制客户端调用<command moreinfo=\"none\">ssh</command>方式，也可以控制服务器中的<command moreinfo=\"none\">sshd</command>的行为方式，在本小节，我们会展示怎样控制<command moreinfo=\"none\">sshd</command>执行<command moreinfo=\"none\">svnserve</command>，包括如何让多个用户分享同一个系统帐户。"

#: build/en/book.xml:13605(para)
msgid "To begin, locate the home directory of the account you'll be using to launch <command moreinfo=\"none\">svnserve</command>. Make sure the account has an SSH public/private keypair installed, and that the user can log in via public-key authentication. Password authentication will not work, since all of the following SSH tricks revolve around using the SSH <filename moreinfo=\"none\">authorized_keys</filename> file."
msgstr "作为开始，定位到你启动<command moreinfo=\"none\">svnserve</command>的帐号的主目录，确定这个账户已经安装了一套SSH公开/私有密钥对，用户可以通过公开密钥认证，因为所有如下的技巧围绕着使用SSH<filename moreinfo=\"none\">authorized_keys</filename>文件，密码认证在这里不会工作。"

#: build/en/book.xml:13613(para)
msgid "If it doesn't already exist, create the <filename moreinfo=\"none\">authorized_keys</filename> file (on Unix, typically <filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>). Each line in this file describes a public key that is allowed to connect. The lines are typically of the form:"
msgstr "如果这个文件还不存在，创建一个<filename moreinfo=\"none\">authorized_keys</filename>文件（在UNIX下通常是<filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>），这个文件的每一行描述了一个允许连接的公钥，这些行通常是下面的形式："

#: build/en/book.xml:1362(para)
#, fuzzy
msgid "The copy-modify-merge model may sound a bit chaotic, but in practice, it runs extremely smoothly. Users can work in parallel, never waiting for one another. When they work on the same files, it turns out that most of their concurrent changes don't overlap at all; conflicts are infrequent. And the amount of time it takes to resolve conflicts is usually far less than the time lost by a locking system."
msgstr "拷贝-修改-合并模型感觉是有一点混乱，但在实践中，通常运行的很平稳，用户可以并行的工作，不必等待别人，当工作在同一个文件上时，也很少会有交迭发生，冲突并不频繁，处理冲突的时间远比等待解锁花费的时间少。"

#: build/en/book.xml:13620(screen)
#, no-wrap
msgid ""
"\n"
"  ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""
"\n"
"  ssh-dsa AAAABtce9euch.... user@example.com\n"

#: build/en/book.xml:13624(para)
msgid "The first field describes the type of key, the second field is the uuencoded key itself, and the third field is a comment. However, it's a lesser known fact that the entire line can be preceded by a <literal moreinfo=\"none\">command</literal> field:"
msgstr "第一个字段描述了密钥的类型，第二个字段是未加密的密钥本身，第三个字段是注释。然而，这是一个很少人知道的事实，可以使用一个<literal moreinfo=\"none\">command</literal>来处理整行："

#: build/en/book.xml:13630(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"program\" ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""
"\n"
"  command=\"program\" ssh-dsa AAAABtce9euch.... user@example.com\n"

#: build/en/book.xml:13634(para)
msgid "When the <literal moreinfo=\"none\">command</literal> field is set, the SSH daemon will run the named program instead of the typical <command moreinfo=\"none\">svnserve -t</command> invocation that the Subversion client asks for. This opens the door to a number of server-side tricks. In the following examples, we abbreviate the lines of the file as:"
msgstr "当<literal moreinfo=\"none\">command</literal>字段设置后，SSH守护进程运行命名的程序而不是通常Subversion客户端询问的<command moreinfo=\"none\">svnserve -t</command>。这为实施许多服务器端技巧开启了大门，在下面的例子里，我们简写了文件的这些行："

#: build/en/book.xml:13641(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"program\" TYPE KEY COMMENT\n"
msgstr ""
"\n"
"  command=\"program\" TYPE KEY COMMENT\n"

#: build/en/book.xml:13649(title)
msgid "Controlling the invoked command"
msgstr "控制调用的命令"

#: build/en/book.xml:13651(para)
msgid "Because we can specify the executed server-side command, it's easy to name a specific <command moreinfo=\"none\">svnserve</command> binary to run and to pass it extra arguments:"
msgstr "因为我们可以指定服务器端执行的命令，我们很容易来选择运行一个特定的<command moreinfo=\"none\">svnserve</command>程序来并且传递给它额外的参数："

#: build/en/book.xml:13655(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"
msgstr ""
"\n"
"  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"

#: build/en/book.xml:13659(para)
msgid "In this example, <filename moreinfo=\"none\">/path/to/svnserve</filename> might be a custom wrapper script around <command moreinfo=\"none\">svnserve</command> which sets the umask (see <xref linkend=\"svn.serverconfig.multimethod\"/>). It also shows how to anchor <command moreinfo=\"none\">svnserve</command> in a virtual root directory, just as one often does when running <command moreinfo=\"none\">svnserve</command> as a daemon process. This might be done either to restrict access to parts of the system, or simply to relieve the user of having to type an absolute path in the <literal moreinfo=\"none\">svn+ssh://</literal> URL."
msgstr "在这个例子里，<filename moreinfo=\"none\">/path/to/svnserve</filename>也许会是一个<command moreinfo=\"none\">svnserve</command>程序的包裹脚本，会来设置umask（见<xref linkend=\"svn.serverconfig.multimethod\"/>）。它也展示了怎样在虚拟根目录定位一个<command moreinfo=\"none\">svnserve</command>，就像我们经常在使用守护进程模式下运行<command moreinfo=\"none\">svnserve</command>一样。这样做不仅可以把访问限制在系统的一部分，也可以使用户不需要在<literal moreinfo=\"none\">svn+ssh://</literal>URL里输入绝对路径。"

#: build/en/book.xml:13671(para)
msgid "It's also possible to have multiple users share a single account. Instead of creating a separate system account for each user, generate a public/private keypair for each person. Then place each public key into the <filename moreinfo=\"none\">authorized_users</filename> file, one per line, and use the <option>--tunnel-user</option> option:"
msgstr "多个用户也可以共享同一个帐号，作为为每个用户创建系统帐户的替代，我们创建一个公开/私有密钥对，然后在<filename moreinfo=\"none\">authorized_users</filename>文件里放置各自的公钥，一个用户一行，使用<option>--tunnel-user</option>选项："

#: build/en/book.xml:13679(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n"
"  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"
msgstr ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n"
"  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"

#: build/en/book.xml:13684(para)
msgid "This example allows both Harry and Sally to connect to the same account via public-key authentication. Each of them has a custom command that will be executed; the <option>--tunnel-user</option> option tells <command moreinfo=\"none\">svnserve -t</command> to assume that the named argument is the authenticated user. Without <option>--tunnel-user</option>, it would appear as though all commits were coming from the one shared system account."
msgstr "这个例子允许Harry和Sally通过公钥认证连接同一个的账户，每个人自定义的命令将会执行。<option>--tunnel-user</option>选项告诉<command moreinfo=\"none\">svnserve -t</command>命令采用命名的参数作为经过认证的用户，如果没有<option>--tunnel-user</option>，所有的提交会作为共享的系统帐户提交。"

#: build/en/book.xml:13694(para)
msgid "A final word of caution: giving a user access to the server via public-key in a shared account might still allow other forms of SSH access, even if you've set the <literal moreinfo=\"none\">command</literal> value in <filename moreinfo=\"none\">authorized_keys</filename>. For example, the user may still get shell access through SSH, or be able to perform X11 or general port-forwarding through your server. To give the user as little permission as possible, you may want to specify a number of restrictive options immediately after the <literal moreinfo=\"none\">command</literal>:"
msgstr "最后要小心：设定通过公钥共享账户进行用户访问时还会允许其它形式的SSH访问，即使你设置了<filename moreinfo=\"none\">authorized_keys</filename>的<literal moreinfo=\"none\">command</literal>值，举个例子，用户仍然可以通过SSH得到shell访问，或者是通过服务器执行X11或者是端口转发。为了给用户尽可能少的访问权限，你或许希望在<literal moreinfo=\"none\">command</literal>命令之后指定一些限制选项："

#: build/en/book.xml:1370(para)
msgid "In the end, it all comes down to one critical factor: user communication. When users communicate poorly, both syntactic and semantic conflicts increase. No system can force users to communicate perfectly, and no system can detect semantic conflicts. So there's no point in being lulled into a false promise that a locking system will somehow prevent conflicts; in practice, locking seems to inhibit productivity more than anything else."
msgstr "最后，一切都要归结到一条重要的因素：用户交流。当用户交流贫乏，语法和语义的冲突就会增加，没有系统可以强制用户完美的交流，没有系统可以检测语义上的冲突，所以没有任何证据能够承诺锁定系统可以防止冲突，实践中，锁定除了约束了生产力，并没有做什么事。"

#: build/en/book.xml:13705(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n"
"           no-agent-forwarding,no-X11-forwarding,no-pty \\\n"
"           TYPE1 KEY1 harry@example.com\n"
msgstr ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n"
"           no-agent-forwarding,no-X11-forwarding,no-pty \\\n"
"           TYPE1 KEY1 harry@example.com\n"

#: build/en/book.xml:13723(title)
msgid "httpd, the Apache HTTP server"
msgstr "httpd，Apache的HTTP服务器"

#: build/en/book.xml:13725(para)
#, fuzzy
msgid "The Apache HTTP Server is a <quote>heavy duty</quote> network server that Subversion can leverage. Via a custom module, <command moreinfo=\"none\">httpd</command> makes Subversion repositories available to clients via the WebDAV/DeltaV protocol, which is an extension to HTTP 1.1 (see <ulink url=\"http://www.webdav.org/\"/> for more information). This protocol takes the ubiquitous HTTP protocol that is the core of the World Wide Web, and adds writing—specifically, versioned writing—capabilities. The result is a standardized, robust system that is conveniently packaged as part of the Apache 2.0 software, is supported by numerous operating systems and third-party products, and doesn't require network administrators to open up yet another custom port. <placeholder-1/> While an Apache-Subversion server has more features than <command moreinfo=\"none\">svnserve</command>, it's also a bit more difficult to set up. With flexibility often comes more complexity."
msgstr "Apache的HTTP服务器是一个Subversion可以利用的<quote>重型</quote>网络服务器，通过一个自定义模块，<command moreinfo=\"none\">httpd</command>可以让Subversion版本库通过WebDAV/DeltaV协议在客户端前可见，WebDAV/DeltaV协议是HTTP 1.1的扩展（见<ulink url=\"http://www.webdav.org/\"/>来查看详细信息）。这个协议利用了无处不在的HTTP协议是广域网的核心这一点，添加了写能力—更明确一点，版本化的写—能力。结果就是这样一个标准化的健壮的系统，作为Apache 2.0软件的一部分打包，被许多操作系统和第三方产品支持，网络管理员也不需要打开另一个自定义端口。 <footnote><placeholder-1/></footnote>这样一个Apache-Subversion服务器具备了许多<command moreinfo=\"none\">svnserve</command>没有的特性，但是也有一点难于配置，灵活通常会带来复杂性。"

#: build/en/book.xml:13739(para)
msgid "They really hate doing that."
msgstr "他们讨厌这样做。"

#: build/en/book.xml:13745(para)
msgid "Much of the following discussion includes references to Apache configuration directives. While some examples are given of the use of these directives, describing them in full is outside the scope of this chapter. The Apache team maintains excellent documentation, publicly available on their website at <ulink url=\"http://httpd.apache.org\"/>. For example, a general reference for the configuration directives is located at <ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>."
msgstr "下面的讨论包括了对Apache配置指示的引用，给了一些使用这些指示的例子，详细地描述不在本章的范围之内，Apache小组维护了完美的文档，公开存放在他们的站点<ulink url=\"http://httpd.apache.org\"/>。例如，一个一般的配置参考位于<ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>。"

#: build/en/book.xml:13753(para)
msgid "Also, as you make changes to your Apache setup, it is likely that somewhere along the way a mistake will be made. If you are not already familiar with Apache's logging subsystem, you should become aware of it. In your <filename moreinfo=\"none\">httpd.conf</filename> file are directives that specify the on-disk locations of the access and error logs generated by Apache (the <literal moreinfo=\"none\">CustomLog</literal> and <literal moreinfo=\"none\">ErrorLog</literal> directives, respectively). Subversion's mod_dav_svn uses Apache's error logging interface as well. You can always browse the contents of those files for information that might reveal the source of a problem that is not clearly noticeable otherwise."
msgstr "同样，当你修改你的Apache设置，很有可能会出现一些错误，如果你还不熟悉Apache的日志子系统，你一定需要认识到这一点。在你的文件<filename moreinfo=\"none\">httpd.conf</filename>里会指定Apache生成的访问和错误日志（<literal moreinfo=\"none\">CustomLog</literal>和<literal moreinfo=\"none\">ErrorLog</literal>指示）的磁盘位置。Subversion的mod_dav_svn使用Apache的错误日志接口，你可以浏览这个文件的内容查看信息来查找难于发现的问题根源。"

#: build/en/book.xml:13767(title)
msgid "Why Apache 2?"
msgstr "为什么是Apache 2？"

#: build/en/book.xml:13769(para)
msgid "If you're a system administrator, it's very likely that you're already running the Apache web server and have some prior experience with it. At the time of writing, Apache 1.3 is by far the most popular version of Apache. The world has been somewhat slow to upgrade to the Apache 2.X series for various reasons: some people fear change, especially changing something as critical as a web server. Other people depend on plug-in modules that only work against the Apache 1.3 API, and are waiting for a 2.X port. Whatever the reason, many people begin to worry when they first discover that Subversion's Apache module is written specifically for the Apache 2 API."
msgstr "如果你系统管理员，很有可能是你已经运行了Apache服务器，并且有一些高级经验。写本文的时候，Apache 1.3是Apache最流行的版本，这个世界因为许多原因而放缓升级到2.X系列：如人们害怕改变，特别是像web服务器这种重要的变化，有些人需要一些在Apache 1.3 API下工作的插件模块，在等待2.X的版本。无论什么原因，许多人会在首次发现Subversion的Apache模块只是为Apache 2 API写的后开始担心。"

#: build/en/book.xml:13781(para)
msgid "The proper response to this problem is: don't worry about it. It's easy to run Apache 1.3 and Apache 2 side-by-side; simply install them to separate places, and use Apache 2 as a dedicated Subversion server that runs on a port other than 80. Clients can access the repository by placing the port number into the URL:"
msgstr "对此问题的适当反应是：不需要担心，同时运行Apache 1.3和Apache 2非常简单，只需要安装到不同的位置，用Apache 2作为Subversion的专用服务器，并且不使用80端口，客户端可以访问版本库时在URL里指定端口："

#: build/en/book.xml:13788(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://host.example.com:7382/repos/project\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://host.example.com:7382/repos/project\n"
"…\n"

#: build/en/book.xml:13797(title)
msgid "Prerequisites"
msgstr "必备条件"

#: build/en/book.xml:13799(para)
msgid "To network your repository over HTTP, you basically need four components, available in two packages. You'll need Apache <command moreinfo=\"none\">httpd</command> 2.0, the <command moreinfo=\"none\">mod_dav</command> DAV module that comes with it, Subversion, and the <command moreinfo=\"none\">mod_dav_svn</command> filesystem provider module distributed with Subversion. Once you have all of those components, the process of networking your repository is as simple as:"
msgstr "为了让你的版本库使用HTTP网络，你基本上需要两个包里的四个部分。你需要Apache <command moreinfo=\"none\">httpd</command> 2.0和包括的<command moreinfo=\"none\">mod_dav</command> DAV模块，Subversion和与之一同分发的<command moreinfo=\"none\">mod_dav_svn</command>文件系统提供者模块，如果你有了这些组件，网络化你的版本库将非常简单，如："

#: build/en/book.xml:138(para)
msgid "The three co-authors of the new book were thus presented with an unusual opportunity. Officially, their task was to write a book top-down, starting from a table of contents and an initial draft. But they also had access to a steady stream—indeed, an uncontrollable geyser—of bottom-up source material. Subversion was already in the hands of thousands of early adopters, and those users were giving tons of feedback, not only about Subversion, but about its existing documentation."
msgstr "新书的三位合著者因而面临着一个不寻常的机会。从职责上讲，他们的任务是从一个目录和一些草稿为基础，自上而下的写一部专著。但事实上，他们的灵感源泉则来自一些具体的内容，稳定却难以组织。Subversion被数以千计的早期用户采用，这些用户提供了大量的反馈，不仅仅针对Subversion，还包括业已存在的文档。"

#: build/en/book.xml:1380(title)
msgid "When Locking is Necessary"
msgstr "什么时候锁定是必需的"

#: build/en/book.xml:13810(para)
msgid "getting httpd 2.0 up and running with the mod_dav module,"
msgstr "配置好httpd 2.0，并且使用mod_dav启动，"

#: build/en/book.xml:13814(para)
msgid "installing the mod_dav_svn plugin to mod_dav, which uses Subversion's libraries to access the repository, and"
msgstr "为mod_dav安装mod_dav_svn插件，它会使用Subversion的库访问版本库，并且"

#: build/en/book.xml:13819(para)
msgid "configuring your <filename moreinfo=\"none\">httpd.conf</filename> file to export (or expose) the repository."
msgstr "配置你的<filename moreinfo=\"none\">httpd.conf</filename>来输出（或者说暴露）版本库。"

#: build/en/book.xml:1382(para)
msgid "While the lock-modify-unlock model is considered generally harmful to collaboration, there are still times when locking is appropriate."
msgstr "锁定-修改-解锁模型被认为不利于协作，但有时候锁定会更好。"

#: build/en/book.xml:13824(para)
msgid "You can accomplish the first two items either by compiling <command moreinfo=\"none\">httpd</command> and Subversion from source code, or by installing pre-built binary packages of them on your system. For the most up-to-date information on how to compile Subversion for use with the Apache HTTP Server, as well as how to compile and configure Apache itself for this purpose, see the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the Subversion source code tree."
msgstr "你可以通过从源代码编译<command moreinfo=\"none\">httpd</command>和Subversion来完成前两个项目，也可以通过你的系统上的已经编译好的二进制包来安装。最新的使用Apache HTTP的Subversion的编译方法和Apache的配置方式可以看Subversion源代码树根目录的<filename moreinfo=\"none\">INSTALL</filename>文件。"

#: build/en/book.xml:13837(title)
msgid "Basic Apache Configuration"
msgstr "基本的Apache配置"

#: build/en/book.xml:13839(para)
msgid "Once you have all the necessary components installed on your system, all that remains is the configuration of Apache via its <filename moreinfo=\"none\">httpd.conf</filename> file. Instruct Apache to load the mod_dav_svn module using the <literal moreinfo=\"none\">LoadModule</literal> directive. This directive must precede any other Subversion-related configuration items. If your Apache was installed using the default layout, your <command moreinfo=\"none\">mod_dav_svn</command> module should have been installed in the <filename moreinfo=\"none\">modules</filename> subdirectory of the Apache install location (often <filename moreinfo=\"none\">/usr/local/apache2</filename>). The <literal moreinfo=\"none\">LoadModule</literal> directive has a simple syntax, mapping a named module to the location of a shared library on disk:"
msgstr "一旦你安装了必须的组件，剩下的工作就是在<filename moreinfo=\"none\">httpd.conf</filename>里配置Apache，使用<literal moreinfo=\"none\">LoadModule</literal>来加载mod_dav_svn模块，这个指示必须先与其它Subversion相关的其它配置出现，如果你的Apache使用缺省布局安装，你的<command moreinfo=\"none\">mod_dav_svn</command>模块一定在Apache安装目录（通常是在<filename moreinfo=\"none\">/usr/local/apache2</filename>）的<filename moreinfo=\"none\">modules</filename>子目录，<literal moreinfo=\"none\">LoadModule</literal>指示的语法很简单，影射一个名字到它的共享库的物理位置："

#: build/en/book.xml:13854(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"

#: build/en/book.xml:13858(para)
msgid "Note that if <command moreinfo=\"none\">mod_dav</command> was compiled as a shared object (instead of statically linked directly to the <command moreinfo=\"none\">httpd</command> binary), you'll need a similar <literal moreinfo=\"none\">LoadModule</literal> statement for it, too. Be sure that it comes before the <command moreinfo=\"none\">mod_dav_svn</command> line:"
msgstr "注意，如果<command moreinfo=\"none\">mod_dav</command>是作为共享对象编译（而不是静态链接到<command moreinfo=\"none\">httpd</command>程序），你需要为它使用使用<literal moreinfo=\"none\">LoadModule</literal>语句，一定确定它在<command moreinfo=\"none\">mod_dav_svn</command>之前："

#: build/en/book.xml:1386(para)
msgid "The copy-modify-merge model is based on the assumption that files are contextually mergeable: that is, that the majority of the files in the repository are line-based text files (such as program source code). But for files with binary formats, such as artwork or sound, it's often impossible to merge conflicting changes. In these situations, it really is necessary to users to take strict turns when changing the file. Without serialized access, somebody ends up wasting time on changes that are ultimately discarded."
msgstr "拷贝-修改-合并模型假定文件是可以根据上下文合并的：就是版本库的文件主要是以行为基础的文本文件（例如程序源代码）。但对于二进制格式，例如艺术品或声音，在这种情况下，十分有必要让用户轮流修改文件，如果没有线性的访问，有些人的许多工作就最终要被放弃。"

#: build/en/book.xml:13864(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"

#: build/en/book.xml:13870(para)
msgid "At a later location in your configuration file, you now need to tell Apache where you keep your Subversion repository (or repositories). The <literal moreinfo=\"none\">Location</literal> directive has an XML-like notation, starting with an opening tag, and ending with a closing tag, with various other configuration directives in the middle. The purpose of the <literal moreinfo=\"none\">Location</literal> directive is to instruct Apache to do something special when handling requests that are directed at a given URL or one of its children. In the case of Subversion, you want Apache to simply hand off support for URLs that point at versioned resources to the DAV layer. You can instruct Apache to delegate the handling of all URLs whose path portions (the part of the URL that follows the server's name and the optional port number) begin with <filename moreinfo=\"none\">/repos/</filename> to a DAV provider whose repository is located at <filename moreinfo=\"none\">/absolute/path/to/repository</filename> using the following <filename moreinfo=\"none\">httpd.conf</filename> syntax:"
msgstr "在你的配置文件后面的位置，你需要告诉Apache你在什么地方保存Subversion版本库（也许是多个），<literal moreinfo=\"none\">位置</literal>指示有一个很像XML的符号，开始于一个开始标签，以一个结束标签结束，配合中间许多的其它配置。<literal moreinfo=\"none\">Location</literal>指示的目的是告诉Apache在特定的URL以及子URL下需要特殊的处理，如果是为Subversion准备的，你希望可以通过告诉Apache特定URL是指向版本化的资源，从而把支持转交给DAV层，你可以告诉Apache将所有路径部分（URL中服务器名称和端口之后的部分）以<filename moreinfo=\"none\">/repos/</filename>开头的URL交由DAV服务提供者处理。一个DAV服务提供者的版本库位于<filename moreinfo=\"none\">/absolute/path/to/repository</filename>，可以使用如下的<filename moreinfo=\"none\">httpd.conf</filename>语法："

#: build/en/book.xml:13889(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /absolute/path/to/repository\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /absolute/path/to/repository\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:13896(para)
#, fuzzy
msgid "If you plan to support multiple Subversion repositories that will reside in the same parent directory on your local disk, you can use an alternative directive, the <literal moreinfo=\"none\">SVNParentPath</literal> directive, to indicate that common parent directory. For example, if you know you will be creating multiple Subversion repositories in a directory <filename moreinfo=\"none\">/usr/local/svn</filename> that would be accessed via URLs like <uri>http://my.server.com/svn/repos1</uri>, <uri>http://my.server.com/svn/repos2</uri>, and so on, you could use the <filename moreinfo=\"none\">httpd.conf</filename> configuration syntax in the following example:"
msgstr "如果你计划支持多个具备相同父目录的Subversion版本库，你有另外的选择，<literal moreinfo=\"none\">SVNParentPath</literal>指示，来表示共同的父目录。举个例子，如果你知道你会在<filename moreinfo=\"none\">/usr/local/svn</filename>下创建多个Subversion版本库，并且通过类似<systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos1</systemitem>，<systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos2</systemitem>的URL访问，你可以用后面例子中的<filename moreinfo=\"none\">httpd.conf</filename>配置语法："

#: build/en/book.xml:13908(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"\n"
"  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"\n"
"  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:13917(para)
msgid "Using the previous syntax, Apache will delegate the handling of all URLs whose path portions begin with <filename moreinfo=\"none\">/svn/</filename> to the Subversion DAV provider, which will then assume that any items in the directory specified by the <literal moreinfo=\"none\">SVNParentPath</literal> directive are actually Subversion repositories. This is a particularly convenient syntax in that, unlike the use of the <literal moreinfo=\"none\">SVNPath</literal> directive, you don't have to restart Apache in order to create and network new repositories."
msgstr "使用上面的语法，Apache会代理所有URL路径部分为<filename moreinfo=\"none\">/svn/</filename>的请求到Subversion的DAV提供者，Subversion会认为<literal moreinfo=\"none\">SVNParentPath</literal>指定的目录下的所有项目是真实的Subversion版本库，这通常是一个便利的语法，不像是用<literal moreinfo=\"none\">SVNPath</literal>指示，我们在此不必为创建新的版本库而重启Apache。"

#: build/en/book.xml:13928(para)
#, fuzzy
msgid "Be sure that when you define your new <literal moreinfo=\"none\">Location</literal>, it doesn't overlap with other exported Locations. For example, if your main <literal moreinfo=\"none\">DocumentRoot</literal> is exported to <filename moreinfo=\"none\">/www</filename>, do not export a Subversion repository in <literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>. If a request comes in for the URI <filename moreinfo=\"none\">/www/repos/foo.c</filename>, Apache won't know whether to look for a file <filename moreinfo=\"none\">repos/foo.c</filename> in the <literal moreinfo=\"none\">DocumentRoot</literal>, or whether to delegate <command moreinfo=\"none\">mod_dav_svn</command> to return <filename moreinfo=\"none\">foo.c</filename> from the Subversion repository."
msgstr "请确定当你定义新的<literal moreinfo=\"none\">位置</literal>，不会与其它输出的位置重叠，例如你的主要<literal moreinfo=\"none\">DocumentRoot</literal>是<filename moreinfo=\"none\">/www</filename>，不要把Subversion版本库输出到<literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>，如果一个请求的URI是<filename moreinfo=\"none\">/www/repos/foo.c</filename>，Apache不知道是直接到<filename moreinfo=\"none\">repos/foo.c</filename>访问这个文件还是让<command moreinfo=\"none\">mod_dav_svn</command>代理从Subversion版本库返回<filename moreinfo=\"none\">foo.c</filename>。"

#: build/en/book.xml:13943(title)
msgid "Server Names and the COPY Request"
msgstr "服务器名称和拷贝请求"

#: build/en/book.xml:13945(para)
msgid "Subversion makes use of the <literal moreinfo=\"none\">COPY</literal> request type to perform server-side copies of files and directories. As part of the sanity checking done by the Apache modules, the source of the copy is expected to be located on the same machine as the destination of the copy. To satisfy this requirement, you might need to tell mod_dav the name you use as the hostname of your server. Generally, you can use the <literal moreinfo=\"none\">ServerName</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename> to accomplish this."
msgstr "Subversion利用<literal moreinfo=\"none\">COPY</literal>请求类型来执行服务器端的文件和目录拷贝，作为一个健全的Apache模块的一部分，拷贝源和拷贝的目标通常坐落在同一个机器上，为了满足这个需求，你或许需要告诉mod_dav服务器主机的名称，通常你可以使用<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">ServerName</literal>指示来完成此目的。"

#: build/en/book.xml:13955(screen)
#, no-wrap
msgid ""
"\n"
"ServerName svn.example.com\n"
msgstr ""
"\n"
"ServerName svn.example.com\n"

#: build/en/book.xml:13959(para)
msgid "If you are using Apache's virtual hosting support via the <literal moreinfo=\"none\">NameVirtualHost</literal> directive, you may need to use the <literal moreinfo=\"none\">ServerAlias</literal> directive to specify additional names that your server is known by. Again, refer to the Apache documentation for full details."
msgstr "如果你通过<literal moreinfo=\"none\">NameVirtualHost</literal>指示使用Apache的虚拟主机，你或许需要<literal moreinfo=\"none\">ServerAlias</literal>指示来指定额外的名称，再说一次，可以查看Apache文档的来得到更多细节。"

#: build/en/book.xml:13967(para)
#, fuzzy
msgid "At this stage, you should strongly consider the question of permissions. If you've been running Apache for some time now as your regular web server, you probably already have a collection of content—web pages, scripts and such. These items have already been configured with a set of permissions that allows them to work with Apache, or more appropriately, that allows Apache to work with those files. Apache, when used as a Subversion server, will also need the correct permissions to read and write to your Subversion repository."
msgstr "在本阶段，你一定要考虑访问权限问题，如果你已经作为普通的web服务器运行过Apache，你一定有了一些内容—网页、脚本和其他。这些项目已经配置了许多在Apache下可以工作的访问许可，或者更准确一点，允许Apache与这些文件一起工作。Apache当作为Subversion服务器运行时，同样需要正确的访问许可来读写你的Subversion版本库。（见<xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>。）"

#: build/en/book.xml:1397(para)
#, fuzzy
msgid "While Subversion is still primarily a copy-modify-merge system, it still recognizes the need to lock an occasional file ands provide mechanisms for this. This feature is discussed later in this book, in <xref linkend=\"svn.advanced.locking\"/>."
msgstr "尽管CVS和Subversion一直主要是拷贝-修改-合并系统，它们都意识到了需要锁定一些文件，并且提供这种锁定机制。见<xref linkend=\"svn.advanced.locking\"/>。"

#: build/en/book.xml:13978(para)
msgid "You will need to determine a permission system setup that satisfies Subversion's requirements without messing up any previously existing web page or script installations. This might mean changing the permissions on your Subversion repository to match those in use by other things that Apache serves for you, or it could mean using the <literal moreinfo=\"none\">User</literal> and <literal moreinfo=\"none\">Group</literal> directives in <filename moreinfo=\"none\">httpd.conf</filename> to specify that Apache should run as the user and group that owns your Subversion repository. There is no single correct way to set up your permissions, and each administrator will have different reasons for doing things a certain way. Just be aware that permission-related problems are perhaps the most common oversight when configuring a Subversion repository for use with Apache."
msgstr "你会需要检验权限系统的设置满足Subversion的需求，同时不会把以前的页面和脚本搞乱。这或许意味着修改Subversion的访问许可来配合Apache服务器已经使用的工具，或者可能意味着需要使用<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">User</literal>和<literal moreinfo=\"none\">Group</literal>指示来指定Apache作为运行的用户和Subversion版本库的组。并不是只有一条正确的方式来设置许可，每个管理员都有不同的原因来以特定的方式操作，只需要意识到许可关联的问题经常在为Apache配置Subversion版本库的过程中被疏忽。"

#: build/en/book.xml:13998(title)
msgid "Authentication Options"
msgstr "认证选项"

#: build/en/book.xml:14(edition)
msgid "Second"
msgstr ""

#: build/en/book.xml:14000(para)
msgid "At this point, if you configured <filename moreinfo=\"none\">httpd.conf</filename> to contain something like"
msgstr "此时，如果你配置的<filename moreinfo=\"none\">httpd.conf</filename>保存如下的内容"

#: build/en/book.xml:14003(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14010(para)
msgid "…then your repository is <quote>anonymously</quote> accessible to the world. Until you configure some authentication and authorization policies, the Subversion repositories you make available via the <literal moreinfo=\"none\">Location</literal> directive will be generally accessible to everyone. In other words,"
msgstr "这样你的版本库对全世界是可以<quote>匿名</quote>访问的，直到你配置了一些认证授权政策，你通过<literal moreinfo=\"none\">Location</literal>指示来使Subversion版本库可以被任何人访问，换句话说，"

#: build/en/book.xml:14019(para)
msgid "anyone can use their Subversion client to checkout a working copy of a repository URL (or any of its subdirectories),"
msgstr "任何人可以使用Subversion客户端来从版本库URL取出一个工作拷贝（或者是它的子目录），"

#: build/en/book.xml:14024(para)
msgid "anyone can interactively browse the repository's latest revision simply by pointing their web browser to the repository URL, and"
msgstr "任何人可以在浏览器输入版本库URL交互浏览的方式来查看版本库的最新修订版本，并且"

#: build/en/book.xml:14029(para)
msgid "anyone can commit to the repository."
msgstr "任何人可以提交到版本库。"

#: build/en/book.xml:14033(para)
msgid "Of course, you might have already set up a <filename moreinfo=\"none\">pre-commit</filename> hook script to prevent commits (see <xref linkend=\"svn.reposadmin.create.hooks\"/>). But as you read on, you'll see that it's also possible use Apache's built-in methods to restrict access in specific ways."
msgstr ""

#: build/en/book.xml:14042(title)
msgid "Basic HTTP Authentication"
msgstr "基本HTTP认证"

#: build/en/book.xml:14044(para)
msgid "The easiest way to authenticate a client is via the HTTP Basic authentication mechanism, which simply uses a username and password to verify that a user is who she says she is. Apache provides an <command moreinfo=\"none\">htpasswd</command> utility for managing the list of acceptable usernames and passwords, those to whom you wish to grant special access to your Subversion repository. Let's grant commit access to Sally and Harry. First, we need to add them to the password file."
msgstr "最简单的客户端认证方式是通过HTTP基本认证机制，简单的使用用户名和密码来验证一个用户所自称的身份，Apache提供了一个<command moreinfo=\"none\">htpasswd</command>工具来管理可接受的用户名和密码，这些就是你希望赋予Subversion特别权限的用户，让我们给Sally和Harry赋予提交权限，首先，我们需要添加他们到密码文件。"

#: build/en/book.xml:14054(screen)
#, no-wrap
msgid ""
"\n"
"$ ### First time: use -c to create the file\n"
"$ ### Use -m to use MD5 encryption of the password, which is more secure\n"
"$ htpasswd -cm /etc/svn-auth-file harry\n"
"New password: *****\n"
"Re-type new password: *****\n"
"Adding password for user harry\n"
"$ htpasswd -m /etc/svn-auth-file sally\n"
"New password: *******\n"
"Re-type new password: *******\n"
"Adding password for user sally\n"
"$\n"
msgstr ""
"\n"
"$ ### First time: use -c to create the file\n"
"$ ### Use -m to use MD5 encryption of the password, which is more secure\n"
"$ htpasswd -cm /etc/svn-auth-file harry\n"
"New password: *****\n"
"Re-type new password: *****\n"
"Adding password for user harry\n"
"$ htpasswd -m /etc/svn-auth-file sally\n"
"New password: *******\n"
"Re-type new password: *******\n"
"Adding password for user sally\n"
"$\n"

#: build/en/book.xml:14068(para)
msgid "Next, you need to add some more <filename moreinfo=\"none\">httpd.conf</filename> directives inside your <literal moreinfo=\"none\">Location</literal> block to tell Apache what to do with your new password file. The <literal moreinfo=\"none\">AuthType</literal> directive specifies the type of authentication system to use. In this case, we want to specify the <literal moreinfo=\"none\">Basic</literal> authentication system. <literal moreinfo=\"none\">AuthName</literal> is an arbitrary name that you give for the authentication domain. Most browsers will display this name in the pop-up dialog box when the browser is querying the user for his name and password. Finally, use the <literal moreinfo=\"none\">AuthUserFile</literal> directive to specify the location of the password file you created using <command moreinfo=\"none\">htpasswd</command>."
msgstr "下一步，你需要在<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">Location</literal>区里添加一些指示来告诉Apache如何来使用这些密码文件，<literal moreinfo=\"none\">AuthType</literal>指示指定系统使用的认证类型，这种情况下，我们需要指定<literal moreinfo=\"none\">Basic</literal>认证系统，<literal moreinfo=\"none\">AuthName</literal>是你提供给认证域一个任意名称，大多数浏览器会在向用户询问名称和密码的弹出窗口里显示这个名称，最终，使用<literal moreinfo=\"none\">AuthUserFile</literal>指示来指定使用<command moreinfo=\"none\">htpasswd</command>创建的密码文件的位置。"

#: build/en/book.xml:14083(para)
msgid "After adding these three directives, your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block should look something like this:"
msgstr "添加完这三个指示，你的<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块一定像这个样子："

#: build/en/book.xml:14087(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14097(para)
msgid "This <literal moreinfo=\"none\">&lt;Location&gt;</literal> block is not yet complete, and will not do anything useful. It's merely telling Apache that whenever authorization is required, Apache should harvest a username and password from the Subversion client. What's missing here, however, are directives that tell Apache <emphasis>which</emphasis> sorts of client requests require authorization. Wherever authorization is required, Apache will demand authentication as well. The simplest thing to do is protect all requests. Adding <literal moreinfo=\"none\">Require valid-user</literal> tells Apache that all requests require an authenticated user:"
msgstr "这个<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块还没有结束，还不能做任何有用的事情，它只是告诉Apache当需要授权时，要去向Subversion客户端索要用户名和密码。我们这里遗漏的，是一些告诉Apache<emphasis>什么样</emphasis>客户端需要授权的指示。哪里需要授权，Apache就会在哪里要求认证，最简单的方式是保护所有的请求，添加<literal moreinfo=\"none\">Require valid-user</literal>来告诉Apache任何请求需要认证的用户："

#: build/en/book.xml:14110(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14121(para)
msgid "Be sure to read the next section (<xref linkend=\"svn.serverconfig.httpd.authz\"/>) for more detail on the <literal moreinfo=\"none\">Require</literal> directive and other ways to set authorization policies."
msgstr "一定要阅读后面的部分（<xref linkend=\"svn.serverconfig.httpd.authz\"/>）来得到<literal moreinfo=\"none\">Require</literal>的细节，和授权政策的其他设置方法。"

#: build/en/book.xml:14125(para)
#, fuzzy
msgid "One word of warning: HTTP Basic Auth passwords pass in very nearly plain-text over the network, and thus are extremely insecure. If you're worried about password snooping, it may be best to use some sort of SSL encryption, so that clients authenticate via <literal moreinfo=\"none\">https://</literal> instead of <literal moreinfo=\"none\">http://</literal>; at a bare minimum, you can configure Apache to use a self-signed server certificate. <placeholder-1/> Consult Apache's documentation (and OpenSSL documentation) about how to do that."
msgstr "需要警惕：HTTP基本认证的密码是用明文传输，因此非常不可靠的，如果你担心密码偷窥，最好是使用某种SSL加密，所以客户端认证使用<literal moreinfo=\"none\">https://</literal>而不是<literal moreinfo=\"none\">http://</literal>，为了方便，你可以配置Apache为自签名认证。 <footnote><placeholder-1/></footnote> 参考Apache的文档（和OpenSSL文档）来查看怎样做。"

#: build/en/book.xml:14134(para)
msgid "While self-signed server certificates are still vulnerable to a <quote>man in the middle</quote> attack, such an attack is still much more difficult for a casual observer to pull off, compared to sniffing unprotected passwords."
msgstr "当使用自签名的服务器时仍会遭受<quote>中间人</quote>攻击，但是与偷取未保护的密码相比，这样的攻击比一个偶然的获取要艰难许多。"

#: build/en/book.xml:14148(title)
msgid "SSL Certificate Management"
msgstr "SSL证书管理"

#: build/en/book.xml:1415(title)
msgid "Subversion in Action"
msgstr "Subversion实战"

#: build/en/book.xml:14150(para)
msgid "Businesses that need to expose their repositories for access outside the company firewall should be conscious of the possibility that unauthorized parties could be <quote>sniffing</quote> their network traffic. SSL makes that kind of unwanted attention less likely to result in sensitive data leaks."
msgstr "商业应用需要越过公司防火墙的版本库访问，防火墙需要小心的考虑非认证用户<quote>吸取</quote>他们的网络流量的情况，SSL让那种形式的关注更不容易导致敏感数据泄露。"

#: build/en/book.xml:14157(para)
msgid "If a Subversion client is compiled to use OpenSSL, then it gains the ability to speak to an Apache server via <literal moreinfo=\"none\">https://</literal> URLs. The Neon library used by the Subversion client is not only able to verify server certificates, but can also supply client certificates when challenged. When the client and server have exchanged SSL certificates and successfully authenticated one another, all further communication is encrypted via a session key."
msgstr "如果Subversion使用OpenSSL编译，它就会具备与Subversion服务器使用<literal moreinfo=\"none\">https://</literal>的URL通讯的能力，Subversion客户端使用的Neon库不仅仅可以用来验证服务器证书，也可以必要时提供客户端证书，如果客户端和服务器交换了SSL证书并且成功地互相认证，所有剩下的交流都会通过一个会话关键字加密。"

#: build/en/book.xml:14166(para)
msgid "It's beyond the scope of this book to describe how to generate client and server certificates, and how to configure Apache to use them. Many other books, including Apache's own documentation, describe this task. But what <emphasis>can</emphasis> be covered here is how to manage server and client certificates from an ordinary Subversion client."
msgstr "怎样产生客户端和服务器端证书以及怎样使用它们已经超出了本书的范围，许多书籍，包括Apache自己的文档，描述这个任务，现在我们<emphasis>可以</emphasis>覆盖的是普通的客户端怎样来管理服务器与客户端证书。"

#: build/en/book.xml:1417(para)
msgid "It's time to move from the abstract to the concrete. In this section, we'll show real examples of Subversion being used."
msgstr "是时候从抽象转到具体了，在本小节，我们会展示一个Subversion真实使用的例子。"

#: build/en/book.xml:14174(para)
msgid "When speaking to Apache via <literal moreinfo=\"none\">https://</literal>, a Subversion client can receive two different types of information:"
msgstr "当通过<literal moreinfo=\"none\">https://</literal>与Apache通讯时，一个Subversion客户端可以接收两种类型的信息："

#: build/en/book.xml:14179(para)
msgid "a server certificate"
msgstr "一个服务器证书"

#: build/en/book.xml:14180(para)
msgid "a demand for a client certificate"
msgstr "一个客户端证书的要求"

#: build/en/book.xml:14183(para)
msgid "If the client receives a server certificate, it needs to verify that it trusts the certificate: is the server really who it claims to be? The OpenSSL library does this by examining the signer of the server certificate, or <firstterm>certifying authority</firstterm> (CA). If OpenSSL is unable to automatically trust the CA, or if some other problem occurs (such as an expired certificate or hostname mismatch), the Subversion command-line client will ask you whether you want to trust the server certificate anyway:"
msgstr "如果客户端接收了一个服务器证书，它需要去验证它是可以相信的：这个服务器是它自称的那一个吗？OpenSSL库会去检验服务器证书的签名人或者是<firstterm>核证机构</firstterm>（CA）。如果OpenSSL不可以自动信任这个CA，或者是一些其他的问题（如证书过期或者是主机名不匹配），Subversion命令行客户端会询问你是否愿意仍然信任这个证书："

#: build/en/book.xml:14194(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Error validating server certificate for 'https://host.example.com:443':\n"
" - The certificate is not issued by a trusted authority. Use the\n"
"   fingerprint to validate the certificate manually!\n"
"Certificate information:\n"
" - Hostname: host.example.com\n"
" - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n"
" - Issuer: CA, example.com, Sometown, California, US\n"
" - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n"
"\n"
"(R)eject, accept (t)emporarily or accept (p)ermanently?\n"
msgstr ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Error validating server certificate for 'https://host.example.com:443':\n"
" - The certificate is not issued by a trusted authority. Use the\n"
"   fingerprint to validate the certificate manually!\n"
"Certificate information:\n"
" - Hostname: host.example.com\n"
" - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n"
" - Issuer: CA, example.com, Sometown, California, US\n"
" - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n"
"\n"
"(R)eject, accept (t)emporarily or accept (p)ermanently?\n"

#: build/en/book.xml:14209(para)
msgid "This dialogue should look familiar; it's essentially the same question you've probably seen coming from your web browser (which is just another HTTP client like Subversion!). If you choose the (p)ermanent option, the server certificate will be cached in your private run-time <filename moreinfo=\"none\">auth/</filename> area in just the same way your username and password are cached (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). If cached, Subversion will automatically remember to trust this certificate in future negotiations."
msgstr "这个对话看起来很熟悉，这是你会在web浏览器（另一种HTTP客户端，就像Subversion）经常看到的问题，如果你选择(p)ermanent选项，服务器证书会存放在你存放那个用户名和密码缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。）的私有运行区<filename moreinfo=\"none\">auth/</filename>中，缓存后，Subversion会自动记住在以后的交流中信任这个证书。"

#: build/en/book.xml:14219(para)
msgid "Your run-time <filename moreinfo=\"none\">servers</filename> file also gives you the ability to make your Subversion client automatically trust specific CAs, either globally or on a per-host basis. Simply set the <literal moreinfo=\"none\">ssl-authority-files</literal> variable to a semicolon-separated list of PEM-encoded CA certificates:"
msgstr "你的运行中<filename moreinfo=\"none\">servers</filename>文件也会给你能力可以让Subversion客户端自动信任特定的CA，包括全局的或是每主机为基础的，只需要设置<literal moreinfo=\"none\">ssl-authority-files</literal>为一组逗号隔开的PEM加密的CA证书列表："

#: build/en/book.xml:14226(screen)
#, no-wrap
msgid ""
"\n"
"[global]\n"
"ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"
msgstr ""
"\n"
"[global]\n"
"ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"

#: build/en/book.xml:1423(title)
msgid "Subversion Repository URLs"
msgstr "Subversion版本库URL"

#: build/en/book.xml:14231(para)
msgid "Many OpenSSL installations also have a pre-defined set of <quote>default</quote> CAs that are nearly universally trusted. To make the Subversion client automatically trust these standard authorities, set the <literal moreinfo=\"none\">ssl-trust-default-ca</literal> variable to <literal moreinfo=\"none\">true</literal>."
msgstr "许多OpenSSL安装包括一些预先定义好的可以普遍信任的<quote>缺省的</quote>CA，为了让Subversion客户端自动信任这些标准权威，设置<literal moreinfo=\"none\">ssl-trust-default-ca</literal>为<literal moreinfo=\"none\">true</literal>。"

#: build/en/book.xml:14238(para)
msgid "When talking to Apache, a Subversion client might also receive a challenge for a client certificate. Apache is asking the client to identify itself: is the client really who it says it is? If all goes correctly, the Subversion client sends back a private certificate signed by a CA that Apache trusts. A client certificate is usually stored on disk in encrypted format, protected by a local password. When Subversion receives this challenge, it will ask you for both a path to the certificate and the password which protects it:"
msgstr "当与Apache通话时，Subversion客户端也会收到一个证书的要求，Apache是询问客户端来证明自己的身份：这个客户端是否是他所说的那一个？如果一切正常，Subversion客户端会发送回一个通过Apache信任的CA签名的私有证书，一个客户端证书通常会以加密方式存放在磁盘，使用本地密码保护，当Subversion收到这个要求，它会询问你证书的路径和保护用的密码："

#: build/en/book.xml:14249(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Authentication realm: https://host.example.com:443\n"
"Client certificate filename: /path/to/my/cert.p12\n"
"Passphrase for '/path/to/my/cert.p12':  ********\n"
"…\n"
msgstr ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Authentication realm: https://host.example.com:443\n"
"Client certificate filename: /path/to/my/cert.p12\n"
"Passphrase for '/path/to/my/cert.p12':  ********\n"
"…\n"

#: build/en/book.xml:1425(para)
#, fuzzy
msgid "Throughout this book, Subversion uses URLs to identify versioned files and directories in Subversion repositories. For the most part, these URLs use the standard syntax, allowing for server names and port numbers to be specified as part of the URL:"
msgstr "正如我们在整本书里描述的，Subversion使用URL来识别Subversion版本库中的版本化资源，通常情况下，这些URL使用标准的语法，允许服务器名称和端口作为URL的一部分："

#: build/en/book.xml:14258(para)
msgid "Notice that the client certificate is a <quote>p12</quote> file. To use a client certificate with Subversion, it must be in PKCS#12 format, which is a portable standard. Most web browsers are already able to import and export certificates in that format. Another option is to use the OpenSSL command-line tools to convert existing certificates into PKCS#12."
msgstr "注意这个客户端证书是一个<quote>p12</quote>文件，为了让Subversion使用客户端证书，它必须是运输标准的PKCS#12格式，大多数浏览器可以导入和导出这种格式的证书，另一个选择是用OpenSSL命令行工具来转化存在的证书为PKCS#12格式。"

#: build/en/book.xml:14266(para)
msgid "Again, the runtime <filename moreinfo=\"none\">servers</filename> file allows you to automate this challenge on a per-host basis. Either or both pieces of information can be described in runtime variables:"
msgstr "再次，运行中<filename moreinfo=\"none\">servers</filename>文件允许你为每个主机自动响应这种要求，单个或两条信息可以用运行参数来描述："

#: build/en/book.xml:14271(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"examplehost = host.example.com\n"
"\n"
"[examplehost]\n"
"ssl-client-cert-file = /path/to/my/cert.p12\n"
"ssl-client-cert-password = somepassword\n"
msgstr ""
"\n"
"[groups]\n"
"examplehost = host.example.com\n"
"\n"
"[examplehost]\n"
"ssl-client-cert-file = /path/to/my/cert.p12\n"
"ssl-client-cert-password = somepassword\n"

#: build/en/book.xml:14280(para)
#, fuzzy
msgid "Once you've set the <literal moreinfo=\"none\">ssl-client-cert-file</literal> and <literal moreinfo=\"none\">ssl-client-cert-password</literal> variables, the Subversion client can automatically respond to a client certificate challenge without prompting you. <placeholder-1/>"
msgstr "一旦你设置了<literal moreinfo=\"none\">ssl-client-cert-file</literal>和 <literal moreinfo=\"none\">ssl-client-cert-password</literal>参数，Subversion客户端可以自动响应客户端证书请求而不会打扰你。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:14286(para)
msgid "More security-conscious folk might not want to store the client certificate password in the runtime <filename moreinfo=\"none\">servers</filename> file."
msgstr "更多有安全意识的人不会希望在运行中<filename moreinfo=\"none\">servers</filename>文件保存客户端证书密码。"

#: build/en/book.xml:14298(title)
msgid "Authorization Options"
msgstr "授权选项"

#: build/en/book.xml:14300(para)
msgid "At this point, you've configured authentication, but not authorization. Apache is able to challenge clients and confirm identities, but it has not been told how to allow or restrict access to the clients bearing those identities. This section describes two strategies for controlling access to your repositories."
msgstr "此刻，你已经配置了认证，但是没有配置授权，Apache可以要求用户认证并且确定身份，但是并没有说明这个身份的怎样允许和限制，这个部分描述了两种控制访问版本库的策略。"

#: build/en/book.xml:14309(title)
msgid "Blanket Access Control"
msgstr "整体访问控制"

#: build/en/book.xml:1431(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com:9834/repos\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com:9834/repos\n"
"…\n"

#: build/en/book.xml:14311(para)
msgid "The simplest form of access control is to authorize certain users for either read-only access to a repository, or read/write access to a repository."
msgstr "最简单的访问控制形式是授权特定用户为只读版本库访问或者是读/写访问版本库。"

#: build/en/book.xml:14315(para)
msgid "You can restrict access on all repository operations by adding the <literal moreinfo=\"none\">Require valid-user</literal> directive to your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block. Using our previous example, this would mean that only clients that claimed to be either <literal moreinfo=\"none\">harry</literal> or <literal moreinfo=\"none\">sally</literal>, and provided the correct password for their respective username, would be allowed to do anything with the Subversion repository:"
msgstr "你可以通过在<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块添加<literal moreinfo=\"none\">Require valid-user</literal>指示来限制所有的版本库操作，使用我们前面的例子，这意味着只有客户端只可以是<literal moreinfo=\"none\">harry</literal>或者<literal moreinfo=\"none\">sally</literal>，而且他们必须提供正确的用户名及对应密码，这样允许对Subversion版本库做任何事："

#: build/en/book.xml:14324(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14339(para)
msgid "Sometimes you don't need to run such a tight ship. For example, Subversion's own source code repository at <ulink url=\"http://svn.collab.net/repos/svn\"/> allows anyone in the world to perform read-only repository tasks (like checking out working copies and browsing the repository with a web browser), but restricts all write operations to authenticated users. To do this type of selective restriction, you can use the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> configuration directives. Like the <literal moreinfo=\"none\">Location</literal> directive, these blocks have starting and ending tags, and you would nest them inside your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr "有时候，你不需要这样严密，举个例子，Subversion自己在<ulink url=\"http://svn.collab.net/repos/svn\"/>的源代码允许全世界的人执行版本库的只读操作（例如检出我们的工作拷贝和使用浏览器浏览版本库），但是限定只有认证用户可以执行写操作。为了执行特定的限制，你可以使用<literal moreinfo=\"none\">Limit</literal>和<literal moreinfo=\"none\">LimitExcept</literal>配置指示，就像<literal moreinfo=\"none\">Location</literal>指示，这个区块有开始和结束标签，你需要在<literal moreinfo=\"none\">&lt;Location&gt;</literal>中添加这个指示。"

#: build/en/book.xml:14353(para)
msgid "The parameters present on the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> directives are HTTP request types that are affected by that block. For example, if you wanted to disallow all access to your repository except the currently supported read-only operations, you would use the <literal moreinfo=\"none\">LimitExcept</literal> directive, passing the <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PROPFIND</literal>, <literal moreinfo=\"none\">OPTIONS</literal>, and <literal moreinfo=\"none\">REPORT</literal> request type parameters. Then the previously mentioned <literal moreinfo=\"none\">Require valid-user</literal> directive would be placed inside the <literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal> block instead of just inside the <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr "在<literal moreinfo=\"none\">Limit</literal>和<literal moreinfo=\"none\">LimitExcept</literal>中使用的参数是可以被这个区块影响的HTTP请求类型，举个例子，如果你希望禁止所有的版本库访问，只是保留当前支持的只读操作，你可以使用<literal moreinfo=\"none\">LimitExcept</literal>指示，并且使用<literal moreinfo=\"none\">GET</literal>，<literal moreinfo=\"none\">PROPFIND</literal>，<literal moreinfo=\"none\">OPTIONS</literal>和<literal moreinfo=\"none\">REPORT</literal>请求类型参数，然后前面提到过的<literal moreinfo=\"none\">Require valid-user</literal>指示将会在<literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal>区块中而不是在<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块。"

#: build/en/book.xml:1436(para)
#, fuzzy
msgid "But there are some nuances in Subversion's handling of URLs that are notable. For example, URLs containing the <literal moreinfo=\"none\">file://</literal> access method (used for local repositories) must, in accordance with convention, have either a server name of <literal moreinfo=\"none\">localhost</literal> or no server name at all:"
msgstr "但是Subversion处理URL的一些细微的不同之处需要注意，例如，使用<literal moreinfo=\"none\">file:</literal>访问方法的URL（用来访问本地版本库）必须与习惯一致，可以包括一个<literal moreinfo=\"none\">localhost</literal>服务器名或者没有服务器名："

#: build/en/book.xml:14367(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # For any operations other than these, require an authenticated user.\n"
"  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n"
"    Require valid-user\n"
"  &lt;/LimitExcept&gt;\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # For any operations other than these, require an authenticated user.\n"
"  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n"
"    Require valid-user\n"
"  &lt;/LimitExcept&gt;\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14384(para)
msgid "These are only a few simple examples. For more in-depth information about Apache access control and the <literal moreinfo=\"none\">Require</literal> directive, take a look at the <literal moreinfo=\"none\">Security</literal> section of the Apache documentation's tutorials collection at <ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>."
msgstr "这里只是一些简单的例子，想看关于Apache访问控制<literal moreinfo=\"none\">Require</literal>指示的更深入信息，可以查看Apache文档中的教程集<ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>中的<literal moreinfo=\"none\">Security</literal>部分。"

#: build/en/book.xml:14395(title)
msgid "Per-Directory Access Control"
msgstr "每目录访问控制"

#: build/en/book.xml:14397(para)
msgid "It's possible to set up finer-grained permissions using a second Apache httpd module, <command moreinfo=\"none\">mod_authz_svn</command>. This module grabs the various opaque URLs passing from client to server, asks <command moreinfo=\"none\">mod_dav_svn</command> to decode them, and then possibly vetoes requests based on access policies defined in a configuration file."
msgstr "也可以使用Apache的httpd模块<command moreinfo=\"none\">mod_authz_svn</command>更加细致的设置访问权限，这个模块收集客户端传递过来的不同的晦涩的URL信息，询问<command moreinfo=\"none\">mod_dav_svn</command>来解码，然后根据在配置文件定义的访问政策来裁决请求。"

#: build/en/book.xml:14405(para)
msgid "If you've built Subversion from source code, <command moreinfo=\"none\">mod_authz_svn</command> is automatically built and installed alongside <command moreinfo=\"none\">mod_dav_svn</command>. Many binary distributions install it automatically as well. To verify that it's installed correctly, make sure it comes right after <command moreinfo=\"none\">mod_dav_svn</command>'s <literal moreinfo=\"none\">LoadModule</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename>:"
msgstr "如果你从源代码创建Subversion，<command moreinfo=\"none\">mod_authz_svn</command>会自动附加到<command moreinfo=\"none\">mod_dav_svn</command>，许多二进制分发版本也会自动安装，为了验证它是安装正确，确定它是在<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">LoadModule</literal>指示中的<command moreinfo=\"none\">mod_dav_svn</command>后面："

#: build/en/book.xml:14414(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
"LoadModule authz_svn_module   modules/mod_authz_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
"LoadModule authz_svn_module   modules/mod_authz_svn.so\n"

#: build/en/book.xml:14420(para)
msgid "To activate this module, you need to configure your <literal moreinfo=\"none\">Location</literal> block to use the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive, which specifies a file containing the permissions policy for paths within your repositories. (In a moment, we'll discuss the format of that file.)"
msgstr "为了激活这个模块，你需要配置你的<literal moreinfo=\"none\">Location</literal>区块的<literal moreinfo=\"none\">AuthzSVNAccessFile</literal>指示，指定保存路径中的版本库访问政策的文件。（一会儿我们将会讨论这个文件的格式。）"

#: build/en/book.xml:14427(para)
msgid "Apache is flexible, so you have the option to configure your block in one of three general patterns. To begin, choose one of these basic configuration patterns. (The examples below are very simple; look at Apache's own documentation for much more detail on Apache authentication and authorization options.)"
msgstr "Apache非常的灵活，你可以从三种模式里选择一种来配置你的区块，作为开始，你选择一种基本的配置模式。（下面的例子非常简单；见Apache自己的文档中的认证和授权选项来查看更多的细节。）"

#: build/en/book.xml:1443(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///path/to/repos\n"
"…\n"
"$ svn checkout file://localhost/path/to/repos\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout file:///path/to/repos\n"
"…\n"
"$ svn checkout file://localhost/path/to/repos\n"
"…\n"

#: build/en/book.xml:14434(para)
msgid "The simplest block is to allow open access to everyone. In this scenario, Apache never sends authentication challenges, so all users are treated as <quote>anonymous</quote>."
msgstr "最简单的区块是允许任何人可以访问，在这个场景里，Apache决不会发送认证请求，所有的用户作为<quote>匿名</quote>对待。"

#: build/en/book.xml:14440(title)
msgid "A sample configuration for anonymous access."
msgstr "匿名访问的配置实例。"

#: build/en/book.xml:14441(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14452(para)
msgid "On the opposite end of the paranoia scale, you can configure your block to demand authentication from everyone. All clients must supply credentials to identify themselves. Your block unconditionally requires authentication via the <literal moreinfo=\"none\">Require valid-user</literal> directive, and defines a means to authenticate."
msgstr "在另一个极端，你可以配置为拒绝所有人的认证，所有客户端必须提供证明自己身份的证书，你通过<literal moreinfo=\"none\">Require valid-user</literal>指示来阻止无条件的认证，并且定义一种认证的手段。"

#: build/en/book.xml:14460(title)
msgid "A sample configuration for authenticated access."
msgstr "一个认证访问的配置实例。"

#: build/en/book.xml:14461(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14480(para)
msgid "A third very popular pattern is to allow a combination of authenticated and anonymous access. For example, many administrators want to allow anonymous users to read certain repository directories, but want only authenticated users to read (or write) more sensitive areas. In this setup, all users start out accessing the repository anonymously. If your access control policy demands a real username at any point, Apache will demand authentication from the client. To do this, you use both the <literal moreinfo=\"none\">Satisfy Any</literal> and <literal moreinfo=\"none\">Require valid-user</literal> directives together."
msgstr "第三种流行的模式是允许认证和匿名用户的组合，举个例子，许多管理员希望允许匿名用户读取特定的版本库路径，但希望只有认证用户可以读（或者写）更多敏感的区域，在这个设置里，所有的用户开始时用匿名用户访问版本库，如果你的访问控制策略在任何时候要求一个真实的用户名，Apache将会要求认证客户端，为­¤，你可以同时使用<literal moreinfo=\"none\">Satisfy Any</literal>和<literal moreinfo=\"none\">Require valid-user</literal>指示。"

#: build/en/book.xml:14493(title)
msgid "A sample configuration for mixed authenticated/anonymous access."
msgstr "一个混合认证/匿名访问的配置实例。"

#: build/en/book.xml:14495(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # try anonymous access first, resort to real\n"
"  # authentication if necessary.\n"
"  Satisfy Any\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # try anonymous access first, resort to real\n"
"  # authentication if necessary.\n"
"  Satisfy Any\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:1450(para)
#, fuzzy
msgid "Also, users of the <literal moreinfo=\"none\">file://</literal> scheme on Windows platforms will need to use an unofficially <quote>standard</quote> syntax for accessing repositories that are on the same machine, but on a different drive than the client's current working drive. Either of the two following URL path syntaxes will work where <literal moreinfo=\"none\">X</literal> is the drive on which the repository resides:"
msgstr "同样在Windows平台下使用<literal moreinfo=\"none\">file:</literal>模式时需要使用一个非正式的<quote>标准</quote>语法来访问本机上不在同一个磁盘分区中的版本库。下面的任意一个URL路径语法都可以工作，其中的<literal moreinfo=\"none\">X</literal>表示版本库所在的磁盘分区："

#: build/en/book.xml:14516(para)
msgid "Once you've settled on one of these three basic <filename moreinfo=\"none\">httpd.conf</filename> templates, you need to create your file containing access rules for particular paths within the repository. This is described in <xref linkend=\"svn.serverconfig.pathbasedauthz\"/>."
msgstr ""

#: build/en/book.xml:14526(title)
msgid "Disabling Path-based Checks"
msgstr "关闭路径为基础的检查"

#: build/en/book.xml:14528(para)
msgid "The <command moreinfo=\"none\">mod_dav_svn</command> module goes through a lot of work to make sure that data you've marked <quote>unreadable</quote> doesn't get accidentally leaked. This means that it needs to closely monitor all of the paths and file-contents returned by commands like <command moreinfo=\"none\">svn checkout</command> or <command moreinfo=\"none\">svn update</command> commands. If these commands encounter a path that isn't readable according to some authorization policy, then the path is typically omitted altogether. In the case of history or rename tracing—e.g. running a command like <command moreinfo=\"none\">svn cat -r OLD foo.c</command> on a file that was renamed long ago—the rename tracking will simply halt if one of the object's former names is determined to be read-restricted."
msgstr "<command moreinfo=\"none\">mod_dav_svn</command>模块做了许多工作来确定你标记为<quote>不可读</quote>的数据不会因意外而泄露，这意味着需要紧密监控通过<command moreinfo=\"none\">svn checkout</command>或是<command moreinfo=\"none\">svn update</command>返回的路径和文件内容，如果这些命令遇到一些根据认证策略不是可读的路径，这个路径通常会被一起忽略，在历史或者重命名操作时—例如运行一个类似<command moreinfo=\"none\">svn cat -r OLD foo.c</command>的命令来操作一个很久以前改过名字的文件 — 如果一个对象的以前的名字检测到是只读的，重命令追踪就会终止。"

#: build/en/book.xml:14543(para)
#, fuzzy
msgid "All of this path-checking can sometimes be quite expensive, especially in the case of <command moreinfo=\"none\">svn log</command>. When retrieving a list of revisions, the server looks at every changed path in each revision and checks it for readability. If an unreadable path is discovered, then it's omitted from the list of the revision's changed paths (normally seen with the <option>--verbose</option> option), and the whole log message is suppressed. Needless to say, this can be time-consuming on revisions that affect a large number of files. This is the cost of security: even if you haven't configured a module like <command moreinfo=\"none\">mod_authz_svn</command> at all, the <command moreinfo=\"none\">mod_dav_svn</command> module is still asking Apache <command moreinfo=\"none\">httpd</command> to run authorization checks on every path. The <command moreinfo=\"none\">mod_dav_svn</command> module has no idea what authorization modules have been installed, so all it can do is ask Apache to invoke whatever might be present."
msgstr "所有的路径检查在有时会非常昂贵，特别是<command moreinfo=\"none\">svn log</command>的情况。当检索一列修订版本时，服务器会查看所有修订版本修改的路径，并且检查可读性，如果发现了一个不可读路径，它会从修订版本的修改路径中忽略（可以查看<option>--verbose</option>选项），并且整个的日志信息会被禁止，不必多说，这种影响大量文件修订版本的操作会非常耗时。这是安全的代价：即使你并没有配置<command moreinfo=\"none\">mod_authz_svn</command>模块，<command moreinfo=\"none\">mod_dav_svn</command>还是会询问<command moreinfo=\"none\">httpd</command>来对所有路径运行认证检查，<command moreinfo=\"none\">mod_dav_svn</command>模块没有办法知道那个认证模块被安装，所以只有询问Apache来调用所提供的模块。"

#: build/en/book.xml:14562(para)
msgid "On the other hand, there's also an escape-hatch of sorts, one which allows you to trade security features for speed. If you're not enforcing any sort of per-directory authorization (i.e. not using <command moreinfo=\"none\">mod_authz_svn</command> or similar module), then you can disable all of this path-checking. In your <filename moreinfo=\"none\">httpd.conf</filename> file, use the <literal moreinfo=\"none\">SVNPathAuthz</literal> directive:"
msgstr "在另一方面，也有一个安全舱门允许你用安全特性来交换速度，如果你不是坚持要求有每目录授权（如不使用 <command moreinfo=\"none\">mod_authz_svn</command>和类似的模块），你就可以关闭所有的路径检查，在你的<filename moreinfo=\"none\">httpd.conf</filename>文件，使用<literal moreinfo=\"none\">SVNPathAuthz</literal>指示："

#: build/en/book.xml:14572(title)
msgid "Disabling path checks altogether"
msgstr "关闭所有的路经检查"

#: build/en/book.xml:14573(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  SVNPathAuthz off\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  SVNPathAuthz off\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14583(para)
msgid "The <literal moreinfo=\"none\">SVNPathAuthz</literal> directive is <quote>on</quote> by default. When set <quote>off</quote>, all path-based authorization checking is disabled; <command moreinfo=\"none\">mod_dav_svn</command> stops invoking authorization checks on every path it discovers."
msgstr "<literal moreinfo=\"none\">SVNPathAuthz</literal>指示缺省是<quote>on</quote>，当设置为<quote>off</quote>时，所有的路径为基础的授权都会关闭；<command moreinfo=\"none\">mod_dav_svn</command>停止对每个目录调用授权检查。"

#: build/en/book.xml:1459(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; svn checkout file:///X:/path/to/repos\n"
"…\n"
"C:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n"
"…\n"
msgstr ""
"\n"
"C:\\&gt; svn checkout file:///X:/path/to/repos\n"
"…\n"
"C:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n"
"…\n"

#: build/en/book.xml:14595(title)
msgid "Extra Goodies"
msgstr "额外的糖果"

#: build/en/book.xml:14597(para)
msgid "We've covered most of the authentication and authorization options for Apache and mod_dav_svn. But there are a few other nice features that Apache provides."
msgstr "我们已经覆盖了关于认证和授权的Apache和mod_dav_svn的大多数选项，但是Apache还提供了许多很好的特性。"

#: build/en/book.xml:14603(title)
msgid "Repository Browsing"
msgstr "版本库浏览"

#: build/en/book.xml:14605(para)
#, fuzzy
msgid "One of the most useful benefits of an Apache/WebDAV configuration for your Subversion repository is that the youngest revisions of your versioned files and directories are immediately available for viewing via a regular web browser. Since Subversion uses URLs to identify versioned resources, those URLs used for HTTP-based repository access can be typed directly into a Web browser. Your browser will issue an HTTP <literal moreinfo=\"none\">GET</literal> request for that URL, and based on whether that URL represents a versioned directory or file, mod_dav_svn will respond with a directory listing or with file contents."
msgstr "一个非常有用的好处是使用Apache/WebDAV配置Subversion版本库时可以用普通的浏览器察看最新的版本库文件，因为Subversion使用URL来鉴别版本库版本化的资源，版本库使用的HTTP为基础的URL也可以直接输入到Web浏览器中，你的浏览器会发送一个<literal moreinfo=\"none\">GET</literal>请求到URL，根据访问的URL是指向一个版本化的目录还是文件，mod_dav_svn会负责列出目录列表或者是文件内容。"

#: build/en/book.xml:14617(para)
msgid "Since the URLs do not contain any information about which version of the resource you wish to see, mod_dav_svn will always answer with the youngest version. This functionality has the wonderful side-effect that you can pass around Subversion URLs to your peers as references to documents, and those URLs will always point at the latest manifestation of that document. Of course, you can even use the URLs as hyperlinks from other web sites, too."
msgstr "因为URL不能确定你所希望看到的资源的版本，mod_dav_svn会一直返回最新的版本，这样会有一些美妙的副作用，你可以直接把Subversion的URL传递给文档作为引用，这些URL会一直指向文档最新的材料，当然，你也可以在别的网站作为超链使用这些URL。"

#: build/en/book.xml:14627(title)
msgid "Can I view older revisions?"
msgstr "我可以看到老的修订版本吗？"

#: build/en/book.xml:14629(para)
msgid "With an ordinary web browser? In one word: nope. At least, not with <command moreinfo=\"none\">mod_dav_svn</command> as your only tool."
msgstr "通过一个普通的浏览器？一句话：不可以，至少是当你只使用<command moreinfo=\"none\">mod_dav_svn</command>作为唯一的工具时。"

#: build/en/book.xml:14633(para)
#, fuzzy
msgid "Your web browser only speaks ordinary HTTP. That means it only knows how to GET public URLs, which represent the latest versions of files and directories. According to the WebDAV/DeltaV specification, each server defines a private URL syntax for older versions of resources, and that syntax is opaque to clients. To find an older version of a file, a client must follow a specific procedure to <quote>discover</quote> the proper URL; the procedure involves issuing a series of WebDAV PROPFIND requests and understanding DeltaV concepts. This is something your web browser simply can't do."
msgstr "你的Web浏览器只会说普通的HTTP，也就是说它只会GET公共的URL，这个URL代表了最新版本的文件和目录，根据WebDAV/DeltaV规范，每种服务器定义了一种私有的URL语法来代表老的资源的版本，这个语法对客户端是不透明的，为了得到老的版本，一个客户端必须通过一种规范过程来<quote>发现</quote>正确的URL；这个过程包括执行一系列WebDAV PROPFIND请求和理解DeltaV概念，这些事情一般是你的web浏览器做不了的。"

#: build/en/book.xml:14645(para)
#, fuzzy
msgid "So to answer the question, one obvious way to see older revisions of files and directories is by passing the <option>--revision (-r)</option> argument to the <command moreinfo=\"none\">svn list</command> and <command moreinfo=\"none\">svn cat</command> commands. To browse old revisions with your web browser, however, you can use third-party software. A good example of this is ViewVC (<ulink url=\"http://viewvc.tigris.org/\"/>). ViewVC was originally written to display CVS repositories through the web, <placeholder-1/> and the latest releases are able to understand Subversion repositories as well."
msgstr "为了回答这些问题，一个明显的看老版本文件和目录的方式是带<option>--revision</option>参数的<command moreinfo=\"none\">svn list</command>和<command moreinfo=\"none\">svn cat</command>命令，为了在浏览器里察看老版本，你可以使用第三方的软件，一个好的例子是ViewVC（<ulink url=\"http://viewvc.tigris.org/\"/>），ViewVC最初写出来是为了在web显示CVS版本库，<footnote><placeholder-1/></footnote>最新的带血的（此时正在编写）版本也已经可以理解Subversion版本库了。"

#: build/en/book.xml:14656(para)
msgid "Back then, it was called <quote>ViewCVS</quote>."
msgstr "之前叫做<quote>ViewCVS</quote>。"

#: build/en/book.xml:1466(para)
#, fuzzy
msgid "In the second syntax, you need to quote the URL so that the vertical bar character is not interpreted as a pipe. Also, note that a URL uses forward slashes even though the native (non-URL) form of a path on Windows uses backslashes."
msgstr "在第二个语法，你需要使用引号包含整个URL，这样竖线字符才不会被解释为管道。当然，注意URL使用普通的斜线而不是Windows本地（不是URL）的反斜线。"

#: build/en/book.xml:14663(title)
msgid "Proper MIME Type"
msgstr ""

#: build/en/book.xml:14665(para)
msgid "When browsing a Subversion repository, the web browser gets a clue about how to render a file's contents by looking at the <literal moreinfo=\"none\">Content-Type:</literal> header returned in Apache's response to the HTTP <literal moreinfo=\"none\">GET</literal> request. The value of this header is some sort of MIME type. By default, Apache will tell the web browsers that all repository files are of the <quote>default</quote> MIME type, typically <literal moreinfo=\"none\">text/plain</literal>. This can be frustrating, however, if a user wishes repository files to render as something more meaningful — for example, it might be nice to have a <filename moreinfo=\"none\">foo.html</filename> file in the repository actually render as HTML when browsing."
msgstr ""

#: build/en/book.xml:14680(para)
msgid "To make this happen, you only need to make sure that your files have the proper <literal moreinfo=\"none\">svn:mime-type</literal> set. This is discussed in more detail in <xref linkend=\"svn.advanced.props.special.mime-type\"/>, and you can even configure your client to automatically attach proper <literal moreinfo=\"none\">svn:mime-type</literal> properties to files entering the repository for the first time; see <xref linkend=\"svn.advanced.props.auto\"/>."
msgstr ""

#: build/en/book.xml:14690(para)
msgid "So in our example, if one were to set the <literal moreinfo=\"none\">svn:mime-type</literal> property to <literal moreinfo=\"none\">text/html</literal> on file <filename moreinfo=\"none\">foo.html</filename>, then Apache would properly tell your web browser to render the file as HTML. One could also attach proper <literal moreinfo=\"none\">image/*</literal> mime-type properties to images, and by doing this, ultimately get an entire web site to be viewable directly from a repository! There's generalyl no problem with doing this, as long as the website doesn't contain any dynamically-generated content."
msgstr ""

#: build/en/book.xml:14706(title)
msgid "Customizing the Look"
msgstr ""

#: build/en/book.xml:14708(para)
msgid "You generally will get more use out of URLs to versioned files—after all, that's where the interesting content tends to lie. But you might have occasion to browse a Subversion directory listing, where you'll quickly note that the generated HTML used to display that listing is very basic, and certainly not intended to be aesthetically pleasing (or even interesting). To enable customization of these directory displays, Subversion provides an XML index feature. A single <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive in your repository's <literal moreinfo=\"none\">Location</literal> block of <filename moreinfo=\"none\">httpd.conf</filename> will instruct mod_dav_svn to generate XML output when displaying a directory listing, and to reference the XSLT stylesheet of your choice:"
msgstr "你通常会在版本化的文件的URL之外得到更多地用处—毕竟那里是有趣的内容存在的地方，但是你会偶尔浏览一个Subversion的目录列表，你会很快发现展示列表生成的HTML非常基本，并且一定没有在外观上（或者是有趣上）下功夫，为了自定义这些目录显示，Subversion提供了一个XML目录特性，一个单独的<literal moreinfo=\"none\">SVNIndexXSLT</literal>指示在你的<filename moreinfo=\"none\">httpd.conf</filename>文件版本库的<literal moreinfo=\"none\">Location</literal>块里，它将会指导mod_dav_svn在显示目录列表的时候生成XML输出，并且引用你选择的XSLT样式表文件："

#: build/en/book.xml:1472(para)
#, fuzzy
msgid "Subversion's <literal moreinfo=\"none\">file://</literal> URLs cannot be used in a regular web browser the way typical <literal moreinfo=\"none\">file://</literal> URLs can. When you attempt to view a <literal moreinfo=\"none\">file://</literal> URL in a regular web browser, it reads and displays the contents of the file at that location by examining the filesystem directly. However, Subversion's resources exist in a virtual filesystem (see <xref linkend=\"svn.developer.layerlib.repos\"/>), and your browser will not understand how to interact with that filesystem."
msgstr "也必须意识到Subversion的<literal moreinfo=\"none\">file:</literal> URL不能和在普通的web服务器中的<literal moreinfo=\"none\">file:</literal> URL一样工作。当你尝试在web服务器查看一个<literal moreinfo=\"none\">file:</literal>的URL，它会通过直接检测文件系统读取和显示那个位置的文件内容，但是Subversion的资源存在于虚拟文件系统（见<xref linkend=\"svn.developer.layerlib.repos\"/>）中，你的浏览器不会理解怎样读取这个文件系统。"

#: build/en/book.xml:14724(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNIndexXSLT \"/svnindex.xsl\"\n"
"  …\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNIndexXSLT \"/svnindex.xsl\"\n"
"  …\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14733(para)
msgid "Using the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive and a creative XSLT stylesheet, you can make your directory listings match the color schemes and imagery used in other parts of your website. Or, if you'd prefer, you can use the sample stylesheets provided in the Subversion source distribution's <filename moreinfo=\"none\">tools/xslt/</filename> directory. Keep in mind that the path provided to the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directory is actually a URL path—browsers need to be able to read your stylesheets in order to make use of them!"
msgstr "使用<literal moreinfo=\"none\">SVNIndexXSLT</literal>指示和创建一个XSLT样式表，你可以让你的目录列表的颜色模式与你的网站的其它部分匹配，否则，如果你愿意，你可以使用Subversion源分发版本中的<filename moreinfo=\"none\">tools/xslt/</filename>目录下的样例样式表。记住提供给<literal moreinfo=\"none\">SVNIndexXSLT</literal> 指示的路径是一个URL路径—浏览器需要阅读你的样式表来利用它们！"

#: build/en/book.xml:14747(title)
#, fuzzy
msgid "Listing Repositories"
msgstr "版本库的移植"

#: build/en/book.xml:14749(para)
msgid "If you're serving a colllection of repositories from a single URL via the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's also possible to have Apache display all available repositories to a web browser. Just activate the <literal moreinfo=\"none\">SVNListParentPath</literal> directive:"
msgstr ""

#: build/en/book.xml:14756(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNListParentPath on\n"
"  …\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNListParentPath on\n"
"  …\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14765(para)
msgid "If a user now points her web browser to the URL <literal moreinfo=\"none\">http://host.example.com/svn/</literal>, she'll see list of all Subversion repositories sitting in <filename moreinfo=\"none\">/usr/local/svn</filename>. Obviously, this can be a security problem, so this feature is turned off by default."
msgstr ""

#: build/en/book.xml:14778(title)
msgid "Apache Logging"
msgstr ""

#: build/en/book.xml:14780(para)
msgid "Because Apache is an HTTP server at heart, it contains fantastically flexible logging feature. It's beyond the scope of this book to discuss all ways logging can be configured, but we should point out that even the most generic <filename moreinfo=\"none\">httpd.conf</filename> file will cause Apache to produce two logs: <filename moreinfo=\"none\">error_log</filename> and <filename moreinfo=\"none\">access_log</filename>. These logs may appear in different places, but are typically created in the logging area of your Apache installation. (On Unix, they often live in <filename moreinfo=\"none\">/usr/local/apache2/logs/</filename>.)"
msgstr ""

#: build/en/book.xml:14793(para)
msgid "The <filename moreinfo=\"none\">error_log</filename> describes any interal errors that Apache runs into as it works. The <filename moreinfo=\"none\">access_log</filename> file records every incoming HTTP request received by Apache. This makes it easy to see, for example, which IP addresses Subversion clients are coming from, how often particular clients use the server, which users are authenticating properly, and which requests succeed or fail."
msgstr ""

#: build/en/book.xml:148(para)
#, fuzzy
msgid "During the entire time they wrote this book, Ben, Mike, and Brian haunted the Subversion mailing lists and chat rooms incessantly, carefully noting the problems users were having in real-life situations. Monitoring such feedback was part of their job descriptions at CollabNet anyway, and it gave them a huge advantage when they set out to document Subversion. The book they produced is grounded firmly in the bedrock of experience, not in the shifting sands of wishful thinking; it combines the best aspects of user manual and FAQ sheet. This duality might not be noticeable on a first reading. Taken in order, front to back, the book is simply a straightforward description of a piece of software. There's the overview, the obligatory guided tour, the chapter on administrative configuration, some advanced topics, and of course a command reference and troubleshooting guide. Only when you come back to it later, seeking the solution to some specific problem, does its authenticity shine out: the telling details that can only result from encounters with the unexpected, the examples honed from genuine use cases, and most of all the sensitivity to the user's needs and the user's point of view."
msgstr "在写这本书的过程里，Ben，Mike 和 Brian一直像鬼魂一样游荡在Subversion邮件列表和聊天室中，仔细的研究用户实际遇到的问题。监视这些反馈是他们在CollabNet工作的一部分，这给他们撰写Subversion文档提供了巨大的便利。这本书建立在丰富的使用经验，而非在流沙般脆弱的想象之上，它结合了用户手册和FAQ的优点。初次阅读时，这种二元性的优势并不明显，按照顺序，从前到后，这本书只是简单的从头到尾描述了软件的细节。书中的内容包括一章概述，一章必不可少的快速指南，一章关于管理配置，一些高级主题，当然还包括命令参考手册和故障排除指南。而当你过一段时间之后，再次翻开本书查找一些特定问题的解决方案时，这种二元性才得以显现：这些生动的细节一定来自不可预测的实际用例的提炼，大多是源于用户的需要和视点。"

#: build/en/book.xml:14802(para)
msgid "Unfortunately, because HTTP is a stateless protocol, even the simplest Subversion client operation generates multiple network requests. It's very difficult to look at the <filename moreinfo=\"none\">access_log</filename> and deduce what the client was doing — most operations look like a series of cryptic <literal moreinfo=\"none\">PROPPATCH</literal>, <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PUT</literal>, and <literal moreinfo=\"none\">REPORT</literal> requests. To make things worse, many client operations send nearly-identical series of requests, so it's even harder to tell them apart."
msgstr ""

#: build/en/book.xml:14813(para)
msgid "<literal moreinfo=\"none\">mod_dav_svn</literal>, however, can come to your aid. By activating an <quote>operational logging</quote> feature, you can ask <literal moreinfo=\"none\">mod_dav_svn</literal> to create a separate log file describing what sort of high-level operations your clients are performing."
msgstr ""

#: build/en/book.xml:14820(para)
msgid "To do this, you need to make use of Apache's <literal moreinfo=\"none\">CustomLog</literal> directive (which is explained in more detail in Apache's own documentation). Be sure to invoke this directive <emphasis>outside</emphasis> of your Subversion <literal moreinfo=\"none\">Location</literal> block:"
msgstr ""

#: build/en/book.xml:14827(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  …\n"
"&lt;/Location&gt;\n"
"\n"
"CustomLog logs/svn_logfile \"%t %u %{SVN-ACTION}e\" env=SVN-ACTION\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  …\n"
"&lt;/Location&gt;\n"
"\n"
"CustomLog logs/svn_logfile \"%t %u %{SVN-ACTION}e\" env=SVN-ACTION\n"

#: build/en/book.xml:1483(para)
msgid "Finally, it should be noted that the Subversion client will automatically encode URLs as necessary, just like a web browser does. For example, if a URL contains a space or upper-ASCII character:"
msgstr "最后，必须注意Subversion的客户端会根据需要自动编码URL，这一点和一般的web浏览器一样，举个例子，如果一个URL包含了空格或是一个字符编码大于128的ASCII字符："

#: build/en/book.xml:14836(para)
msgid "In this example, we're asking Apache to create a special logfile <filename moreinfo=\"none\">svn_logfile</filename> in the standard Apache <filename moreinfo=\"none\">logs</filename> directory. The <literal moreinfo=\"none\">%t</literal> and <literal moreinfo=\"none\">%u</literal> variables are replaced by the time and username of the request, respectively. The really important part are the two instances of <literal moreinfo=\"none\">SVN-ACTION</literal>. When Apache sees that variable, it substitutes the value of the <literal moreinfo=\"none\">SVN-ACTION</literal> environment variable, which is automatically set by <literal moreinfo=\"none\">mod_dav_svn</literal> whenever it detects a high-level client action."
msgstr ""

#: build/en/book.xml:14848(para)
#, fuzzy
msgid "So instead of having to interpret a traditional <filename moreinfo=\"none\">access_log</filename> like this:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:14852(screen)
#, no-wrap
msgid ""
"\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1\" 207 398\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1\" 207 449\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc HTTP/1.1\" 207 647\n"
"[26/Jan/2007:22:25:29 -0600] \"REPORT /svn/calc/!svn/vcc/default HTTP/1.1\" 200 607\n"
"[26/Jan/2007:22:25:31 -0600] \"OPTIONS /svn/calc HTTP/1.1\" 200 188\n"
"[26/Jan/2007:22:25:31 -0600] \"MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1\" 201 227\n"
"…\n"
msgstr ""
"\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1\" 207 398\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1\" 207 449\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc HTTP/1.1\" 207 647\n"
"[26/Jan/2007:22:25:29 -0600] \"REPORT /svn/calc/!svn/vcc/default HTTP/1.1\" 200 607\n"
"[26/Jan/2007:22:25:31 -0600] \"OPTIONS /svn/calc HTTP/1.1\" 200 188\n"
"[26/Jan/2007:22:25:31 -0600] \"MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1\" 201 227\n"
"…\n"

#: build/en/book.xml:14862(para)
#, fuzzy
msgid "… you can instead peruse a much more intelligible <filename moreinfo=\"none\">svn_logfile</filename> like this:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:14865(screen)
#, no-wrap
msgid ""
"\n"
"[26/Jan/2007:22:24:20 -0600] - list-dir '/'\n"
"[26/Jan/2007:22:24:27 -0600] - update '/'\n"
"[26/Jan/2007:22:25:29 -0600] - remote-status '/'\n"
"[26/Jan/2007:22:25:31 -0600] sally commit r60\n"
msgstr ""
"\n"
"[26/Jan/2007:22:24:20 -0600] - list-dir '/'\n"
"[26/Jan/2007:22:24:27 -0600] - update '/'\n"
"[26/Jan/2007:22:25:29 -0600] - remote-status '/'\n"
"[26/Jan/2007:22:25:31 -0600] sally commit r60\n"

#: build/en/book.xml:14876(title)
msgid "Other Features"
msgstr "其它特性"

#: build/en/book.xml:14878(para)
#, fuzzy
msgid "Several of the features already provided by Apache in its role as a robust Web server can be leveraged for increased functionality or security in Subversion as well. Subversion communicates with Apache using Neon, which is a generic HTTP/WebDAV library with support for such mechanisms as SSL (the Secure Socket Layer, discussed earlier). If your Subversion client is built to support SSL, then it can access your Apache server using <literal moreinfo=\"none\">https://</literal>."
msgstr "Apache作为一个健壮的Web服务器的许多特性也可以用来增加Subversion的功能性和安全性，Subversion使用Neon与Apache通讯，这是一种一般的HTTP/WebDAV库，可以支持SSL和Deflate压缩（是<command moreinfo=\"none\">gzip</command>和<command moreinfo=\"none\">PKZIP</command>程序用来<quote>压缩</quote>文件为数据块的一样的算法）之类的机制。你只需要编译你希望Subversion和Apache需要的特性，并且正确的配置程序来使用这些特性。"

#: build/en/book.xml:1488(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout \"http://host/path with space/project/españa\"\n"
msgstr ""
"\n"
"$ svn checkout \"http://host/path with space/project/españa\"\n"

#: build/en/book.xml:14888(para)
#, fuzzy
msgid "Equally useful are other features of the Apache and Subversion relationship, such as the ability to specify a custom port (instead of the default HTTP port 80) or a virtual domain name by which the Subversion repository should be accessed, or the ability to access the repository through an HTTP proxy. These things are all supported by Neon, so Subversion gets that support for free."
msgstr "不怎么有趣，但同样重要，是Apache和Subversion关系的一些特性，像可以指定自定义的端口（而不是缺省的HTTP的80）或者是一个Subversion可以被访问的虚拟主机名，或者是通过代理服务器访问的能力，这些特性都是Neon所支持的，所以Subversion轻易得到这些支持。"

#: build/en/book.xml:14896(para)
#, fuzzy
msgid "Finally, because <command moreinfo=\"none\">mod_dav_svn</command> is speaking a subset of the WebDAV/DeltaV protocol, it's possible to access the repository via third-party DAV clients. Most modern operating systems (Win32, OS X, and Linux) have the built-in ability to mount a DAV server as a standard network share. This is a complicated topic; for details, read <xref linkend=\"svn.webdav\"/>."
msgstr "最后，因为<command moreinfo=\"none\">mod_dav_svn</command>是使用一个半完成的WebDAV/DeltaV方言，所以通过第三方的DAV客户端访问也是可能的，几乎所有的现代操作系统（Win32、OS X和Linux）都有把DAV服务器影射为普通的网络<quote>共享</quote>的内置能力，这是一个复杂的主题；察看<xref linkend=\"svn.webdav\"/>来得到更多细节。"

#: build/en/book.xml:14915(title)
msgid "Path-Based Authorization"
msgstr "基于路径的授权"

#: build/en/book.xml:14917(para)
msgid "Both Apache and <command moreinfo=\"none\">svnserve</command> are capable of granting (or denying) permissions to users. Typically this is done over the entire repository: a user can read the repository (or not), and she can write to the repository (or not). It's also possible, however, to define finer-grained access rules. One set of users may have permssion to write to a certain directory in the repository, but not others; another directory might not even be readable by all but a few special people."
msgstr ""

#: build/en/book.xml:1492(para)
msgid "…then Subversion will escape the unsafe characters and behave as if you had typed:"
msgstr "…Subversion会回避这些不安全字符，并且会像你输入了这些字符一样工作："

#: build/en/book.xml:14927(para)
msgid "Both servers use a common file format to describe these path-based access rules. In the case of Apache, one needs to load the <command moreinfo=\"none\">mod_authz_svn</command> module and then add the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive (within the <filename moreinfo=\"none\">httpd.conf</filename> file) pointing to your own rules-file. (For a full explanation, see <xref linkend=\"svn.serverconfig.httpd.authz.perdir\"/>.) If you're using <command moreinfo=\"none\">svnserve</command>, then you need to make the <literal moreinfo=\"none\">authz-db</literal> variable (within <filename moreinfo=\"none\">svnserve.conf</filename>) point to your rules-file."
msgstr ""

#: build/en/book.xml:14940(title)
msgid "Do you really need path-based access control?"
msgstr ""

#: build/en/book.xml:14942(para)
msgid "A lot of administrators setting up Subversion for the first time tend to jump into path-based access control without giving it a lot of thought. The administrator usually knows which teams of people are working on which projects, so it's easy to jump in and grant certain teams access to certain directories and not others. It seems like a natural thing, and it appeases the administrator's desire to maintain tight control of the repository."
msgstr ""

#: build/en/book.xml:1495(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"
msgstr ""
"\n"
"$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"

#: build/en/book.xml:14951(para)
msgid "Note, though, that there are often invisible (and visible!) costs associated with this feature. In the visible category, the server needs to do a lot more work to ensure that the user has the right to read or write each specific path; in certain situations, there's very noticeable performance loss. In the invisible category, consider the culture you're creating. Most of the time, while certain users <emphasis>shouldn't</emphasis> be committing changes to certain parts of the repository, that social contract doesn't need to be technologically enforced. Teams can sometimes spontaneously collaborate with each other; someone may want to help someone else out by committing to an area she doesn't normally work on. By preventing this sort of thing at the server level, you're setting up barriers to unexpected collaboration. You're also creating a bunch of rules that need to be maintained as projects develop, new users are added, and so on. It's a bunch of extra work to maintain."
msgstr ""

#: build/en/book.xml:14970(para)
msgid "Remember that this is a version control system! Even if somebody accidentally commits a change to something they shouldn't, it's easy to undo the change. And if a user commits to the wrong place with deliberate malice, then it's a social problem anyway, and that the problem needs to be dealt with outside of Subversion."
msgstr ""

#: build/en/book.xml:14977(para)
msgid "So before you begin restricting users' access rights, ask yourself if there's a real, honest need for this, or if it's just something that <quote>sounds good</quote> to an administrator. Decide whether it's worth sacrificing some server speed for, and remember that there's very little risk involved; it's bad to become dependent on technology as a crutch for social problems.<placeholder-1/>."
msgstr ""

#: build/en/book.xml:14983(para)
msgid "A common theme in this book!"
msgstr ""

#: build/en/book.xml:14986(para)
msgid "As an example to ponder, consider that the Subversion project itself has always had a notion of who is allowed to commit where, but it's always been enforced socially. This is a good model of community trust, especially for open-source projects. Of course, sometimes there <emphasis>are</emphasis> truly legitimate needs for path-based access control; within corporations, for example, certain types of data really can be sensitive, and access needs to be genuinely restricted to small groups of people."
msgstr ""

#: build/en/book.xml:1499(para)
msgid "If the URL contains spaces, be sure to place it within quote marks, so that your shell treats the whole thing as a single argument to the <command moreinfo=\"none\">svn</command> program."
msgstr "如果URL包含空格，一定要使用引号，这样你的脚本才会把它做一个单独的<command moreinfo=\"none\">svn</command>参数。"

#: build/en/book.xml:14998(para)
msgid "Once your server knows where to find your rules-file, it's time to define the rules."
msgstr ""

#: build/en/book.xml:15(isbn)
msgid "?-?????-???-?"
msgstr "?-?????-???-?"

#: build/en/book.xml:15001(para)
#, fuzzy
msgid "The syntax of the file is the same familiar one used by <command moreinfo=\"none\">svnserve.conf</command> and the runtime configuration files. Lines that start with a hash (<literal moreinfo=\"none\">#</literal>) are ignored. In its simplest form, each section names a repository and path within it, and the authenticated usernames are the option names within each section. The value of each option describes the user's level of access to the repository path: either <literal moreinfo=\"none\">r</literal> (read-only) or <literal moreinfo=\"none\">rw</literal> (read-write). If the user is not mentioned at all, no access is allowed."
msgstr "访问文件的语法与<command moreinfo=\"none\">svnserve.conf</command>和运行中配置文件非常相似，以（<literal moreinfo=\"none\">#</literal>）开头的行会被忽略，在它的简单形式里，每一小节命名一个版本库和一个里面的路径，认证用户名是在每个小节中的选项名，每个选项的值描述了用户访问版本库的级别：<literal moreinfo=\"none\">r</literal>（只读）或者<literal moreinfo=\"none\">rw</literal>（读写），如果用户没有提到，访问是不允许的。"

#: build/en/book.xml:15013(para)
msgid "To be more specific: the value of the section-names are either of the form <literal moreinfo=\"none\">[repos-name:path]</literal> or the form <literal moreinfo=\"none\">[path]</literal>. If you're using the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's important to specify the repository names in your sections. If you omit them, then a section like <literal moreinfo=\"none\">[/some/dir]</literal> will match the path <filename moreinfo=\"none\">/some/dir</filename> in <emphasis>every</emphasis> repository. If you're using the <literal moreinfo=\"none\">SVNPath</literal> directive, however, then it's fine to only define paths in your sections—after all, there's only one repository."
msgstr "具体一点：这个小节的名称是<literal moreinfo=\"none\">[repos-name:path]</literal>或者<literal moreinfo=\"none\">[path]</literal>的形式，如果你使用<literal moreinfo=\"none\">SVNParentPath</literal>指示，指定版本库的名字是很重要的，如果你漏掉了他们，<literal moreinfo=\"none\">[/some/dir]</literal>部分就会与<filename moreinfo=\"none\">/some/dir</filename>的所有版本库匹配，如果你使用<literal moreinfo=\"none\">SVNPath</literal>指示，因此在你的小节中只是定义路径也很好—毕竟只有一个版本库。"

#: build/en/book.xml:15025(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"

#: build/en/book.xml:15031(para)
msgid "In this first example, the user <literal moreinfo=\"none\">harry</literal> has full read and write access on the <filename moreinfo=\"none\">/branches/calc/bug-142</filename> directory in the <literal moreinfo=\"none\">calc</literal> repository, but the user <literal moreinfo=\"none\">sally</literal> has read-only access. Any other users are blocked from accessing this directory."
msgstr "在第一个例子里，用户<literal moreinfo=\"none\">harry</literal>对<literal moreinfo=\"none\">calc</literal>版本库中<filename moreinfo=\"none\">/branches/calc/bug-142</filename>具备完全的读写权利，但是用户<literal moreinfo=\"none\">sally</literal>只有读权利，任何其他用户禁止访问这个目录。"

#: build/en/book.xml:15038(para)
msgid "Of course, permissions are inherited from parent to child directory. That means that we can specify a subdirectory with a different access policy for Sally:"
msgstr "当然，访问控制是父目录传递给子目录的，这意味着我们可以为Sally指定一个子目录的不同访问策略："

#: build/en/book.xml:15042(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"# give sally write access only to the 'testing' subdir\n"
"[calc:/branches/calc/bug-142/testing]\n"
"sally = rw\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"# give sally write access only to the 'testing' subdir\n"
"[calc:/branches/calc/bug-142/testing]\n"
"sally = rw\n"

#: build/en/book.xml:15052(para)
msgid "Now Sally can write to the <filename moreinfo=\"none\">testing</filename> subdirectory of the branch, but can still only read other parts. Harry, meanwhile, continues to have complete read-write access to the whole branch."
msgstr "现在Sally可以读取分支的<filename moreinfo=\"none\">testing</filename>子目录，但对其他部分还是只可以读，同时，Harry对整个分支还继续有完全的读写权限。"

#: build/en/book.xml:15057(para)
msgid "It's also possible to explicitly deny permission to someone via inheritance rules, by setting the username variable to nothing:"
msgstr "也可以通过继承规则明确的的拒绝某人的访问，只需要设置用户名参数为空："

#: build/en/book.xml:15061(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"[calc:/branches/calc/bug-142/secret]\n"
"harry =\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"[calc:/branches/calc/bug-142/secret]\n"
"harry =\n"

#: build/en/book.xml:1507(title)
msgid "Working Copies"
msgstr "工作拷贝"

#: build/en/book.xml:15070(para)
msgid "In this example, Harry has read-write access to the entire <filename moreinfo=\"none\">bug-142</filename> tree, but has absolutely no access at all to the <filename moreinfo=\"none\">secret</filename> subdirectory within it."
msgstr "在这个例子里，Harry对<filename moreinfo=\"none\">bug-142</filename>目录树有完全的读写权限，但是对<filename moreinfo=\"none\">secret</filename>子目录没有任何访问权利。"

#: build/en/book.xml:15075(para)
#, fuzzy
msgid "The thing to remember is that the most specific path always matches first. The server tries to match the path itself, and then the parent of the path, then the parent of that, and so on. The net effect is that mentioning a specific path in the accessfile will always override any permissions inherited from parent directories."
msgstr "有一件事需要记住的是需要找到最匹配的目录，<command moreinfo=\"none\">mod_authz_svn</command>模块首先找到匹配自己的目录，然后父目录，然后父目录的父目录，就这样继续下去，更具体的路径控制会覆盖所有继承下来的访问控制。"

#: build/en/book.xml:15082(para)
msgid "By default, nobody has any access to the repository at all. That means that if you're starting with an empty file, you'll probably want to give at least read permission to all users at the root of the repository. You can do this by using the asterisk variable (<literal moreinfo=\"none\">*</literal>), which means <quote>all users</quote>:"
msgstr "缺省情况下，没有人对版本库有任何访问，这意味着如果你已经从一个空文件开始，你会希望给所有用户对版本库根目录具备读权限，你可以使用<literal moreinfo=\"none\">*</literal>实现，用来代表<quote>所有用户</quote>："

#: build/en/book.xml:15089(screen)
#, no-wrap
msgid ""
"\n"
"[/]\n"
"* = r\n"
msgstr ""
"\n"
"[/]\n"
"* = r\n"

#: build/en/book.xml:1509(para)
msgid "You've already read about working copies; now we'll demonstrate how the Subversion client creates and uses them."
msgstr "你已经阅读过了关于工作拷贝的内容，现在我们要讲一讲客户端怎样建立和使用它。"

#: build/en/book.xml:15094(para)
#, fuzzy
msgid "This is a common setup; notice that there's no repository name mentioned in the section name. This makes all repositories world readable to all users. Once all users have read-access to the repositories, you can give explicit <literal moreinfo=\"none\">rw</literal> permission to certain users on specific subdirectories within specific repositories."
msgstr "这是一个普通的设置；注意在小节名中没有提到版本库名称，这让所有版本库对所有的用户可读，不管你是使用<literal moreinfo=\"none\">SVNPath</literal>或是<literal moreinfo=\"none\">SVNParentPath</literal>。当所有用户对版本库有了读权利，你可以赋予特定用户对特定子目录的<literal moreinfo=\"none\">rw</literal>权限。"

#: build/en/book.xml:15101(para)
#, fuzzy
msgid "The asterisk variable (<literal moreinfo=\"none\">*</literal>) is also worth special mention here: it's the <emphasis>only</emphasis> pattern which matches an anonymous user. If you've configured your server block to allow a mixture of anonymous and authenticated access, all users start out accessing anonymously. The server looks for a <literal moreinfo=\"none\">*</literal> value defined for the path being accessed; if it can't find one, then it demands real authentication from the client."
msgstr "星号（<literal moreinfo=\"none\">*</literal>）参数需要在这里详细强调：这是匹配匿名用户的<emphasis>唯一</emphasis>模式，如果你已经配置了你的<literal moreinfo=\"none\">Location</literal>区块允许匿名和认证用户的混合访问，所有用户作为Apache匿名用户开始访问，<command moreinfo=\"none\">mod_authz_svn</command>会在要访问路径的定义中查找<literal moreinfo=\"none\">*</literal>值；如果找不到，Apache就会要求真实的客户端认证。"

#: build/en/book.xml:15111(para)
msgid "The access file also allows you to define whole groups of users, much like the Unix <filename moreinfo=\"none\">/etc/group</filename> file:"
msgstr "访问文件也允许你定义一组的用户，很像Unix的<filename moreinfo=\"none\">/etc/group</filename>文件："

#: build/en/book.xml:15115(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = harry, sally, joe, frank, sally, jane\n"
msgstr ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = harry, sally, joe, frank, sally, jane\n"

#: build/en/book.xml:15122(para)
msgid "Groups can be granted access control just like users. Distinguish them with an <quote>at</quote> (<literal moreinfo=\"none\">@</literal>) prefix:"
msgstr "组可以被赋予通用户一样的访问权限，使用<quote>at</quote>（<literal moreinfo=\"none\">@</literal>）前缀来加以区别："

#: build/en/book.xml:15126(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/projects/calc]\n"
"@calc-developers = rw\n"
"\n"
"[paint:/projects/paint]\n"
"@paint-developers = rw\n"
"jane = r\n"
msgstr ""
"\n"
"[calc:/projects/calc]\n"
"@calc-developers = rw\n"
"\n"
"[paint:/projects/paint]\n"
"@paint-developers = rw\n"
"jane = r\n"

#: build/en/book.xml:1513(para)
msgid "A Subversion working copy is an ordinary directory tree on your local system, containing a collection of files. You can edit these files however you wish, and if they're source code files, you can compile your program from them in the usual way. Your working copy is your own private work area: Subversion will never incorporate other people's changes, nor make your own changes available to others, until you explicitly tell it to do so. You can even have multiple working copies of the same project."
msgstr "一个Subversion工作拷贝是你本地机器一个普通的目录，保存着一些文件，你可以任意的编辑文件，而且如果是源代码文件，你可以像平常一样编译，你的工作拷贝是你的私有工作区，在你明确的做了特定操作之前，Subversion不会把你的修改与其他人的合并，也不会把你的修改展示给别人，你甚至可以拥有同一个项目的多个工作拷贝。"

#: build/en/book.xml:15135(para)
msgid "Groups can also be defined to contain other groups:"
msgstr "组中也可以定义为包含其它的组："

#: build/en/book.xml:15137(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = @calc-developers, @paint-developers\n"
msgstr ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = @calc-developers, @paint-developers\n"

#: build/en/book.xml:15152(title)
msgid "Supporting Multiple Repository Access Methods"
msgstr "支持多种版本库访问方法"

#: build/en/book.xml:15154(para)
msgid "You've seen how a repository can be accessed in many different ways. But is it possible—or safe—for your repository to be accessed by multiple methods simultaneously? The answer is yes, provided you use a bit of foresight."
msgstr "你已经看到了一个版本库可以用多种方式访问，但是可以—或者说安全的—用几种方式同时并行的访问你的版本库吗？回答是可以，倘若你有一些深谋远虑的使用。"

#: build/en/book.xml:15159(para)
msgid "At any given time, these processes may require read and write access to your repository:"
msgstr "在任何给定