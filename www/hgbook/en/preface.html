<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Preface</title>
<link rel="stylesheet" href="hgbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="index.html" title="Mercurial: The Definitive Guide">
<link rel="up" href="index.html" title="Mercurial: The Definitive Guide">
<link rel="prev" href="index.html" title="Mercurial: The Definitive Guide">
<link rel="next" href="a-tour-of-mercurial-the-basics.html" title="Chapter 1. A tour of Mercurial: the basics">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Preface</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="index.html">Prev</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="a-tour-of-mercurial-the-basics.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="preface" lang="en">
<div class="titlepage"><div><div><h2 class="title">
<a name="chap:preface"></a>Preface</h2></div></div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="preface.html#id506726">1. Why revision control? Why Mercurial?</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="preface.html#id490147">1.1. Why use revision control?</a></span></dt>
<dt><span class="sect2"><a href="preface.html#id467872">1.2. The many names of revision control</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="preface.html#id468502">2. This book is a work in progress</a></span></dt>
<dt><span class="sect1"><a href="preface.html#id468517">3. About the examples in this book</a></span></dt>
<dt><span class="sect1"><a href="preface.html#id468194">4. Trends in the field</a></span></dt>
<dt><span class="sect1"><a href="preface.html#id512343">5. A few of the advantages of distributed revision
      control</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="preface.html#id512390">5.1. Advantages for open source projects</a></span></dt>
<dt><span class="sect2"><a href="preface.html#id512508">5.2. Advantages for commercial projects</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="preface.html#id512545">6. Why choose Mercurial?</a></span></dt>
<dt><span class="sect1"><a href="preface.html#id512618">7. Mercurial compared with other tools</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="preface.html#id512631">7.1. Subversion</a></span></dt>
<dt><span class="sect2"><a href="preface.html#id512734">7.2. Git</a></span></dt>
<dt><span class="sect2"><a href="preface.html#id512788">7.3. CVS</a></span></dt>
<dt><span class="sect2"><a href="preface.html#id512840">7.4. Commercial tools</a></span></dt>
<dt><span class="sect2"><a href="preface.html#id512862">7.5. Choosing a revision control tool</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="preface.html#id512890">8. Switching from another tool to Mercurial</a></span></dt>
<dt><span class="sect1"><a href="preface.html#id512983">9. A short history of revision control</a></span></dt>
<dt><span class="sect1"><a href="preface.html#id513084">10. Colophon—this book is Free</a></span></dt>
</dl>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id506726"></a>1. Why revision control? Why Mercurial?</h2></div></div></div>
<p><a name="x_6d"></a>Revision control is the process of managing multiple
      versions of a piece of information.  In its simplest form, this
      is something that many people do by hand: every time you modify
      a file, save it under a new name that contains a number, each
      one higher than the number of the preceding version.</p>
<p><a name="x_6e"></a>Manually managing multiple versions of even a single file is
      an error-prone task, though, so software tools to help automate
      this process have long been available.  The earliest automated
      revision control tools were intended to help a single user to
      manage revisions of a single file.  Over the past few decades,
      the scope of revision control tools has expanded greatly; they
      now manage multiple files, and help multiple people to work
      together.  The best modern revision control tools have no
      problem coping with thousands of people working together on
      projects that consist of hundreds of thousands of files.</p>
<p><a name="x_6f"></a>The arrival of distributed revision control is relatively
      recent, and so far this new field has grown due to people's
      willingness to explore ill-charted territory.</p>
<p><a name="x_70"></a>I am writing a book about distributed revision control
      because I believe that it is an important subject that deserves
      a field guide. I chose to write about Mercurial because it is
      the easiest tool to learn the terrain with, and yet it scales to
      the demands of real, challenging environments where many other
      revision control tools buckle.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id490147"></a>1.1. Why use revision control?</h3></div></div></div>
<p><a name="x_71"></a>There are a number of reasons why you or your team might
	want to use an automated revision control tool for a
	project.</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_72"></a>It will track the history and evolution of
	    your project, so you don't have to.  For every change,
	    you'll have a log of <span class="emphasis"><em>who</em></span> made it;
	    <span class="emphasis"><em>why</em></span> they made it;
	    <span class="emphasis"><em>when</em></span> they made it; and
	    <span class="emphasis"><em>what</em></span> the change
	    was.</p></li>
<li><p><a name="x_73"></a>When you're working with other people,
	    revision control software makes it easier for you to
	    collaborate.  For example, when people more or less
	    simultaneously make potentially incompatible changes, the
	    software will help you to identify and resolve those
	    conflicts.</p></li>
<li><p><a name="x_74"></a>It can help you to recover from mistakes.  If
	    you make a change that later turns out to be in error, you
	    can revert to an earlier version of one or more files.  In
	    fact, a <span class="emphasis"><em>really</em></span> good revision control
	    tool will even help you to efficiently figure out exactly
	    when a problem was introduced (see <a class="xref" href="finding-and-fixing-mistakes.html#sec:undo:bisect" title="8.5. Finding the source of a bug">Section 8.5, “Finding the source of a bug”</a> for details).</p></li>
<li><p><a name="x_75"></a>It will help you to work simultaneously on,
	    and manage the drift between, multiple versions of your
	    project.</p></li>
</ul></div>
<p><a name="x_76"></a>Most of these reasons are equally valid---at least in
	theory---whether you're working on a project by yourself, or
	with a hundred other people.</p>
<p><a name="x_77"></a>A key question about the practicality of revision control
	at these two different scales (“<span class="quote">lone hacker</span>” and
	“<span class="quote">huge team</span>”) is how its
	<span class="emphasis"><em>benefits</em></span> compare to its
	<span class="emphasis"><em>costs</em></span>.  A revision control tool that's
	difficult to understand or use is going to impose a high
	cost.</p>
<p><a name="x_78"></a>A five-hundred-person project is likely to collapse under
	its own weight almost immediately without a revision control
	tool and process. In this case, the cost of using revision
	control might hardly seem worth considering, since
	<span class="emphasis"><em>without</em></span> it, failure is almost
	guaranteed.</p>
<p><a name="x_79"></a>On the other hand, a one-person “<span class="quote">quick hack</span>”
	might seem like a poor place to use a revision control tool,
	because surely the cost of using one must be close to the
	overall cost of the project.  Right?</p>
<p><a name="x_7a"></a>Mercurial uniquely supports <span class="emphasis"><em>both</em></span> of
	these scales of development.  You can learn the basics in just
	a few minutes, and due to its low overhead, you can apply
	revision control to the smallest of projects with ease.  Its
	simplicity means you won't have a lot of abstruse concepts or
	command sequences competing for mental space with whatever
	you're <span class="emphasis"><em>really</em></span> trying to do.  At the same
	time, Mercurial's high performance and peer-to-peer nature let
	you scale painlessly to handle large projects.</p>
<p><a name="x_7b"></a>No revision control tool can rescue a poorly run project,
	but a good choice of tools can make a huge difference to the
	fluidity with which you can work on a project.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id467872"></a>1.2. The many names of revision control</h3></div></div></div>
<p><a name="x_7c"></a>Revision control is a diverse field, so much so that it is
	referred to by many names and acronyms.  Here are a few of the
	more common variations you'll encounter:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_7d"></a>Revision control (RCS)</p></li>
<li><p><a name="x_7e"></a>Software configuration management (SCM), or
	    configuration management</p></li>
<li><p><a name="x_7f"></a>Source code management</p></li>
<li><p><a name="x_80"></a>Source code control, or source
	    control</p></li>
<li><p><a name="x_81"></a>Version control
	    (VCS)</p></li>
</ul></div>
<p><a name="x_82"></a>Some people claim that these terms actually have different
	meanings, but in practice they overlap so much that there's no
	agreed or even useful way to tease them apart.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id468502"></a>2. This book is a work in progress</h2></div></div></div>
<p><a name="x_83"></a>I am releasing this book while I am still writing it, in the
      hope that it will prove useful to others.  I am writing under an
      open license in the hope that you, my readers, will contribute
      feedback and perhaps content of your own.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id468517"></a>3. About the examples in this book</h2></div></div></div>
<p><a name="x_84"></a>This book takes an unusual approach to code samples.  Every
      example is “<span class="quote">live</span>”---each one is actually the result
      of a shell script that executes the Mercurial commands you see.
      Every time an image of the book is built from its sources, all
      the example scripts are automatically run, and their current
      results compared against their expected results.</p>
<p><a name="x_85"></a>The advantage of this approach is that the examples are
      always accurate; they describe <span class="emphasis"><em>exactly</em></span> the
      behaviour of the version of Mercurial that's mentioned at the
      front of the book.  If I update the version of Mercurial that
      I'm documenting, and the output of some command changes, the
      build fails.</p>
<p><a name="x_86"></a>There is a small disadvantage to this approach, which is
      that the dates and times you'll see in examples tend to be
      “<span class="quote">squashed</span>” together in a way that they wouldn't be
      if the same commands were being typed by a human.  Where a human
      can issue no more than one command every few seconds, with any
      resulting timestamps correspondingly spread out, my automated
      example scripts run many commands in one second.</p>
<p><a name="x_87"></a>As an instance of this, several consecutive commits in an
      example can show up as having occurred during the same second.
      You can see this occur in the <code class="literal">bisect</code> example in <a class="xref" href="finding-and-fixing-mistakes.html#sec:undo:bisect" title="8.5. Finding the source of a bug">Section 8.5, “Finding the source of a bug”</a>, for instance.</p>
<p><a name="x_88"></a>So when you're reading examples, don't place too much weight
      on the dates or times you see in the output of commands.  But
      <span class="emphasis"><em>do</em></span> be confident that the behaviour you're
      seeing is consistent and reproducible.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id468194"></a>4. Trends in the field</h2></div></div></div>
<p><a name="x_89"></a>There has been an unmistakable trend in the development and
      use of revision control tools over the past four decades, as
      people have become familiar with the capabilities of their tools
      and constrained by their limitations.</p>
<p><a name="x_8a"></a>The first generation began by managing single files on
      individual computers.  Although these tools represented a huge
      advance over ad-hoc manual revision control, their locking model
      and reliance on a single computer limited them to small,
      tightly-knit teams.</p>
<p><a name="x_8b"></a>The second generation loosened these constraints by moving
      to network-centered architectures, and managing entire projects
      at a time.  As projects grew larger, they ran into new problems.
      With clients needing to talk to servers very frequently, server
      scaling became an issue for large projects.  An unreliable
      network connection could prevent remote users from being able to
      talk to the server at all.  As open source projects started
      making read-only access available anonymously to anyone, people
      without commit privileges found that they could not use the
      tools to interact with a project in a natural way, as they could
      not record their changes.</p>
<p><a name="x_8c"></a>The current generation of revision control tools is
      peer-to-peer in nature.  All of these systems have dropped the
      dependency on a single central server, and allow people to
      distribute their revision control data to where it's actually
      needed.  Collaboration over the Internet has moved from
      constrained by technology to a matter of choice and consensus.
      Modern tools can operate offline indefinitely and autonomously,
      with a network connection only needed when syncing changes with
      another repository.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id512343"></a>5. A few of the advantages of distributed revision
      control</h2></div></div></div>
<p><a name="x_8d"></a>Even though distributed revision control tools have for
      several years been as robust and usable as their
      previous-generation counterparts, people using older tools have
      not yet necessarily woken up to their advantages.  There are a
      number of ways in which distributed tools shine relative to
      centralised ones.</p>
<p><a name="x_8e"></a>For an individual developer, distributed tools are almost
      always much faster than centralised tools.  This is for a simple
      reason: a centralised tool needs to talk over the network for
      many common operations, because most metadata is stored in a
      single copy on the central server.  A distributed tool stores
      all of its metadata locally.  All else being equal, talking over
      the network adds overhead to a centralised tool.  Don't
      underestimate the value of a snappy, responsive tool: you're
      going to spend a lot of time interacting with your revision
      control software.</p>
<p><a name="x_8f"></a>Distributed tools are indifferent to the vagaries of your
      server infrastructure, again because they replicate metadata to
      so many locations.  If you use a centralised system and your
      server catches fire, you'd better hope that your backup media
      are reliable, and that your last backup was recent and actually
      worked.  With a distributed tool, you have many backups
      available on every contributor's computer.</p>
<p><a name="x_90"></a>The reliability of your network will affect distributed
      tools far less than it will centralised tools.  You can't even
      use a centralised tool without a network connection, except for
      a few highly constrained commands.  With a distributed tool, if
      your network connection goes down while you're working, you may
      not even notice.  The only thing you won't be able to do is talk
      to repositories on other computers, something that is relatively
      rare compared with local operations.  If you have a far-flung
      team of collaborators, this may be significant.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512390"></a>5.1. Advantages for open source projects</h3></div></div></div>
<p><a name="x_91"></a>If you take a shine to an open source project and decide
	that you would like to start hacking on it, and that project
	uses a distributed revision control tool, you are at once a
	peer with the people who consider themselves the
	“<span class="quote">core</span>” of that project.  If they publish their
	repositories, you can immediately copy their project history,
	start making changes, and record your work, using the same
	tools in the same ways as insiders.  By contrast, with a
	centralised tool, you must use the software in a “<span class="quote">read
	  only</span>” mode unless someone grants you permission to
	commit changes to their central server.  Until then, you won't
	be able to record changes, and your local modifications will
	be at risk of corruption any time you try to update your
	client's view of the repository.</p>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id512414"></a>5.1.1. The forking non-problem</h4></div></div></div>
<p><a name="x_92"></a>It has been suggested that distributed revision control
	  tools pose some sort of risk to open source projects because
	  they make it easy to “<span class="quote">fork</span>” the development of
	  a project.  A fork happens when there are differences in
	  opinion or attitude between groups of developers that cause
	  them to decide that they can't work together any longer.
	  Each side takes a more or less complete copy of the
	  project's source code, and goes off in its own
	  direction.</p>
<p><a name="x_93"></a>Sometimes the camps in a fork decide to reconcile their
	  differences. With a centralised revision control system, the
	  <span class="emphasis"><em>technical</em></span> process of reconciliation is
	  painful, and has to be performed largely by hand.  You have
	  to decide whose revision history is going to
	  “<span class="quote">win</span>”, and graft the other team's changes into
	  the tree somehow. This usually loses some or all of one
	  side's revision history.</p>
<p><a name="x_94"></a>What distributed tools do with respect to forking is
	  they make forking the <span class="emphasis"><em>only</em></span> way to
	  develop a project.  Every single change that you make is
	  potentially a fork point.  The great strength of this
	  approach is that a distributed revision control tool has to
	  be really good at <span class="emphasis"><em>merging</em></span> forks,
	  because forks are absolutely fundamental: they happen all
	  the time.</p>
<p><a name="x_95"></a>If every piece of work that everybody does, all the
	  time, is framed in terms of forking and merging, then what
	  the open source world refers to as a “<span class="quote">fork</span>”
	  becomes <span class="emphasis"><em>purely</em></span> a social issue.  If
	  anything, distributed tools <span class="emphasis"><em>lower</em></span> the
	  likelihood of a fork:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_96"></a>They eliminate the social distinction that
	      centralised tools impose: that between insiders (people
	      with commit access) and outsiders (people
	      without).</p></li>
<li><p><a name="x_97"></a>They make it easier to reconcile after a
	      social fork, because all that's involved from the
	      perspective of the revision control software is just
	      another merge.</p></li>
</ul></div>
<p><a name="x_98"></a>Some people resist distributed tools because they want
	  to retain tight control over their projects, and they
	  believe that centralised tools give them this control.
	  However, if you're of this belief, and you publish your CVS
	  or Subversion repositories publicly, there are plenty of
	  tools available that can pull out your entire project's
	  history (albeit slowly) and recreate it somewhere that you
	  don't control.  So while your control in this case is
	  illusory, you are forgoing the ability to fluidly
	  collaborate with whatever people feel compelled to mirror
	  and fork your history.</p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512508"></a>5.2. Advantages for commercial projects</h3></div></div></div>
<p><a name="x_99"></a>Many commercial projects are undertaken by teams that are
	scattered across the globe.  Contributors who are far from a
	central server will see slower command execution and perhaps
	less reliability.  Commercial revision control systems attempt
	to ameliorate these problems with remote-site replication
	add-ons that are typically expensive to buy and cantankerous
	to administer.  A distributed system doesn't suffer from these
	problems in the first place.  Better yet, you can easily set
	up multiple authoritative servers, say one per site, so that
	there's no redundant communication between repositories over
	expensive long-haul network links.</p>
<p><a name="x_9a"></a>Centralised revision control systems tend to have
	relatively low scalability.  It's not unusual for an expensive
	centralised system to fall over under the combined load of
	just a few dozen concurrent users.  Once again, the typical
	response tends to be an expensive and clunky replication
	facility.  Since the load on a central server---if you have
	one at all---is many times lower with a distributed tool
	(because all of the data is replicated everywhere), a single
	cheap server can handle the needs of a much larger team, and
	replication to balance load becomes a simple matter of
	scripting.</p>
<p><a name="x_9b"></a>If you have an employee in the field, troubleshooting a
	problem at a customer's site, they'll benefit from distributed
	revision control. The tool will let them generate custom
	builds, try different fixes in isolation from each other, and
	search efficiently through history for the sources of bugs and
	regressions in the customer's environment, all without needing
	to connect to your company's network.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id512545"></a>6. Why choose Mercurial?</h2></div></div></div>
<p><a name="x_9c"></a>Mercurial has a unique set of properties that make it a
      particularly good choice as a revision control system.</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_9d"></a>It is easy to learn and use.</p></li>
<li><p><a name="x_9e"></a>It is lightweight.</p></li>
<li><p><a name="x_9f"></a>It scales excellently.</p></li>
<li><p><a name="x_a0"></a>It is easy to
	  customise.</p></li>
</ul></div>
<p><a name="x_a1"></a>If you are at all familiar with revision control systems,
      you should be able to get up and running with Mercurial in less
      than five minutes.  Even if not, it will take no more than a few
      minutes longer.  Mercurial's command and feature sets are
      generally uniform and consistent, so you can keep track of a few
      general rules instead of a host of exceptions.</p>
<p><a name="x_a2"></a>On a small project, you can start working with Mercurial in
      moments. Creating new changes and branches; transferring changes
      around (whether locally or over a network); and history and
      status operations are all fast.  Mercurial attempts to stay
      nimble and largely out of your way by combining low cognitive
      overhead with blazingly fast operations.</p>
<p><a name="x_a3"></a>The usefulness of Mercurial is not limited to small
      projects: it is used by projects with hundreds to thousands of
      contributors, each containing tens of thousands of files and
      hundreds of megabytes of source code.</p>
<p><a name="x_a4"></a>If the core functionality of Mercurial is not enough for
      you, it's easy to build on.  Mercurial is well suited to
      scripting tasks, and its clean internals and implementation in
      Python make it easy to add features in the form of extensions.
      There are a number of popular and useful extensions already
      available, ranging from helping to identify bugs to improving
      performance.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id512618"></a>7. Mercurial compared with other tools</h2></div></div></div>
<p><a name="x_a5"></a>Before you read on, please understand that this section
      necessarily reflects my own experiences, interests, and (dare I
      say it) biases.  I have used every one of the revision control
      tools listed below, in most cases for several years at a
      time.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512631"></a>7.1. Subversion</h3></div></div></div>
<p><a name="x_a6"></a>Subversion is a popular revision control tool, developed
	to replace CVS.  It has a centralised client/server
	architecture.</p>
<p><a name="x_a7"></a>Subversion and Mercurial have similarly named commands for
	performing the same operations, so if you're familiar with
	one, it is easy to learn to use the other.  Both tools are
	portable to all popular operating systems.</p>
<p><a name="x_a8"></a>Prior to version 1.5, Subversion had no useful support for
	merges. At the time of writing, its merge tracking capability
	is new, and known to be <a class="ulink" href="http://svnbook.red-bean.com/nightly/en/svn.branchmerge.advanced.html#svn.branchmerge.advanced.finalword" target="_top">complicated 
	  and buggy</a>.</p>
<p><a name="x_a9"></a>Mercurial has a substantial performance advantage over
	Subversion on every revision control operation I have
	benchmarked.  I have measured its advantage as ranging from a
	factor of two to a factor of six when compared with Subversion
	1.4.3's <span class="emphasis"><em>ra_local</em></span> file store, which is the
	fastest access method available.  In more realistic
	deployments involving a network-based store, Subversion will
	be at a substantially larger disadvantage.  Because many
	Subversion commands must talk to the server and Subversion
	does not have useful replication facilities, server capacity
	and network bandwidth become bottlenecks for modestly large
	projects.</p>
<p><a name="x_aa"></a>Additionally, Subversion incurs substantial storage
	overhead to avoid network transactions for a few common
	operations, such as finding modified files
	(<code class="literal">status</code>) and displaying modifications
	against the current revision (<code class="literal">diff</code>).  As a
	result, a Subversion working copy is often the same size as,
	or larger than, a Mercurial repository and working directory,
	even though the Mercurial repository contains a complete
	history of the project.</p>
<p><a name="x_ab"></a>Subversion is widely supported by third party tools.
	Mercurial currently lags considerably in this area.  This gap
	is closing, however, and indeed some of Mercurial's GUI tools
	now outshine their Subversion equivalents.  Like Mercurial,
	Subversion has an excellent user manual.</p>
<p><a name="x_ac"></a>Because Subversion doesn't store revision history on the
	client, it is well suited to managing projects that deal with
	lots of large, opaque binary files.  If you check in fifty
	revisions to an incompressible 10MB file, Subversion's
	client-side space usage stays constant The space used by any
	distributed SCM will grow rapidly in proportion to the number
	of revisions, because the differences between each revision
	are large.</p>
<p><a name="x_ad"></a>In addition, it's often difficult or, more usually,
	impossible to merge different versions of a binary file.
	Subversion's ability to let a user lock a file, so that they
	temporarily have the exclusive right to commit changes to it,
	can be a significant advantage to a project where binary files
	are widely used.</p>
<p><a name="x_ae"></a>Mercurial can import revision history from a Subversion
	repository. It can also export revision history to a
	Subversion repository.  This makes it easy to “<span class="quote">test the
	  waters</span>” and use Mercurial and Subversion in parallel
	before deciding to switch.  History conversion is incremental,
	so you can perform an initial conversion, then small
	additional conversions afterwards to bring in new
	changes.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512734"></a>7.2. Git</h3></div></div></div>
<p><a name="x_af"></a>Git is a distributed revision control tool that was
	developed for managing the Linux kernel source tree.  Like
	Mercurial, its early design was somewhat influenced by
	Monotone.</p>
<p><a name="x_b0"></a>Git has a very large command set, with version 1.5.0
	providing 139 individual commands.  It has something of a
	reputation for being difficult to learn.  Compared to Git,
	Mercurial has a strong focus on simplicity.</p>
<p><a name="x_b1"></a>In terms of performance, Git is extremely fast.  In
	several cases, it is faster than Mercurial, at least on Linux,
	while Mercurial performs better on other operations.  However,
	on Windows, the performance and general level of support that
	Git provides is, at the time of writing, far behind that of
	Mercurial.</p>
<p><a name="x_b2"></a>While a Mercurial repository needs no maintenance, a Git
	repository requires frequent manual “<span class="quote">repacks</span>” of
	its metadata.  Without these, performance degrades, while
	space usage grows rapidly.  A server that contains many Git
	repositories that are not rigorously and frequently repacked
	will become heavily disk-bound during backups, and there have
	been instances of daily backups taking far longer than 24
	hours as a result.  A freshly packed Git repository is
	slightly smaller than a Mercurial repository, but an unpacked
	repository is several orders of magnitude larger.</p>
<p><a name="x_b3"></a>The core of Git is written in C.  Many Git commands are
	implemented as shell or Perl scripts, and the quality of these
	scripts varies widely. I have encountered several instances
	where scripts charged along blindly in the presence of errors
	that should have been fatal.</p>
<p><a name="x_b4"></a>Mercurial can import revision history from a Git
	repository.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512788"></a>7.3. CVS</h3></div></div></div>
<p><a name="x_b5"></a>CVS is probably the most widely used revision control tool
	in the world.  Due to its age and internal untidiness, it has
	been only lightly maintained for many years.</p>
<p><a name="x_b6"></a>It has a centralised client/server architecture.  It does
	not group related file changes into atomic commits, making it
	easy for people to “<span class="quote">break the build</span>”: one person
	can successfully commit part of a change and then be blocked
	by the need for a merge, causing other people to see only a
	portion of the work they intended to do.  This also affects
	how you work with project history.  If you want to see all of
	the modifications someone made as part of a task, you will
	need to manually inspect the descriptions and timestamps of
	the changes made to each file involved (if you even know what
	those files were).</p>
<p><a name="x_b7"></a>CVS has a muddled notion of tags and branches that I will
	not attempt to even describe.  It does not support renaming of
	files or directories well, making it easy to corrupt a
	repository.  It has almost no internal consistency checking
	capabilities, so it is usually not even possible to tell
	whether or how a repository is corrupt.  I would not recommend
	CVS for any project, existing or new.</p>
<p><a name="x_b8"></a>Mercurial can import CVS revision history.  However, there
	are a few caveats that apply; these are true of every other
	revision control tool's CVS importer, too.  Due to CVS's lack
	of atomic changes and unversioned filesystem hierarchy, it is
	not possible to reconstruct CVS history completely accurately;
	some guesswork is involved, and renames will usually not show
	up.  Because a lot of advanced CVS administration has to be
	done by hand and is hence error-prone, it's common for CVS
	importers to run into multiple problems with corrupted
	repositories (completely bogus revision timestamps and files
	that have remained locked for over a decade are just two of
	the less interesting problems I can recall from personal
	experience).</p>
<p><a name="x_b9"></a>Mercurial can import revision history from a CVS
	repository.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512840"></a>7.4. Commercial tools</h3></div></div></div>
<p><a name="x_ba"></a>Perforce has a centralised client/server architecture,
	with no client-side caching of any data.  Unlike modern
	revision control tools, Perforce requires that a user run a
	command to inform the server about every file they intend to
	edit.</p>
<p><a name="x_bb"></a>The performance of Perforce is quite good for small teams,
	but it falls off rapidly as the number of users grows beyond a
	few dozen. Modestly large Perforce installations require the
	deployment of proxies to cope with the load their users
	generate.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512862"></a>7.5. Choosing a revision control tool</h3></div></div></div>
<p><a name="x_bc"></a>With the exception of CVS, all of the tools listed above
	have unique strengths that suit them to particular styles of
	work.  There is no single revision control tool that is best
	in all situations.</p>
<p><a name="x_bd"></a>As an example, Subversion is a good choice for working
	with frequently edited binary files, due to its centralised
	nature and support for file locking.</p>
<p><a name="x_be"></a>I personally find Mercurial's properties of simplicity,
	performance, and good merge support to be a compelling
	combination that has served me well for several years.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id512890"></a>8. Switching from another tool to Mercurial</h2></div></div></div>
<p><a name="x_bf"></a>Mercurial is bundled with an extension named <code class="literal">convert</code>, which can incrementally
      import revision history from several other revision control
      tools.  By “<span class="quote">incremental</span>”, I mean that you can
      convert all of a project's history to date in one go, then rerun
      the conversion later to obtain new changes that happened after
      the initial conversion.</p>
<p><a name="x_c0"></a>The revision control tools supported by <code class="literal">convert</code> are as follows:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_c1"></a>Subversion</p></li>
<li><p><a name="x_c2"></a>CVS</p></li>
<li><p><a name="x_c3"></a>Git</p></li>
<li><p><a name="x_c4"></a>Darcs</p></li>
</ul></div>
<p><a name="x_c5"></a>In addition, <code class="literal">convert</code> can
      export changes from Mercurial to Subversion.  This makes it
      possible to try Subversion and Mercurial in parallel before
      committing to a switchover, without risking the loss of any
      work.</p>
<p><a name="x_c6"></a>The <span class="command"><strong>convert</strong></span> command
      is easy to use.  Simply point it at the path or URL of the
      source repository, optionally give it the name of the
      destination repository, and it will start working.  After the
      initial conversion, just run the same command again to import
      new changes.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id512983"></a>9. A short history of revision control</h2></div></div></div>
<p><a name="x_c7"></a>The best known of the old-time revision control tools is
      SCCS (Source Code Control System), which Marc Rochkind wrote at
      Bell Labs, in the early 1970s.  SCCS operated on individual
      files, and required every person working on a project to have
      access to a shared workspace on a single system.  Only one
      person could modify a file at any time; arbitration for access
      to files was via locks.  It was common for people to lock files,
      and later forget to unlock them, preventing anyone else from
      modifying those files without the help of an
      administrator.</p>
<p><a name="x_c8"></a>Walter Tichy developed a free alternative to SCCS in the
      early 1980s; he called his program RCS (Revision Control System).
      Like SCCS, RCS required developers to work in a single shared
      workspace, and to lock files to prevent multiple people from
      modifying them simultaneously.</p>
<p><a name="x_c9"></a>Later in the 1980s, Dick Grune used RCS as a building block
      for a set of shell scripts he initially called cmt, but then
      renamed to CVS (Concurrent Versions System).  The big innovation
      of CVS was that it let developers work simultaneously and
      somewhat independently in their own personal workspaces.  The
      personal workspaces prevented developers from stepping on each
      other's toes all the time, as was common with SCCS and RCS. Each
      developer had a copy of every project file, and could modify
      their copies independently.  They had to merge their edits prior
      to committing changes to the central repository.</p>
<p><a name="x_ca"></a>Brian Berliner took Grune's original scripts and rewrote
      them in C, releasing in 1989 the code that has since developed
      into the modern version of CVS.  CVS subsequently acquired the
      ability to operate over a network connection, giving it a
      client/server architecture.  CVS's architecture is centralised;
      only the server has a copy of the history of the project. Client
      workspaces just contain copies of recent versions of the
      project's files, and a little metadata to tell them where the
      server is.  CVS has been enormously successful; it is probably
      the world's most widely used revision control system.</p>
<p><a name="x_cb"></a>In the early 1990s, Sun Microsystems developed an early
      distributed revision control system, called TeamWare.  A
      TeamWare workspace contains a complete copy of the project's
      history.  TeamWare has no notion of a central repository.  (CVS
      relied upon RCS for its history storage; TeamWare used
      SCCS.)</p>
<p><a name="x_cc"></a>As the 1990s progressed, awareness grew of a number of
      problems with CVS.  It records simultaneous changes to multiple
      files individually, instead of grouping them together as a
      single logically atomic operation.  It does not manage its file
      hierarchy well; it is easy to make a mess of a repository by
      renaming files and directories.  Worse, its source code is
      difficult to read and maintain, which made the “<span class="quote">pain
	level</span>” of fixing these architectural problems
      prohibitive.</p>
<p><a name="x_cd"></a>In 2001, Jim Blandy and Karl Fogel, two developers who had
      worked on CVS, started a project to replace it with a tool that
      would have a better architecture and cleaner code.  The result,
      Subversion, does not stray from CVS's centralised client/server
      model, but it adds multi-file atomic commits, better namespace
      management, and a number of other features that make it a
      generally better tool than CVS. Since its initial release, it
      has rapidly grown in popularity.</p>
<p><a name="x_ce"></a>More or less simultaneously, Graydon Hoare began working on
      an ambitious distributed revision control system that he named
      Monotone. While Monotone addresses many of CVS's design flaws
      and has a peer-to-peer architecture, it goes beyond earlier (and
      subsequent) revision control tools in a number of innovative
      ways.  It uses cryptographic hashes as identifiers, and has an
      integral notion of “<span class="quote">trust</span>” for code from different
      sources.</p>
<p><a name="x_cf"></a>Mercurial began life in 2005.  While a few aspects of its
      design are influenced by Monotone, Mercurial focuses on ease of
      use, high performance, and scalability to very large
      projects.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id513084"></a>10. Colophon—this book is Free</h2></div></div></div>
<p><a name="x_d0"></a>This book is licensed under the Open Publication License,
      and is produced entirely using Free Software tools.  It is
      typeset with DocBook XML.  Illustrations are drawn and rendered with
      <a class="ulink" href="http://www.inkscape.org/" target="_top">Inkscape</a>.</p>
<p><a name="x_d1"></a>The complete source code for this book is published as a
      Mercurial repository, at <a class="ulink" href="http://hg.serpentine.com/mercurial/book" target="_top">http://hg.serpentine.com/mercurial/book</a>.</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="index.html">Prev</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="a-tour-of-mercurial-the-basics.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Mercurial: The Definitive Guide </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 1. A tour of Mercurial: the basics</td>
</tr>
</table>
</div>
</body>
</html>
